
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model DropPoint
 * 
 */
export type DropPoint = $Result.DefaultSelection<Prisma.$DropPointPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model Manager
 * 
 */
export type Manager = $Result.DefaultSelection<Prisma.$ManagerPayload>
/**
 * Model Donation
 * 
 */
export type Donation = $Result.DefaultSelection<Prisma.$DonationPayload>
/**
 * Model Feedback
 * 
 */
export type Feedback = $Result.DefaultSelection<Prisma.$FeedbackPayload>
/**
 * Model Peripheral
 * 
 */
export type Peripheral = $Result.DefaultSelection<Prisma.$PeripheralPayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model Advertisement
 * 
 */
export type Advertisement = $Result.DefaultSelection<Prisma.$AdvertisementPayload>
/**
 * Model AdInteraction
 * 
 */
export type AdInteraction = $Result.DefaultSelection<Prisma.$AdInteractionPayload>
/**
 * Model KeyValueStore
 * 
 */
export type KeyValueStore = $Result.DefaultSelection<Prisma.$KeyValueStorePayload>
/**
 * Model Listing
 * 
 */
export type Listing = $Result.DefaultSelection<Prisma.$ListingPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model SavedListing
 * 
 */
export type SavedListing = $Result.DefaultSelection<Prisma.$SavedListingPayload>
/**
 * Model Sale
 * 
 */
export type Sale = $Result.DefaultSelection<Prisma.$SalePayload>
/**
 * Model Rating
 * 
 */
export type Rating = $Result.DefaultSelection<Prisma.$RatingPayload>
/**
 * Model Photo
 * 
 */
export type Photo = $Result.DefaultSelection<Prisma.$PhotoPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Condition
 * 
 */
export type Condition = $Result.DefaultSelection<Prisma.$ConditionPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.dropPoint`: Exposes CRUD operations for the **DropPoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DropPoints
    * const dropPoints = await prisma.dropPoint.findMany()
    * ```
    */
  get dropPoint(): Prisma.DropPointDelegate<ExtArgs>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs>;

  /**
   * `prisma.manager`: Exposes CRUD operations for the **Manager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Managers
    * const managers = await prisma.manager.findMany()
    * ```
    */
  get manager(): Prisma.ManagerDelegate<ExtArgs>;

  /**
   * `prisma.donation`: Exposes CRUD operations for the **Donation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Donations
    * const donations = await prisma.donation.findMany()
    * ```
    */
  get donation(): Prisma.DonationDelegate<ExtArgs>;

  /**
   * `prisma.feedback`: Exposes CRUD operations for the **Feedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedback.findMany()
    * ```
    */
  get feedback(): Prisma.FeedbackDelegate<ExtArgs>;

  /**
   * `prisma.peripheral`: Exposes CRUD operations for the **Peripheral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Peripherals
    * const peripherals = await prisma.peripheral.findMany()
    * ```
    */
  get peripheral(): Prisma.PeripheralDelegate<ExtArgs>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs>;

  /**
   * `prisma.advertisement`: Exposes CRUD operations for the **Advertisement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Advertisements
    * const advertisements = await prisma.advertisement.findMany()
    * ```
    */
  get advertisement(): Prisma.AdvertisementDelegate<ExtArgs>;

  /**
   * `prisma.adInteraction`: Exposes CRUD operations for the **AdInteraction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdInteractions
    * const adInteractions = await prisma.adInteraction.findMany()
    * ```
    */
  get adInteraction(): Prisma.AdInteractionDelegate<ExtArgs>;

  /**
   * `prisma.keyValueStore`: Exposes CRUD operations for the **KeyValueStore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KeyValueStores
    * const keyValueStores = await prisma.keyValueStore.findMany()
    * ```
    */
  get keyValueStore(): Prisma.KeyValueStoreDelegate<ExtArgs>;

  /**
   * `prisma.listing`: Exposes CRUD operations for the **Listing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Listings
    * const listings = await prisma.listing.findMany()
    * ```
    */
  get listing(): Prisma.ListingDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.savedListing`: Exposes CRUD operations for the **SavedListing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedListings
    * const savedListings = await prisma.savedListing.findMany()
    * ```
    */
  get savedListing(): Prisma.SavedListingDelegate<ExtArgs>;

  /**
   * `prisma.sale`: Exposes CRUD operations for the **Sale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sales
    * const sales = await prisma.sale.findMany()
    * ```
    */
  get sale(): Prisma.SaleDelegate<ExtArgs>;

  /**
   * `prisma.rating`: Exposes CRUD operations for the **Rating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ratings
    * const ratings = await prisma.rating.findMany()
    * ```
    */
  get rating(): Prisma.RatingDelegate<ExtArgs>;

  /**
   * `prisma.photo`: Exposes CRUD operations for the **Photo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Photos
    * const photos = await prisma.photo.findMany()
    * ```
    */
  get photo(): Prisma.PhotoDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.condition`: Exposes CRUD operations for the **Condition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conditions
    * const conditions = await prisma.condition.findMany()
    * ```
    */
  get condition(): Prisma.ConditionDelegate<ExtArgs>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.2.0
   * Query Engine version: 4bc8b6e1b66cb932731fb1bdbbc550d1e010de81
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Organization: 'Organization',
    Document: 'Document',
    DropPoint: 'DropPoint',
    Admin: 'Admin',
    Manager: 'Manager',
    Donation: 'Donation',
    Feedback: 'Feedback',
    Peripheral: 'Peripheral',
    City: 'City',
    Advertisement: 'Advertisement',
    AdInteraction: 'AdInteraction',
    KeyValueStore: 'KeyValueStore',
    Listing: 'Listing',
    Report: 'Report',
    SavedListing: 'SavedListing',
    Sale: 'Sale',
    Rating: 'Rating',
    Photo: 'Photo',
    Category: 'Category',
    Condition: 'Condition',
    Conversation: 'Conversation',
    Message: 'Message'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'organization' | 'document' | 'dropPoint' | 'admin' | 'manager' | 'donation' | 'feedback' | 'peripheral' | 'city' | 'advertisement' | 'adInteraction' | 'keyValueStore' | 'listing' | 'report' | 'savedListing' | 'sale' | 'rating' | 'photo' | 'category' | 'condition' | 'conversation' | 'message'
      txIsolationLevel: never
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.OrganizationFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.OrganizationAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>,
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DocumentFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.DocumentAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      DropPoint: {
        payload: Prisma.$DropPointPayload<ExtArgs>
        fields: Prisma.DropPointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DropPointFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropPointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DropPointFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropPointPayload>
          }
          findFirst: {
            args: Prisma.DropPointFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropPointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DropPointFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropPointPayload>
          }
          findMany: {
            args: Prisma.DropPointFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropPointPayload>[]
          }
          create: {
            args: Prisma.DropPointCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropPointPayload>
          }
          createMany: {
            args: Prisma.DropPointCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DropPointDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropPointPayload>
          }
          update: {
            args: Prisma.DropPointUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropPointPayload>
          }
          deleteMany: {
            args: Prisma.DropPointDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DropPointUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DropPointUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropPointPayload>
          }
          aggregate: {
            args: Prisma.DropPointAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDropPoint>
          }
          groupBy: {
            args: Prisma.DropPointGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DropPointGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DropPointFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.DropPointAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.DropPointCountArgs<ExtArgs>,
            result: $Utils.Optional<DropPointCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AdminFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.AdminAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>,
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      Manager: {
        payload: Prisma.$ManagerPayload<ExtArgs>
        fields: Prisma.ManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManagerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManagerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          findFirst: {
            args: Prisma.ManagerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManagerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          findMany: {
            args: Prisma.ManagerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          create: {
            args: Prisma.ManagerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          createMany: {
            args: Prisma.ManagerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ManagerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          update: {
            args: Prisma.ManagerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          deleteMany: {
            args: Prisma.ManagerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ManagerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ManagerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          aggregate: {
            args: Prisma.ManagerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateManager>
          }
          groupBy: {
            args: Prisma.ManagerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ManagerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ManagerFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.ManagerAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.ManagerCountArgs<ExtArgs>,
            result: $Utils.Optional<ManagerCountAggregateOutputType> | number
          }
        }
      }
      Donation: {
        payload: Prisma.$DonationPayload<ExtArgs>
        fields: Prisma.DonationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DonationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DonationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DonationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          findFirst: {
            args: Prisma.DonationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DonationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DonationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          findMany: {
            args: Prisma.DonationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>[]
          }
          create: {
            args: Prisma.DonationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          createMany: {
            args: Prisma.DonationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DonationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          update: {
            args: Prisma.DonationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          deleteMany: {
            args: Prisma.DonationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DonationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DonationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          aggregate: {
            args: Prisma.DonationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDonation>
          }
          groupBy: {
            args: Prisma.DonationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DonationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DonationFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.DonationAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.DonationCountArgs<ExtArgs>,
            result: $Utils.Optional<DonationCountAggregateOutputType> | number
          }
        }
      }
      Feedback: {
        payload: Prisma.$FeedbackPayload<ExtArgs>
        fields: Prisma.FeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findFirst: {
            args: Prisma.FeedbackFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          findMany: {
            args: Prisma.FeedbackFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>[]
          }
          create: {
            args: Prisma.FeedbackCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          createMany: {
            args: Prisma.FeedbackCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FeedbackDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          update: {
            args: Prisma.FeedbackUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FeedbackUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FeedbackPayload>
          }
          aggregate: {
            args: Prisma.FeedbackAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFeedback>
          }
          groupBy: {
            args: Prisma.FeedbackGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FeedbackGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FeedbackFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.FeedbackAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.FeedbackCountArgs<ExtArgs>,
            result: $Utils.Optional<FeedbackCountAggregateOutputType> | number
          }
        }
      }
      Peripheral: {
        payload: Prisma.$PeripheralPayload<ExtArgs>
        fields: Prisma.PeripheralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PeripheralFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PeripheralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PeripheralFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PeripheralPayload>
          }
          findFirst: {
            args: Prisma.PeripheralFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PeripheralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PeripheralFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PeripheralPayload>
          }
          findMany: {
            args: Prisma.PeripheralFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PeripheralPayload>[]
          }
          create: {
            args: Prisma.PeripheralCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PeripheralPayload>
          }
          createMany: {
            args: Prisma.PeripheralCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PeripheralDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PeripheralPayload>
          }
          update: {
            args: Prisma.PeripheralUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PeripheralPayload>
          }
          deleteMany: {
            args: Prisma.PeripheralDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PeripheralUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PeripheralUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PeripheralPayload>
          }
          aggregate: {
            args: Prisma.PeripheralAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePeripheral>
          }
          groupBy: {
            args: Prisma.PeripheralGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PeripheralGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PeripheralFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.PeripheralAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.PeripheralCountArgs<ExtArgs>,
            result: $Utils.Optional<PeripheralCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CityFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.CityAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>,
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      Advertisement: {
        payload: Prisma.$AdvertisementPayload<ExtArgs>
        fields: Prisma.AdvertisementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdvertisementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdvertisementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          findFirst: {
            args: Prisma.AdvertisementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdvertisementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          findMany: {
            args: Prisma.AdvertisementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>[]
          }
          create: {
            args: Prisma.AdvertisementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          createMany: {
            args: Prisma.AdvertisementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdvertisementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          update: {
            args: Prisma.AdvertisementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          deleteMany: {
            args: Prisma.AdvertisementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdvertisementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdvertisementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          aggregate: {
            args: Prisma.AdvertisementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdvertisement>
          }
          groupBy: {
            args: Prisma.AdvertisementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdvertisementGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AdvertisementFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.AdvertisementAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.AdvertisementCountArgs<ExtArgs>,
            result: $Utils.Optional<AdvertisementCountAggregateOutputType> | number
          }
        }
      }
      AdInteraction: {
        payload: Prisma.$AdInteractionPayload<ExtArgs>
        fields: Prisma.AdInteractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdInteractionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdInteractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdInteractionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdInteractionPayload>
          }
          findFirst: {
            args: Prisma.AdInteractionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdInteractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdInteractionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdInteractionPayload>
          }
          findMany: {
            args: Prisma.AdInteractionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdInteractionPayload>[]
          }
          create: {
            args: Prisma.AdInteractionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdInteractionPayload>
          }
          createMany: {
            args: Prisma.AdInteractionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdInteractionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdInteractionPayload>
          }
          update: {
            args: Prisma.AdInteractionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdInteractionPayload>
          }
          deleteMany: {
            args: Prisma.AdInteractionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdInteractionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdInteractionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdInteractionPayload>
          }
          aggregate: {
            args: Prisma.AdInteractionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdInteraction>
          }
          groupBy: {
            args: Prisma.AdInteractionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdInteractionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AdInteractionFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.AdInteractionAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.AdInteractionCountArgs<ExtArgs>,
            result: $Utils.Optional<AdInteractionCountAggregateOutputType> | number
          }
        }
      }
      KeyValueStore: {
        payload: Prisma.$KeyValueStorePayload<ExtArgs>
        fields: Prisma.KeyValueStoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KeyValueStoreFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$KeyValueStorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KeyValueStoreFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$KeyValueStorePayload>
          }
          findFirst: {
            args: Prisma.KeyValueStoreFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$KeyValueStorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KeyValueStoreFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$KeyValueStorePayload>
          }
          findMany: {
            args: Prisma.KeyValueStoreFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$KeyValueStorePayload>[]
          }
          create: {
            args: Prisma.KeyValueStoreCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$KeyValueStorePayload>
          }
          createMany: {
            args: Prisma.KeyValueStoreCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.KeyValueStoreDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$KeyValueStorePayload>
          }
          update: {
            args: Prisma.KeyValueStoreUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$KeyValueStorePayload>
          }
          deleteMany: {
            args: Prisma.KeyValueStoreDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.KeyValueStoreUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.KeyValueStoreUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$KeyValueStorePayload>
          }
          aggregate: {
            args: Prisma.KeyValueStoreAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateKeyValueStore>
          }
          groupBy: {
            args: Prisma.KeyValueStoreGroupByArgs<ExtArgs>,
            result: $Utils.Optional<KeyValueStoreGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.KeyValueStoreFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.KeyValueStoreAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.KeyValueStoreCountArgs<ExtArgs>,
            result: $Utils.Optional<KeyValueStoreCountAggregateOutputType> | number
          }
        }
      }
      Listing: {
        payload: Prisma.$ListingPayload<ExtArgs>
        fields: Prisma.ListingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ListingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ListingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ListingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          findFirst: {
            args: Prisma.ListingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ListingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ListingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          findMany: {
            args: Prisma.ListingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>[]
          }
          create: {
            args: Prisma.ListingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          createMany: {
            args: Prisma.ListingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ListingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          update: {
            args: Prisma.ListingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          deleteMany: {
            args: Prisma.ListingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ListingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ListingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ListingPayload>
          }
          aggregate: {
            args: Prisma.ListingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateListing>
          }
          groupBy: {
            args: Prisma.ListingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ListingGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ListingFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.ListingAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.ListingCountArgs<ExtArgs>,
            result: $Utils.Optional<ListingCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ReportFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.ReportAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>,
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      SavedListing: {
        payload: Prisma.$SavedListingPayload<ExtArgs>
        fields: Prisma.SavedListingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SavedListingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SavedListingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SavedListingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SavedListingPayload>
          }
          findFirst: {
            args: Prisma.SavedListingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SavedListingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SavedListingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SavedListingPayload>
          }
          findMany: {
            args: Prisma.SavedListingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SavedListingPayload>[]
          }
          create: {
            args: Prisma.SavedListingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SavedListingPayload>
          }
          createMany: {
            args: Prisma.SavedListingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SavedListingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SavedListingPayload>
          }
          update: {
            args: Prisma.SavedListingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SavedListingPayload>
          }
          deleteMany: {
            args: Prisma.SavedListingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SavedListingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SavedListingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SavedListingPayload>
          }
          aggregate: {
            args: Prisma.SavedListingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSavedListing>
          }
          groupBy: {
            args: Prisma.SavedListingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SavedListingGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SavedListingFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.SavedListingAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.SavedListingCountArgs<ExtArgs>,
            result: $Utils.Optional<SavedListingCountAggregateOutputType> | number
          }
        }
      }
      Sale: {
        payload: Prisma.$SalePayload<ExtArgs>
        fields: Prisma.SaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findFirst: {
            args: Prisma.SaleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findMany: {
            args: Prisma.SaleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          create: {
            args: Prisma.SaleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          createMany: {
            args: Prisma.SaleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SaleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          update: {
            args: Prisma.SaleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          deleteMany: {
            args: Prisma.SaleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SaleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SaleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          aggregate: {
            args: Prisma.SaleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSale>
          }
          groupBy: {
            args: Prisma.SaleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SaleGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SaleFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.SaleAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.SaleCountArgs<ExtArgs>,
            result: $Utils.Optional<SaleCountAggregateOutputType> | number
          }
        }
      }
      Rating: {
        payload: Prisma.$RatingPayload<ExtArgs>
        fields: Prisma.RatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RatingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RatingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          findFirst: {
            args: Prisma.RatingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RatingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          findMany: {
            args: Prisma.RatingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>[]
          }
          create: {
            args: Prisma.RatingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          createMany: {
            args: Prisma.RatingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RatingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          update: {
            args: Prisma.RatingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          deleteMany: {
            args: Prisma.RatingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RatingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RatingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RatingPayload>
          }
          aggregate: {
            args: Prisma.RatingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRating>
          }
          groupBy: {
            args: Prisma.RatingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RatingGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.RatingFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.RatingAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.RatingCountArgs<ExtArgs>,
            result: $Utils.Optional<RatingCountAggregateOutputType> | number
          }
        }
      }
      Photo: {
        payload: Prisma.$PhotoPayload<ExtArgs>
        fields: Prisma.PhotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhotoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhotoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          findFirst: {
            args: Prisma.PhotoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhotoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          findMany: {
            args: Prisma.PhotoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>[]
          }
          create: {
            args: Prisma.PhotoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          createMany: {
            args: Prisma.PhotoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PhotoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          update: {
            args: Prisma.PhotoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          deleteMany: {
            args: Prisma.PhotoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PhotoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PhotoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PhotoPayload>
          }
          aggregate: {
            args: Prisma.PhotoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePhoto>
          }
          groupBy: {
            args: Prisma.PhotoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PhotoGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PhotoFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.PhotoAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.PhotoCountArgs<ExtArgs>,
            result: $Utils.Optional<PhotoCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CategoryFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.CategoryAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Condition: {
        payload: Prisma.$ConditionPayload<ExtArgs>
        fields: Prisma.ConditionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConditionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConditionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>
          }
          findFirst: {
            args: Prisma.ConditionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConditionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>
          }
          findMany: {
            args: Prisma.ConditionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>[]
          }
          create: {
            args: Prisma.ConditionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>
          }
          createMany: {
            args: Prisma.ConditionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConditionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>
          }
          update: {
            args: Prisma.ConditionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>
          }
          deleteMany: {
            args: Prisma.ConditionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConditionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConditionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConditionPayload>
          }
          aggregate: {
            args: Prisma.ConditionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCondition>
          }
          groupBy: {
            args: Prisma.ConditionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConditionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ConditionFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.ConditionAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.ConditionCountArgs<ExtArgs>,
            result: $Utils.Optional<ConditionCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ConversationFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.ConversationAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>,
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MessageFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.MessageAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>,
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    listings: number
    purchases: number
    conversationsInitiated: number
    conversationsReceived: number
    sentMessages: number
    givenRatings: number
    receivedRatings: number
    savedListings: number
    reportsMade: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    listings?: boolean | UserCountOutputTypeCountListingsArgs
    purchases?: boolean | UserCountOutputTypeCountPurchasesArgs
    conversationsInitiated?: boolean | UserCountOutputTypeCountConversationsInitiatedArgs
    conversationsReceived?: boolean | UserCountOutputTypeCountConversationsReceivedArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    givenRatings?: boolean | UserCountOutputTypeCountGivenRatingsArgs
    receivedRatings?: boolean | UserCountOutputTypeCountReceivedRatingsArgs
    savedListings?: boolean | UserCountOutputTypeCountSavedListingsArgs
    reportsMade?: boolean | UserCountOutputTypeCountReportsMadeArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchasesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsInitiatedArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsReceivedArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGivenRatingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedRatingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSavedListingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SavedListingWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsMadeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }



  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    submittedDocuments: number
    donations: number
    advertisements: number
    feedbacksGiven: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    submittedDocuments?: boolean | OrganizationCountOutputTypeCountSubmittedDocumentsArgs
    donations?: boolean | OrganizationCountOutputTypeCountDonationsArgs
    advertisements?: boolean | OrganizationCountOutputTypeCountAdvertisementsArgs
    feedbacksGiven?: boolean | OrganizationCountOutputTypeCountFeedbacksGivenArgs
  }

  // Custom InputTypes

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountSubmittedDocumentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountDonationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DonationWhereInput
  }


  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountAdvertisementsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AdvertisementWhereInput
  }


  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountFeedbacksGivenArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }



  /**
   * Count Type DropPointCountOutputType
   */

  export type DropPointCountOutputType = {
    donations: number
    feedbacksGiven: number
  }

  export type DropPointCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    donations?: boolean | DropPointCountOutputTypeCountDonationsArgs
    feedbacksGiven?: boolean | DropPointCountOutputTypeCountFeedbacksGivenArgs
  }

  // Custom InputTypes

  /**
   * DropPointCountOutputType without action
   */
  export type DropPointCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPointCountOutputType
     */
    select?: DropPointCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DropPointCountOutputType without action
   */
  export type DropPointCountOutputTypeCountDonationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DonationWhereInput
  }


  /**
   * DropPointCountOutputType without action
   */
  export type DropPointCountOutputTypeCountFeedbacksGivenArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
  }



  /**
   * Count Type ManagerCountOutputType
   */

  export type ManagerCountOutputType = {
    dropPoint: number
  }

  export type ManagerCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    dropPoint?: boolean | ManagerCountOutputTypeCountDropPointArgs
  }

  // Custom InputTypes

  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerCountOutputType
     */
    select?: ManagerCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeCountDropPointArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DropPointWhereInput
  }



  /**
   * Count Type DonationCountOutputType
   */

  export type DonationCountOutputType = {
    peripherals: number
  }

  export type DonationCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    peripherals?: boolean | DonationCountOutputTypeCountPeripheralsArgs
  }

  // Custom InputTypes

  /**
   * DonationCountOutputType without action
   */
  export type DonationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DonationCountOutputType
     */
    select?: DonationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DonationCountOutputType without action
   */
  export type DonationCountOutputTypeCountPeripheralsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PeripheralWhereInput
  }



  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    users: number
    advertisements: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | CityCountOutputTypeCountUsersArgs
    advertisements?: boolean | CityCountOutputTypeCountAdvertisementsArgs
  }

  // Custom InputTypes

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountAdvertisementsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AdvertisementWhereInput
  }



  /**
   * Count Type AdvertisementCountOutputType
   */

  export type AdvertisementCountOutputType = {
    interactions: number
  }

  export type AdvertisementCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    interactions?: boolean | AdvertisementCountOutputTypeCountInteractionsArgs
  }

  // Custom InputTypes

  /**
   * AdvertisementCountOutputType without action
   */
  export type AdvertisementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisementCountOutputType
     */
    select?: AdvertisementCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AdvertisementCountOutputType without action
   */
  export type AdvertisementCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AdInteractionWhereInput
  }



  /**
   * Count Type ListingCountOutputType
   */

  export type ListingCountOutputType = {
    photos: number
    sales: number
    conversations: number
    savedByUsers: number
    reports: number
  }

  export type ListingCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    photos?: boolean | ListingCountOutputTypeCountPhotosArgs
    sales?: boolean | ListingCountOutputTypeCountSalesArgs
    conversations?: boolean | ListingCountOutputTypeCountConversationsArgs
    savedByUsers?: boolean | ListingCountOutputTypeCountSavedByUsersArgs
    reports?: boolean | ListingCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes

  /**
   * ListingCountOutputType without action
   */
  export type ListingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ListingCountOutputType
     */
    select?: ListingCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ListingCountOutputType without action
   */
  export type ListingCountOutputTypeCountPhotosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PhotoWhereInput
  }


  /**
   * ListingCountOutputType without action
   */
  export type ListingCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }


  /**
   * ListingCountOutputType without action
   */
  export type ListingCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }


  /**
   * ListingCountOutputType without action
   */
  export type ListingCountOutputTypeCountSavedByUsersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SavedListingWhereInput
  }


  /**
   * ListingCountOutputType without action
   */
  export type ListingCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }



  /**
   * Count Type SaleCountOutputType
   */

  export type SaleCountOutputType = {
    rating: number
  }

  export type SaleCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    rating?: boolean | SaleCountOutputTypeCountRatingArgs
  }

  // Custom InputTypes

  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SaleCountOutputType
     */
    select?: SaleCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SaleCountOutputType without action
   */
  export type SaleCountOutputTypeCountRatingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
  }



  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    listings: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    listings?: boolean | CategoryCountOutputTypeCountListingsArgs
  }

  // Custom InputTypes

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
  }



  /**
   * Count Type ConditionCountOutputType
   */

  export type ConditionCountOutputType = {
    listings: number
  }

  export type ConditionCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    listings?: boolean | ConditionCountOutputTypeCountListingsArgs
  }

  // Custom InputTypes

  /**
   * ConditionCountOutputType without action
   */
  export type ConditionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConditionCountOutputType
     */
    select?: ConditionCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ConditionCountOutputType without action
   */
  export type ConditionCountOutputTypeCountListingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
  }



  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    messages: number
    Sale: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
    Sale?: boolean | ConversationCountOutputTypeCountSaleArgs
  }

  // Custom InputTypes

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountSaleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    reportedListingCount: number | null
  }

  export type UserSumAggregateOutputType = {
    reportedListingCount: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    password: string | null
    cityId: string | null
    gender: string | null
    contactNumber: string | null
    profilePicture: Buffer | null
    createdAt: Date | null
    reportedListingCount: number | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    password: string | null
    cityId: string | null
    gender: string | null
    contactNumber: string | null
    profilePicture: Buffer | null
    createdAt: Date | null
    reportedListingCount: number | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    firstName: number
    lastName: number
    password: number
    cityId: number
    gender: number
    contactNumber: number
    profilePicture: number
    createdAt: number
    reportedListingCount: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    reportedListingCount?: true
  }

  export type UserSumAggregateInputType = {
    reportedListingCount?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    password?: true
    cityId?: true
    gender?: true
    contactNumber?: true
    profilePicture?: true
    createdAt?: true
    reportedListingCount?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    password?: true
    cityId?: true
    gender?: true
    contactNumber?: true
    profilePicture?: true
    createdAt?: true
    reportedListingCount?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    password?: true
    cityId?: true
    gender?: true
    contactNumber?: true
    profilePicture?: true
    createdAt?: true
    reportedListingCount?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    firstName: string
    lastName: string
    password: string
    cityId: string
    gender: string
    contactNumber: string
    profilePicture: Buffer | null
    createdAt: Date
    reportedListingCount: number
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    cityId?: boolean
    gender?: boolean
    contactNumber?: boolean
    profilePicture?: boolean
    createdAt?: boolean
    reportedListingCount?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
    listings?: boolean | User$listingsArgs<ExtArgs>
    purchases?: boolean | User$purchasesArgs<ExtArgs>
    conversationsInitiated?: boolean | User$conversationsInitiatedArgs<ExtArgs>
    conversationsReceived?: boolean | User$conversationsReceivedArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    givenRatings?: boolean | User$givenRatingsArgs<ExtArgs>
    receivedRatings?: boolean | User$receivedRatingsArgs<ExtArgs>
    savedListings?: boolean | User$savedListingsArgs<ExtArgs>
    reportsMade?: boolean | User$reportsMadeArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    cityId?: boolean
    gender?: boolean
    contactNumber?: boolean
    profilePicture?: boolean
    createdAt?: boolean
    reportedListingCount?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
    listings?: boolean | User$listingsArgs<ExtArgs>
    purchases?: boolean | User$purchasesArgs<ExtArgs>
    conversationsInitiated?: boolean | User$conversationsInitiatedArgs<ExtArgs>
    conversationsReceived?: boolean | User$conversationsReceivedArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    givenRatings?: boolean | User$givenRatingsArgs<ExtArgs>
    receivedRatings?: boolean | User$receivedRatingsArgs<ExtArgs>
    savedListings?: boolean | User$savedListingsArgs<ExtArgs>
    reportsMade?: boolean | User$reportsMadeArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
      listings: Prisma.$ListingPayload<ExtArgs>[]
      purchases: Prisma.$SalePayload<ExtArgs>[]
      conversationsInitiated: Prisma.$ConversationPayload<ExtArgs>[]
      conversationsReceived: Prisma.$ConversationPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      givenRatings: Prisma.$RatingPayload<ExtArgs>[]
      receivedRatings: Prisma.$RatingPayload<ExtArgs>[]
      savedListings: Prisma.$SavedListingPayload<ExtArgs>[]
      reportsMade: Prisma.$ReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      email: string
      firstName: string
      lastName: string
      password: string
      cityId: string
      gender: string
      contactNumber: string
      profilePicture: Buffer | null
      createdAt: Date
      reportedListingCount: number
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: UserFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: UserAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    listings<T extends User$listingsArgs<ExtArgs> = {}>(args?: Subset<T, User$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, 'findMany'> | Null>;

    purchases<T extends User$purchasesArgs<ExtArgs> = {}>(args?: Subset<T, User$purchasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, 'findMany'> | Null>;

    conversationsInitiated<T extends User$conversationsInitiatedArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationsInitiatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findMany'> | Null>;

    conversationsReceived<T extends User$conversationsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findMany'> | Null>;

    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findMany'> | Null>;

    givenRatings<T extends User$givenRatingsArgs<ExtArgs> = {}>(args?: Subset<T, User$givenRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'findMany'> | Null>;

    receivedRatings<T extends User$receivedRatingsArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedRatingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'findMany'> | Null>;

    savedListings<T extends User$savedListingsArgs<ExtArgs> = {}>(args?: Subset<T, User$savedListingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedListingPayload<ExtArgs>, T, 'findMany'> | Null>;

    reportsMade<T extends User$reportsMadeArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsMadeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly cityId: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'String'>
    readonly contactNumber: FieldRef<"User", 'String'>
    readonly profilePicture: FieldRef<"User", 'Bytes'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly reportedListingCount: FieldRef<"User", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * User.listings
   */
  export type User$listingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    cursor?: ListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }


  /**
   * User.purchases
   */
  export type User$purchasesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }


  /**
   * User.conversationsInitiated
   */
  export type User$conversationsInitiatedArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }


  /**
   * User.conversationsReceived
   */
  export type User$conversationsReceivedArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }


  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * User.givenRatings
   */
  export type User$givenRatingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    cursor?: RatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }


  /**
   * User.receivedRatings
   */
  export type User$receivedRatingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    cursor?: RatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }


  /**
   * User.savedListings
   */
  export type User$savedListingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedListing
     */
    select?: SavedListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SavedListingInclude<ExtArgs> | null
    where?: SavedListingWhereInput
    orderBy?: SavedListingOrderByWithRelationInput | SavedListingOrderByWithRelationInput[]
    cursor?: SavedListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedListingScalarFieldEnum | SavedListingScalarFieldEnum[]
  }


  /**
   * User.reportsMade
   */
  export type User$reportsMadeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationAvgAggregateOutputType = {
    lifetimePoints: number | null
    totalPoints: number | null
  }

  export type OrganizationSumAggregateOutputType = {
    lifetimePoints: number | null
    totalPoints: number | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    organizationname: string | null
    email: string | null
    password: string | null
    address: string | null
    contactNumber: string | null
    secRegistrationNumber: string | null
    verificationStatus: string | null
    lifetimePoints: number | null
    totalPoints: number | null
    type: string | null
    profilePicture: Buffer | null
    createdAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    organizationname: string | null
    email: string | null
    password: string | null
    address: string | null
    contactNumber: string | null
    secRegistrationNumber: string | null
    verificationStatus: string | null
    lifetimePoints: number | null
    totalPoints: number | null
    type: string | null
    profilePicture: Buffer | null
    createdAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    organizationname: number
    email: number
    password: number
    address: number
    contactNumber: number
    secRegistrationNumber: number
    verificationStatus: number
    lifetimePoints: number
    totalPoints: number
    type: number
    profilePicture: number
    createdAt: number
    _all: number
  }


  export type OrganizationAvgAggregateInputType = {
    lifetimePoints?: true
    totalPoints?: true
  }

  export type OrganizationSumAggregateInputType = {
    lifetimePoints?: true
    totalPoints?: true
  }

  export type OrganizationMinAggregateInputType = {
    id?: true
    organizationname?: true
    email?: true
    password?: true
    address?: true
    contactNumber?: true
    secRegistrationNumber?: true
    verificationStatus?: true
    lifetimePoints?: true
    totalPoints?: true
    type?: true
    profilePicture?: true
    createdAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    organizationname?: true
    email?: true
    password?: true
    address?: true
    contactNumber?: true
    secRegistrationNumber?: true
    verificationStatus?: true
    lifetimePoints?: true
    totalPoints?: true
    type?: true
    profilePicture?: true
    createdAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    organizationname?: true
    email?: true
    password?: true
    address?: true
    contactNumber?: true
    secRegistrationNumber?: true
    verificationStatus?: true
    lifetimePoints?: true
    totalPoints?: true
    type?: true
    profilePicture?: true
    createdAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _avg?: OrganizationAvgAggregateInputType
    _sum?: OrganizationSumAggregateInputType
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber: string | null
    verificationStatus: string
    lifetimePoints: number
    totalPoints: number
    type: string
    profilePicture: Buffer | null
    createdAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationname?: boolean
    email?: boolean
    password?: boolean
    address?: boolean
    contactNumber?: boolean
    secRegistrationNumber?: boolean
    verificationStatus?: boolean
    lifetimePoints?: boolean
    totalPoints?: boolean
    type?: boolean
    profilePicture?: boolean
    createdAt?: boolean
    submittedDocuments?: boolean | Organization$submittedDocumentsArgs<ExtArgs>
    donations?: boolean | Organization$donationsArgs<ExtArgs>
    advertisements?: boolean | Organization$advertisementsArgs<ExtArgs>
    feedbacksGiven?: boolean | Organization$feedbacksGivenArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    organizationname?: boolean
    email?: boolean
    password?: boolean
    address?: boolean
    contactNumber?: boolean
    secRegistrationNumber?: boolean
    verificationStatus?: boolean
    lifetimePoints?: boolean
    totalPoints?: boolean
    type?: boolean
    profilePicture?: boolean
    createdAt?: boolean
  }

  export type OrganizationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    submittedDocuments?: boolean | Organization$submittedDocumentsArgs<ExtArgs>
    donations?: boolean | Organization$donationsArgs<ExtArgs>
    advertisements?: boolean | Organization$advertisementsArgs<ExtArgs>
    feedbacksGiven?: boolean | Organization$feedbacksGivenArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $OrganizationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      submittedDocuments: Prisma.$DocumentPayload<ExtArgs>[]
      donations: Prisma.$DonationPayload<ExtArgs>[]
      advertisements: Prisma.$AdvertisementPayload<ExtArgs>[]
      feedbacksGiven: Prisma.$FeedbackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      organizationname: string
      email: string
      password: string
      address: string
      contactNumber: string
      secRegistrationNumber: string | null
      verificationStatus: string
      lifetimePoints: number
      totalPoints: number
      type: string
      profilePicture: Buffer | null
      createdAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }


  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OrganizationFindManyArgs, 'select' | 'include'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrganizationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Organization that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrganizationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrganizationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
    **/
    create<T extends OrganizationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Organizations.
     *     @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     *     @example
     *     // Create many Organizations
     *     const organization = await prisma.organization.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrganizationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
    **/
    delete<T extends OrganizationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrganizationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrganizationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrganizationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
    **/
    upsert<T extends OrganizationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * @param {OrganizationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const organization = await prisma.organization.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: OrganizationFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Organization.
     * @param {OrganizationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const organization = await prisma.organization.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: OrganizationAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    submittedDocuments<T extends Organization$submittedDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$submittedDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'> | Null>;

    donations<T extends Organization$donationsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$donationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'findMany'> | Null>;

    advertisements<T extends Organization$advertisementsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$advertisementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findMany'> | Null>;

    feedbacksGiven<T extends Organization$feedbacksGivenArgs<ExtArgs> = {}>(args?: Subset<T, Organization$feedbacksGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Organization model
   */ 
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly organizationname: FieldRef<"Organization", 'String'>
    readonly email: FieldRef<"Organization", 'String'>
    readonly password: FieldRef<"Organization", 'String'>
    readonly address: FieldRef<"Organization", 'String'>
    readonly contactNumber: FieldRef<"Organization", 'String'>
    readonly secRegistrationNumber: FieldRef<"Organization", 'String'>
    readonly verificationStatus: FieldRef<"Organization", 'String'>
    readonly lifetimePoints: FieldRef<"Organization", 'Float'>
    readonly totalPoints: FieldRef<"Organization", 'Float'>
    readonly type: FieldRef<"Organization", 'String'>
    readonly profilePicture: FieldRef<"Organization", 'Bytes'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }


  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }


  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }


  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }


  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
  }


  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
  }


  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }


  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
  }


  /**
   * Organization findRaw
   */
  export type OrganizationFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Organization aggregateRaw
   */
  export type OrganizationAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Organization.submittedDocuments
   */
  export type Organization$submittedDocumentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Organization.donations
   */
  export type Organization$donationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    where?: DonationWhereInput
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    cursor?: DonationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }


  /**
   * Organization.advertisements
   */
  export type Organization$advertisementsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    where?: AdvertisementWhereInput
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    cursor?: AdvertisementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }


  /**
   * Organization.feedbacksGiven
   */
  export type Organization$feedbacksGivenArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }


  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
  }



  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    filename: string | null
    url: string | null
    uploadedBy: string | null
    organizationId: string | null
    createdAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    filename: string | null
    url: string | null
    uploadedBy: string | null
    organizationId: string | null
    createdAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    filename: number
    url: number
    uploadedBy: number
    organizationId: number
    createdAt: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    filename?: true
    url?: true
    uploadedBy?: true
    organizationId?: true
    createdAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    filename?: true
    url?: true
    uploadedBy?: true
    organizationId?: true
    createdAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    filename?: true
    url?: true
    uploadedBy?: true
    organizationId?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    filename: string
    url: string
    uploadedBy: string
    organizationId: string | null
    createdAt: Date
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    url?: boolean
    uploadedBy?: boolean
    organizationId?: boolean
    createdAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    filename?: boolean
    url?: boolean
    uploadedBy?: boolean
    organizationId?: boolean
    createdAt?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }


  export type $DocumentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      filename: string
      url: string
      uploadedBy: string
      organizationId: string | null
      createdAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }


  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
    **/
    create<T extends DocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Documents.
     *     @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     *     @example
     *     // Create many Documents
     *     const document = await prisma.document.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
    **/
    delete<T extends DocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * @param {DocumentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const document = await prisma.document.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: DocumentFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Document.
     * @param {DocumentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const document = await prisma.document.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: DocumentAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly filename: FieldRef<"Document", 'String'>
    readonly url: FieldRef<"Document", 'String'>
    readonly uploadedBy: FieldRef<"Document", 'String'>
    readonly organizationId: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }


  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
  }


  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }


  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }


  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }


  /**
   * Document findRaw
   */
  export type DocumentFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Document aggregateRaw
   */
  export type DocumentAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
  }



  /**
   * Model DropPoint
   */

  export type AggregateDropPoint = {
    _count: DropPointCountAggregateOutputType | null
    _min: DropPointMinAggregateOutputType | null
    _max: DropPointMaxAggregateOutputType | null
  }

  export type DropPointMinAggregateOutputType = {
    id: string | null
    name: string | null
    location: string | null
    openingTime: string | null
    closingTime: string | null
    description: string | null
    managerId: string | null
    password: string | null
  }

  export type DropPointMaxAggregateOutputType = {
    id: string | null
    name: string | null
    location: string | null
    openingTime: string | null
    closingTime: string | null
    description: string | null
    managerId: string | null
    password: string | null
  }

  export type DropPointCountAggregateOutputType = {
    id: number
    name: number
    location: number
    openingTime: number
    closingTime: number
    description: number
    managerId: number
    password: number
    _all: number
  }


  export type DropPointMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    openingTime?: true
    closingTime?: true
    description?: true
    managerId?: true
    password?: true
  }

  export type DropPointMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    openingTime?: true
    closingTime?: true
    description?: true
    managerId?: true
    password?: true
  }

  export type DropPointCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    openingTime?: true
    closingTime?: true
    description?: true
    managerId?: true
    password?: true
    _all?: true
  }

  export type DropPointAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DropPoint to aggregate.
     */
    where?: DropPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropPoints to fetch.
     */
    orderBy?: DropPointOrderByWithRelationInput | DropPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DropPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DropPoints
    **/
    _count?: true | DropPointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DropPointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DropPointMaxAggregateInputType
  }

  export type GetDropPointAggregateType<T extends DropPointAggregateArgs> = {
        [P in keyof T & keyof AggregateDropPoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDropPoint[P]>
      : GetScalarType<T[P], AggregateDropPoint[P]>
  }




  export type DropPointGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DropPointWhereInput
    orderBy?: DropPointOrderByWithAggregationInput | DropPointOrderByWithAggregationInput[]
    by: DropPointScalarFieldEnum[] | DropPointScalarFieldEnum
    having?: DropPointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DropPointCountAggregateInputType | true
    _min?: DropPointMinAggregateInputType
    _max?: DropPointMaxAggregateInputType
  }

  export type DropPointGroupByOutputType = {
    id: string
    name: string
    location: string
    openingTime: string
    closingTime: string
    description: string
    managerId: string | null
    password: string | null
    _count: DropPointCountAggregateOutputType | null
    _min: DropPointMinAggregateOutputType | null
    _max: DropPointMaxAggregateOutputType | null
  }

  type GetDropPointGroupByPayload<T extends DropPointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DropPointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DropPointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DropPointGroupByOutputType[P]>
            : GetScalarType<T[P], DropPointGroupByOutputType[P]>
        }
      >
    >


  export type DropPointSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    openingTime?: boolean
    closingTime?: boolean
    description?: boolean
    managerId?: boolean
    password?: boolean
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
    donations?: boolean | DropPoint$donationsArgs<ExtArgs>
    feedbacksGiven?: boolean | DropPoint$feedbacksGivenArgs<ExtArgs>
    _count?: boolean | DropPointCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dropPoint"]>

  export type DropPointSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    openingTime?: boolean
    closingTime?: boolean
    description?: boolean
    managerId?: boolean
    password?: boolean
  }

  export type DropPointInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
    donations?: boolean | DropPoint$donationsArgs<ExtArgs>
    feedbacksGiven?: boolean | DropPoint$feedbacksGivenArgs<ExtArgs>
    _count?: boolean | DropPointCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DropPointPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "DropPoint"
    objects: {
      manager: Prisma.$ManagerPayload<ExtArgs> | null
      donations: Prisma.$DonationPayload<ExtArgs>[]
      feedbacksGiven: Prisma.$FeedbackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      name: string
      location: string
      openingTime: string
      closingTime: string
      description: string
      managerId: string | null
      password: string | null
    }, ExtArgs["result"]["dropPoint"]>
    composites: {}
  }


  type DropPointGetPayload<S extends boolean | null | undefined | DropPointDefaultArgs> = $Result.GetResult<Prisma.$DropPointPayload, S>

  type DropPointCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DropPointFindManyArgs, 'select' | 'include'> & {
      select?: DropPointCountAggregateInputType | true
    }

  export interface DropPointDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DropPoint'], meta: { name: 'DropPoint' } }
    /**
     * Find zero or one DropPoint that matches the filter.
     * @param {DropPointFindUniqueArgs} args - Arguments to find a DropPoint
     * @example
     * // Get one DropPoint
     * const dropPoint = await prisma.dropPoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DropPointFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DropPointFindUniqueArgs<ExtArgs>>
    ): Prisma__DropPointClient<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DropPoint that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DropPointFindUniqueOrThrowArgs} args - Arguments to find a DropPoint
     * @example
     * // Get one DropPoint
     * const dropPoint = await prisma.dropPoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DropPointFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DropPointFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DropPointClient<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DropPoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropPointFindFirstArgs} args - Arguments to find a DropPoint
     * @example
     * // Get one DropPoint
     * const dropPoint = await prisma.dropPoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DropPointFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DropPointFindFirstArgs<ExtArgs>>
    ): Prisma__DropPointClient<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DropPoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropPointFindFirstOrThrowArgs} args - Arguments to find a DropPoint
     * @example
     * // Get one DropPoint
     * const dropPoint = await prisma.dropPoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DropPointFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DropPointFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DropPointClient<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DropPoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropPointFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DropPoints
     * const dropPoints = await prisma.dropPoint.findMany()
     * 
     * // Get first 10 DropPoints
     * const dropPoints = await prisma.dropPoint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dropPointWithIdOnly = await prisma.dropPoint.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DropPointFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DropPointFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DropPoint.
     * @param {DropPointCreateArgs} args - Arguments to create a DropPoint.
     * @example
     * // Create one DropPoint
     * const DropPoint = await prisma.dropPoint.create({
     *   data: {
     *     // ... data to create a DropPoint
     *   }
     * })
     * 
    **/
    create<T extends DropPointCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DropPointCreateArgs<ExtArgs>>
    ): Prisma__DropPointClient<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DropPoints.
     *     @param {DropPointCreateManyArgs} args - Arguments to create many DropPoints.
     *     @example
     *     // Create many DropPoints
     *     const dropPoint = await prisma.dropPoint.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DropPointCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DropPointCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DropPoint.
     * @param {DropPointDeleteArgs} args - Arguments to delete one DropPoint.
     * @example
     * // Delete one DropPoint
     * const DropPoint = await prisma.dropPoint.delete({
     *   where: {
     *     // ... filter to delete one DropPoint
     *   }
     * })
     * 
    **/
    delete<T extends DropPointDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DropPointDeleteArgs<ExtArgs>>
    ): Prisma__DropPointClient<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DropPoint.
     * @param {DropPointUpdateArgs} args - Arguments to update one DropPoint.
     * @example
     * // Update one DropPoint
     * const dropPoint = await prisma.dropPoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DropPointUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DropPointUpdateArgs<ExtArgs>>
    ): Prisma__DropPointClient<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DropPoints.
     * @param {DropPointDeleteManyArgs} args - Arguments to filter DropPoints to delete.
     * @example
     * // Delete a few DropPoints
     * const { count } = await prisma.dropPoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DropPointDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DropPointDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DropPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropPointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DropPoints
     * const dropPoint = await prisma.dropPoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DropPointUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DropPointUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DropPoint.
     * @param {DropPointUpsertArgs} args - Arguments to update or create a DropPoint.
     * @example
     * // Update or create a DropPoint
     * const dropPoint = await prisma.dropPoint.upsert({
     *   create: {
     *     // ... data to create a DropPoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DropPoint we want to update
     *   }
     * })
    **/
    upsert<T extends DropPointUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DropPointUpsertArgs<ExtArgs>>
    ): Prisma__DropPointClient<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more DropPoints that matches the filter.
     * @param {DropPointFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dropPoint = await prisma.dropPoint.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: DropPointFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DropPoint.
     * @param {DropPointAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dropPoint = await prisma.dropPoint.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: DropPointAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of DropPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropPointCountArgs} args - Arguments to filter DropPoints to count.
     * @example
     * // Count the number of DropPoints
     * const count = await prisma.dropPoint.count({
     *   where: {
     *     // ... the filter for the DropPoints we want to count
     *   }
     * })
    **/
    count<T extends DropPointCountArgs>(
      args?: Subset<T, DropPointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DropPointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DropPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropPointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DropPointAggregateArgs>(args: Subset<T, DropPointAggregateArgs>): Prisma.PrismaPromise<GetDropPointAggregateType<T>>

    /**
     * Group by DropPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropPointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DropPointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DropPointGroupByArgs['orderBy'] }
        : { orderBy?: DropPointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DropPointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDropPointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DropPoint model
   */
  readonly fields: DropPointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DropPoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DropPointClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    manager<T extends ManagerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ManagerDefaultArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    donations<T extends DropPoint$donationsArgs<ExtArgs> = {}>(args?: Subset<T, DropPoint$donationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'findMany'> | Null>;

    feedbacksGiven<T extends DropPoint$feedbacksGivenArgs<ExtArgs> = {}>(args?: Subset<T, DropPoint$feedbacksGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DropPoint model
   */ 
  interface DropPointFieldRefs {
    readonly id: FieldRef<"DropPoint", 'String'>
    readonly name: FieldRef<"DropPoint", 'String'>
    readonly location: FieldRef<"DropPoint", 'String'>
    readonly openingTime: FieldRef<"DropPoint", 'String'>
    readonly closingTime: FieldRef<"DropPoint", 'String'>
    readonly description: FieldRef<"DropPoint", 'String'>
    readonly managerId: FieldRef<"DropPoint", 'String'>
    readonly password: FieldRef<"DropPoint", 'String'>
  }
    

  // Custom InputTypes

  /**
   * DropPoint findUnique
   */
  export type DropPointFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
    /**
     * Filter, which DropPoint to fetch.
     */
    where: DropPointWhereUniqueInput
  }


  /**
   * DropPoint findUniqueOrThrow
   */
  export type DropPointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
    /**
     * Filter, which DropPoint to fetch.
     */
    where: DropPointWhereUniqueInput
  }


  /**
   * DropPoint findFirst
   */
  export type DropPointFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
    /**
     * Filter, which DropPoint to fetch.
     */
    where?: DropPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropPoints to fetch.
     */
    orderBy?: DropPointOrderByWithRelationInput | DropPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DropPoints.
     */
    cursor?: DropPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DropPoints.
     */
    distinct?: DropPointScalarFieldEnum | DropPointScalarFieldEnum[]
  }


  /**
   * DropPoint findFirstOrThrow
   */
  export type DropPointFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
    /**
     * Filter, which DropPoint to fetch.
     */
    where?: DropPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropPoints to fetch.
     */
    orderBy?: DropPointOrderByWithRelationInput | DropPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DropPoints.
     */
    cursor?: DropPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DropPoints.
     */
    distinct?: DropPointScalarFieldEnum | DropPointScalarFieldEnum[]
  }


  /**
   * DropPoint findMany
   */
  export type DropPointFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
    /**
     * Filter, which DropPoints to fetch.
     */
    where?: DropPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropPoints to fetch.
     */
    orderBy?: DropPointOrderByWithRelationInput | DropPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DropPoints.
     */
    cursor?: DropPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropPoints.
     */
    skip?: number
    distinct?: DropPointScalarFieldEnum | DropPointScalarFieldEnum[]
  }


  /**
   * DropPoint create
   */
  export type DropPointCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
    /**
     * The data needed to create a DropPoint.
     */
    data: XOR<DropPointCreateInput, DropPointUncheckedCreateInput>
  }


  /**
   * DropPoint createMany
   */
  export type DropPointCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DropPoints.
     */
    data: DropPointCreateManyInput | DropPointCreateManyInput[]
  }


  /**
   * DropPoint update
   */
  export type DropPointUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
    /**
     * The data needed to update a DropPoint.
     */
    data: XOR<DropPointUpdateInput, DropPointUncheckedUpdateInput>
    /**
     * Choose, which DropPoint to update.
     */
    where: DropPointWhereUniqueInput
  }


  /**
   * DropPoint updateMany
   */
  export type DropPointUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DropPoints.
     */
    data: XOR<DropPointUpdateManyMutationInput, DropPointUncheckedUpdateManyInput>
    /**
     * Filter which DropPoints to update
     */
    where?: DropPointWhereInput
  }


  /**
   * DropPoint upsert
   */
  export type DropPointUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
    /**
     * The filter to search for the DropPoint to update in case it exists.
     */
    where: DropPointWhereUniqueInput
    /**
     * In case the DropPoint found by the `where` argument doesn't exist, create a new DropPoint with this data.
     */
    create: XOR<DropPointCreateInput, DropPointUncheckedCreateInput>
    /**
     * In case the DropPoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DropPointUpdateInput, DropPointUncheckedUpdateInput>
  }


  /**
   * DropPoint delete
   */
  export type DropPointDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
    /**
     * Filter which DropPoint to delete.
     */
    where: DropPointWhereUniqueInput
  }


  /**
   * DropPoint deleteMany
   */
  export type DropPointDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DropPoints to delete
     */
    where?: DropPointWhereInput
  }


  /**
   * DropPoint findRaw
   */
  export type DropPointFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * DropPoint aggregateRaw
   */
  export type DropPointAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * DropPoint.donations
   */
  export type DropPoint$donationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    where?: DonationWhereInput
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    cursor?: DonationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }


  /**
   * DropPoint.feedbacksGiven
   */
  export type DropPoint$feedbacksGivenArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    cursor?: FeedbackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }


  /**
   * DropPoint without action
   */
  export type DropPointDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
  }



  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    email: number
    password: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    email: string
    password: string
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
  }, ExtArgs["result"]["admin"]>

  export type AdminSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
  }


  export type $AdminPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: string
      email: string
      password: string
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }


  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AdminFindManyArgs, 'select' | 'include'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdminFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Admin that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdminFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdminFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
    **/
    create<T extends AdminCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminCreateArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Admins.
     *     @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     *     @example
     *     // Create many Admins
     *     const admin = await prisma.admin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdminCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
    **/
    delete<T extends AdminDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdminUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdminDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdminUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
    **/
    upsert<T extends AdminUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>
    ): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Admins that matches the filter.
     * @param {AdminFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const admin = await prisma.admin.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: AdminFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Admin.
     * @param {AdminAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const admin = await prisma.admin.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: AdminAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Admin model
   */ 
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly email: FieldRef<"Admin", 'String'>
    readonly password: FieldRef<"Admin", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }


  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }


  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
  }


  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
  }


  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }


  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }


  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
  }


  /**
   * Admin findRaw
   */
  export type AdminFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Admin aggregateRaw
   */
  export type AdminAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
  }



  /**
   * Model Manager
   */

  export type AggregateManager = {
    _count: ManagerCountAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  export type ManagerMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phoneNumber: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ManagerMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phoneNumber: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ManagerCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    phoneNumber: number
    address: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ManagerMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ManagerMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ManagerCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ManagerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Manager to aggregate.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Managers
    **/
    _count?: true | ManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManagerMaxAggregateInputType
  }

  export type GetManagerAggregateType<T extends ManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManager[P]>
      : GetScalarType<T[P], AggregateManager[P]>
  }




  export type ManagerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ManagerWhereInput
    orderBy?: ManagerOrderByWithAggregationInput | ManagerOrderByWithAggregationInput[]
    by: ManagerScalarFieldEnum[] | ManagerScalarFieldEnum
    having?: ManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManagerCountAggregateInputType | true
    _min?: ManagerMinAggregateInputType
    _max?: ManagerMaxAggregateInputType
  }

  export type ManagerGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string
    phoneNumber: string | null
    address: string | null
    createdAt: Date
    updatedAt: Date
    _count: ManagerCountAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  type GetManagerGroupByPayload<T extends ManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManagerGroupByOutputType[P]>
            : GetScalarType<T[P], ManagerGroupByOutputType[P]>
        }
      >
    >


  export type ManagerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dropPoint?: boolean | Manager$dropPointArgs<ExtArgs>
    _count?: boolean | ManagerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manager"]>

  export type ManagerSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ManagerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    dropPoint?: boolean | Manager$dropPointArgs<ExtArgs>
    _count?: boolean | ManagerCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ManagerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Manager"
    objects: {
      dropPoint: Prisma.$DropPointPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      firstName: string
      lastName: string
      email: string
      phoneNumber: string | null
      address: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["manager"]>
    composites: {}
  }


  type ManagerGetPayload<S extends boolean | null | undefined | ManagerDefaultArgs> = $Result.GetResult<Prisma.$ManagerPayload, S>

  type ManagerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ManagerFindManyArgs, 'select' | 'include'> & {
      select?: ManagerCountAggregateInputType | true
    }

  export interface ManagerDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Manager'], meta: { name: 'Manager' } }
    /**
     * Find zero or one Manager that matches the filter.
     * @param {ManagerFindUniqueArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ManagerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ManagerFindUniqueArgs<ExtArgs>>
    ): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Manager that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ManagerFindUniqueOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ManagerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ManagerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Manager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ManagerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ManagerFindFirstArgs<ExtArgs>>
    ): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Manager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ManagerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ManagerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Managers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Managers
     * const managers = await prisma.manager.findMany()
     * 
     * // Get first 10 Managers
     * const managers = await prisma.manager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const managerWithIdOnly = await prisma.manager.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ManagerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ManagerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Manager.
     * @param {ManagerCreateArgs} args - Arguments to create a Manager.
     * @example
     * // Create one Manager
     * const Manager = await prisma.manager.create({
     *   data: {
     *     // ... data to create a Manager
     *   }
     * })
     * 
    **/
    create<T extends ManagerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ManagerCreateArgs<ExtArgs>>
    ): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Managers.
     *     @param {ManagerCreateManyArgs} args - Arguments to create many Managers.
     *     @example
     *     // Create many Managers
     *     const manager = await prisma.manager.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ManagerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ManagerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Manager.
     * @param {ManagerDeleteArgs} args - Arguments to delete one Manager.
     * @example
     * // Delete one Manager
     * const Manager = await prisma.manager.delete({
     *   where: {
     *     // ... filter to delete one Manager
     *   }
     * })
     * 
    **/
    delete<T extends ManagerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ManagerDeleteArgs<ExtArgs>>
    ): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Manager.
     * @param {ManagerUpdateArgs} args - Arguments to update one Manager.
     * @example
     * // Update one Manager
     * const manager = await prisma.manager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ManagerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ManagerUpdateArgs<ExtArgs>>
    ): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Managers.
     * @param {ManagerDeleteManyArgs} args - Arguments to filter Managers to delete.
     * @example
     * // Delete a few Managers
     * const { count } = await prisma.manager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ManagerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ManagerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Managers
     * const manager = await prisma.manager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ManagerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ManagerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Manager.
     * @param {ManagerUpsertArgs} args - Arguments to update or create a Manager.
     * @example
     * // Update or create a Manager
     * const manager = await prisma.manager.upsert({
     *   create: {
     *     // ... data to create a Manager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manager we want to update
     *   }
     * })
    **/
    upsert<T extends ManagerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ManagerUpsertArgs<ExtArgs>>
    ): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Managers that matches the filter.
     * @param {ManagerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const manager = await prisma.manager.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ManagerFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Manager.
     * @param {ManagerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const manager = await prisma.manager.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ManagerAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerCountArgs} args - Arguments to filter Managers to count.
     * @example
     * // Count the number of Managers
     * const count = await prisma.manager.count({
     *   where: {
     *     // ... the filter for the Managers we want to count
     *   }
     * })
    **/
    count<T extends ManagerCountArgs>(
      args?: Subset<T, ManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManagerAggregateArgs>(args: Subset<T, ManagerAggregateArgs>): Prisma.PrismaPromise<GetManagerAggregateType<T>>

    /**
     * Group by Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManagerGroupByArgs['orderBy'] }
        : { orderBy?: ManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Manager model
   */
  readonly fields: ManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Manager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManagerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    dropPoint<T extends Manager$dropPointArgs<ExtArgs> = {}>(args?: Subset<T, Manager$dropPointArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Manager model
   */ 
  interface ManagerFieldRefs {
    readonly id: FieldRef<"Manager", 'String'>
    readonly firstName: FieldRef<"Manager", 'String'>
    readonly lastName: FieldRef<"Manager", 'String'>
    readonly email: FieldRef<"Manager", 'String'>
    readonly phoneNumber: FieldRef<"Manager", 'String'>
    readonly address: FieldRef<"Manager", 'String'>
    readonly createdAt: FieldRef<"Manager", 'DateTime'>
    readonly updatedAt: FieldRef<"Manager", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Manager findUnique
   */
  export type ManagerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }


  /**
   * Manager findUniqueOrThrow
   */
  export type ManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }


  /**
   * Manager findFirst
   */
  export type ManagerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }


  /**
   * Manager findFirstOrThrow
   */
  export type ManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }


  /**
   * Manager findMany
   */
  export type ManagerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Managers to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }


  /**
   * Manager create
   */
  export type ManagerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a Manager.
     */
    data: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
  }


  /**
   * Manager createMany
   */
  export type ManagerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Managers.
     */
    data: ManagerCreateManyInput | ManagerCreateManyInput[]
  }


  /**
   * Manager update
   */
  export type ManagerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a Manager.
     */
    data: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
    /**
     * Choose, which Manager to update.
     */
    where: ManagerWhereUniqueInput
  }


  /**
   * Manager updateMany
   */
  export type ManagerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Managers.
     */
    data: XOR<ManagerUpdateManyMutationInput, ManagerUncheckedUpdateManyInput>
    /**
     * Filter which Managers to update
     */
    where?: ManagerWhereInput
  }


  /**
   * Manager upsert
   */
  export type ManagerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the Manager to update in case it exists.
     */
    where: ManagerWhereUniqueInput
    /**
     * In case the Manager found by the `where` argument doesn't exist, create a new Manager with this data.
     */
    create: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
    /**
     * In case the Manager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
  }


  /**
   * Manager delete
   */
  export type ManagerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter which Manager to delete.
     */
    where: ManagerWhereUniqueInput
  }


  /**
   * Manager deleteMany
   */
  export type ManagerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Managers to delete
     */
    where?: ManagerWhereInput
  }


  /**
   * Manager findRaw
   */
  export type ManagerFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Manager aggregateRaw
   */
  export type ManagerAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Manager.dropPoint
   */
  export type Manager$dropPointArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
    where?: DropPointWhereInput
    orderBy?: DropPointOrderByWithRelationInput | DropPointOrderByWithRelationInput[]
    cursor?: DropPointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DropPointScalarFieldEnum | DropPointScalarFieldEnum[]
  }


  /**
   * Manager without action
   */
  export type ManagerDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManagerInclude<ExtArgs> | null
  }



  /**
   * Model Donation
   */

  export type AggregateDonation = {
    _count: DonationCountAggregateOutputType | null
    _avg: DonationAvgAggregateOutputType | null
    _sum: DonationSumAggregateOutputType | null
    _min: DonationMinAggregateOutputType | null
    _max: DonationMaxAggregateOutputType | null
  }

  export type DonationAvgAggregateOutputType = {
    points: number | null
  }

  export type DonationSumAggregateOutputType = {
    points: number | null
  }

  export type DonationMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    dropPointId: string | null
    createdAt: Date | null
    expectedDateOfArrival: Date | null
    confirmedByName: string | null
    confirmedByEmail: string | null
    status: string | null
    isSubmitted: boolean | null
    points: number | null
  }

  export type DonationMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    dropPointId: string | null
    createdAt: Date | null
    expectedDateOfArrival: Date | null
    confirmedByName: string | null
    confirmedByEmail: string | null
    status: string | null
    isSubmitted: boolean | null
    points: number | null
  }

  export type DonationCountAggregateOutputType = {
    id: number
    organizationId: number
    dropPointId: number
    createdAt: number
    expectedDateOfArrival: number
    confirmedByName: number
    confirmedByEmail: number
    status: number
    isSubmitted: number
    points: number
    _all: number
  }


  export type DonationAvgAggregateInputType = {
    points?: true
  }

  export type DonationSumAggregateInputType = {
    points?: true
  }

  export type DonationMinAggregateInputType = {
    id?: true
    organizationId?: true
    dropPointId?: true
    createdAt?: true
    expectedDateOfArrival?: true
    confirmedByName?: true
    confirmedByEmail?: true
    status?: true
    isSubmitted?: true
    points?: true
  }

  export type DonationMaxAggregateInputType = {
    id?: true
    organizationId?: true
    dropPointId?: true
    createdAt?: true
    expectedDateOfArrival?: true
    confirmedByName?: true
    confirmedByEmail?: true
    status?: true
    isSubmitted?: true
    points?: true
  }

  export type DonationCountAggregateInputType = {
    id?: true
    organizationId?: true
    dropPointId?: true
    createdAt?: true
    expectedDateOfArrival?: true
    confirmedByName?: true
    confirmedByEmail?: true
    status?: true
    isSubmitted?: true
    points?: true
    _all?: true
  }

  export type DonationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Donation to aggregate.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Donations
    **/
    _count?: true | DonationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DonationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DonationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DonationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DonationMaxAggregateInputType
  }

  export type GetDonationAggregateType<T extends DonationAggregateArgs> = {
        [P in keyof T & keyof AggregateDonation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDonation[P]>
      : GetScalarType<T[P], AggregateDonation[P]>
  }




  export type DonationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DonationWhereInput
    orderBy?: DonationOrderByWithAggregationInput | DonationOrderByWithAggregationInput[]
    by: DonationScalarFieldEnum[] | DonationScalarFieldEnum
    having?: DonationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DonationCountAggregateInputType | true
    _avg?: DonationAvgAggregateInputType
    _sum?: DonationSumAggregateInputType
    _min?: DonationMinAggregateInputType
    _max?: DonationMaxAggregateInputType
  }

  export type DonationGroupByOutputType = {
    id: string
    organizationId: string
    dropPointId: string
    createdAt: Date
    expectedDateOfArrival: Date | null
    confirmedByName: string | null
    confirmedByEmail: string | null
    status: string | null
    isSubmitted: boolean
    points: number | null
    _count: DonationCountAggregateOutputType | null
    _avg: DonationAvgAggregateOutputType | null
    _sum: DonationSumAggregateOutputType | null
    _min: DonationMinAggregateOutputType | null
    _max: DonationMaxAggregateOutputType | null
  }

  type GetDonationGroupByPayload<T extends DonationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DonationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DonationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DonationGroupByOutputType[P]>
            : GetScalarType<T[P], DonationGroupByOutputType[P]>
        }
      >
    >


  export type DonationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    dropPointId?: boolean
    createdAt?: boolean
    expectedDateOfArrival?: boolean
    confirmedByName?: boolean
    confirmedByEmail?: boolean
    status?: boolean
    isSubmitted?: boolean
    points?: boolean
    feedback?: boolean | FeedbackDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    dropPoint?: boolean | DropPointDefaultArgs<ExtArgs>
    peripherals?: boolean | Donation$peripheralsArgs<ExtArgs>
    _count?: boolean | DonationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["donation"]>

  export type DonationSelectScalar = {
    id?: boolean
    organizationId?: boolean
    dropPointId?: boolean
    createdAt?: boolean
    expectedDateOfArrival?: boolean
    confirmedByName?: boolean
    confirmedByEmail?: boolean
    status?: boolean
    isSubmitted?: boolean
    points?: boolean
  }

  export type DonationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    feedback?: boolean | FeedbackDefaultArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    dropPoint?: boolean | DropPointDefaultArgs<ExtArgs>
    peripherals?: boolean | Donation$peripheralsArgs<ExtArgs>
    _count?: boolean | DonationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DonationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Donation"
    objects: {
      feedback: Prisma.$FeedbackPayload<ExtArgs> | null
      organization: Prisma.$OrganizationPayload<ExtArgs>
      dropPoint: Prisma.$DropPointPayload<ExtArgs>
      peripherals: Prisma.$PeripheralPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      organizationId: string
      dropPointId: string
      createdAt: Date
      expectedDateOfArrival: Date | null
      confirmedByName: string | null
      confirmedByEmail: string | null
      status: string | null
      isSubmitted: boolean
      points: number | null
    }, ExtArgs["result"]["donation"]>
    composites: {}
  }


  type DonationGetPayload<S extends boolean | null | undefined | DonationDefaultArgs> = $Result.GetResult<Prisma.$DonationPayload, S>

  type DonationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DonationFindManyArgs, 'select' | 'include'> & {
      select?: DonationCountAggregateInputType | true
    }

  export interface DonationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Donation'], meta: { name: 'Donation' } }
    /**
     * Find zero or one Donation that matches the filter.
     * @param {DonationFindUniqueArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DonationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DonationFindUniqueArgs<ExtArgs>>
    ): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Donation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DonationFindUniqueOrThrowArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DonationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DonationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Donation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationFindFirstArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DonationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DonationFindFirstArgs<ExtArgs>>
    ): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Donation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationFindFirstOrThrowArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DonationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DonationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Donations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Donations
     * const donations = await prisma.donation.findMany()
     * 
     * // Get first 10 Donations
     * const donations = await prisma.donation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const donationWithIdOnly = await prisma.donation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DonationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DonationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Donation.
     * @param {DonationCreateArgs} args - Arguments to create a Donation.
     * @example
     * // Create one Donation
     * const Donation = await prisma.donation.create({
     *   data: {
     *     // ... data to create a Donation
     *   }
     * })
     * 
    **/
    create<T extends DonationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DonationCreateArgs<ExtArgs>>
    ): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Donations.
     *     @param {DonationCreateManyArgs} args - Arguments to create many Donations.
     *     @example
     *     // Create many Donations
     *     const donation = await prisma.donation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DonationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DonationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Donation.
     * @param {DonationDeleteArgs} args - Arguments to delete one Donation.
     * @example
     * // Delete one Donation
     * const Donation = await prisma.donation.delete({
     *   where: {
     *     // ... filter to delete one Donation
     *   }
     * })
     * 
    **/
    delete<T extends DonationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DonationDeleteArgs<ExtArgs>>
    ): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Donation.
     * @param {DonationUpdateArgs} args - Arguments to update one Donation.
     * @example
     * // Update one Donation
     * const donation = await prisma.donation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DonationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DonationUpdateArgs<ExtArgs>>
    ): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Donations.
     * @param {DonationDeleteManyArgs} args - Arguments to filter Donations to delete.
     * @example
     * // Delete a few Donations
     * const { count } = await prisma.donation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DonationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DonationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Donations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Donations
     * const donation = await prisma.donation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DonationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DonationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Donation.
     * @param {DonationUpsertArgs} args - Arguments to update or create a Donation.
     * @example
     * // Update or create a Donation
     * const donation = await prisma.donation.upsert({
     *   create: {
     *     // ... data to create a Donation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Donation we want to update
     *   }
     * })
    **/
    upsert<T extends DonationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DonationUpsertArgs<ExtArgs>>
    ): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Donations that matches the filter.
     * @param {DonationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const donation = await prisma.donation.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: DonationFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Donation.
     * @param {DonationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const donation = await prisma.donation.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: DonationAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Donations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationCountArgs} args - Arguments to filter Donations to count.
     * @example
     * // Count the number of Donations
     * const count = await prisma.donation.count({
     *   where: {
     *     // ... the filter for the Donations we want to count
     *   }
     * })
    **/
    count<T extends DonationCountArgs>(
      args?: Subset<T, DonationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DonationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Donation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DonationAggregateArgs>(args: Subset<T, DonationAggregateArgs>): Prisma.PrismaPromise<GetDonationAggregateType<T>>

    /**
     * Group by Donation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DonationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DonationGroupByArgs['orderBy'] }
        : { orderBy?: DonationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DonationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDonationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Donation model
   */
  readonly fields: DonationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Donation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DonationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    feedback<T extends FeedbackDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeedbackDefaultArgs<ExtArgs>>): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    dropPoint<T extends DropPointDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DropPointDefaultArgs<ExtArgs>>): Prisma__DropPointClient<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    peripherals<T extends Donation$peripheralsArgs<ExtArgs> = {}>(args?: Subset<T, Donation$peripheralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeripheralPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Donation model
   */ 
  interface DonationFieldRefs {
    readonly id: FieldRef<"Donation", 'String'>
    readonly organizationId: FieldRef<"Donation", 'String'>
    readonly dropPointId: FieldRef<"Donation", 'String'>
    readonly createdAt: FieldRef<"Donation", 'DateTime'>
    readonly expectedDateOfArrival: FieldRef<"Donation", 'DateTime'>
    readonly confirmedByName: FieldRef<"Donation", 'String'>
    readonly confirmedByEmail: FieldRef<"Donation", 'String'>
    readonly status: FieldRef<"Donation", 'String'>
    readonly isSubmitted: FieldRef<"Donation", 'Boolean'>
    readonly points: FieldRef<"Donation", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * Donation findUnique
   */
  export type DonationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where: DonationWhereUniqueInput
  }


  /**
   * Donation findUniqueOrThrow
   */
  export type DonationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where: DonationWhereUniqueInput
  }


  /**
   * Donation findFirst
   */
  export type DonationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Donations.
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Donations.
     */
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }


  /**
   * Donation findFirstOrThrow
   */
  export type DonationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Donations.
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Donations.
     */
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }


  /**
   * Donation findMany
   */
  export type DonationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donations to fetch.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Donations.
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }


  /**
   * Donation create
   */
  export type DonationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * The data needed to create a Donation.
     */
    data: XOR<DonationCreateInput, DonationUncheckedCreateInput>
  }


  /**
   * Donation createMany
   */
  export type DonationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Donations.
     */
    data: DonationCreateManyInput | DonationCreateManyInput[]
  }


  /**
   * Donation update
   */
  export type DonationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * The data needed to update a Donation.
     */
    data: XOR<DonationUpdateInput, DonationUncheckedUpdateInput>
    /**
     * Choose, which Donation to update.
     */
    where: DonationWhereUniqueInput
  }


  /**
   * Donation updateMany
   */
  export type DonationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Donations.
     */
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyInput>
    /**
     * Filter which Donations to update
     */
    where?: DonationWhereInput
  }


  /**
   * Donation upsert
   */
  export type DonationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * The filter to search for the Donation to update in case it exists.
     */
    where: DonationWhereUniqueInput
    /**
     * In case the Donation found by the `where` argument doesn't exist, create a new Donation with this data.
     */
    create: XOR<DonationCreateInput, DonationUncheckedCreateInput>
    /**
     * In case the Donation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DonationUpdateInput, DonationUncheckedUpdateInput>
  }


  /**
   * Donation delete
   */
  export type DonationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter which Donation to delete.
     */
    where: DonationWhereUniqueInput
  }


  /**
   * Donation deleteMany
   */
  export type DonationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Donations to delete
     */
    where?: DonationWhereInput
  }


  /**
   * Donation findRaw
   */
  export type DonationFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Donation aggregateRaw
   */
  export type DonationAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Donation.peripherals
   */
  export type Donation$peripheralsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
    where?: PeripheralWhereInput
    orderBy?: PeripheralOrderByWithRelationInput | PeripheralOrderByWithRelationInput[]
    cursor?: PeripheralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PeripheralScalarFieldEnum | PeripheralScalarFieldEnum[]
  }


  /**
   * Donation without action
   */
  export type DonationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
  }



  /**
   * Model Feedback
   */

  export type AggregateFeedback = {
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  export type FeedbackAvgAggregateOutputType = {
    rating: number | null
  }

  export type FeedbackSumAggregateOutputType = {
    rating: number | null
  }

  export type FeedbackMinAggregateOutputType = {
    id: string | null
    content: string | null
    rating: number | null
    createdAt: Date | null
    organizationId: string | null
    dropPointId: string | null
    donationId: string | null
  }

  export type FeedbackMaxAggregateOutputType = {
    id: string | null
    content: string | null
    rating: number | null
    createdAt: Date | null
    organizationId: string | null
    dropPointId: string | null
    donationId: string | null
  }

  export type FeedbackCountAggregateOutputType = {
    id: number
    content: number
    rating: number
    createdAt: number
    organizationId: number
    dropPointId: number
    donationId: number
    _all: number
  }


  export type FeedbackAvgAggregateInputType = {
    rating?: true
  }

  export type FeedbackSumAggregateInputType = {
    rating?: true
  }

  export type FeedbackMinAggregateInputType = {
    id?: true
    content?: true
    rating?: true
    createdAt?: true
    organizationId?: true
    dropPointId?: true
    donationId?: true
  }

  export type FeedbackMaxAggregateInputType = {
    id?: true
    content?: true
    rating?: true
    createdAt?: true
    organizationId?: true
    dropPointId?: true
    donationId?: true
  }

  export type FeedbackCountAggregateInputType = {
    id?: true
    content?: true
    rating?: true
    createdAt?: true
    organizationId?: true
    dropPointId?: true
    donationId?: true
    _all?: true
  }

  export type FeedbackAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedback to aggregate.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Feedbacks
    **/
    _count?: true | FeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackMaxAggregateInputType
  }

  export type GetFeedbackAggregateType<T extends FeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedback[P]>
      : GetScalarType<T[P], AggregateFeedback[P]>
  }




  export type FeedbackGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: FeedbackWhereInput
    orderBy?: FeedbackOrderByWithAggregationInput | FeedbackOrderByWithAggregationInput[]
    by: FeedbackScalarFieldEnum[] | FeedbackScalarFieldEnum
    having?: FeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackCountAggregateInputType | true
    _avg?: FeedbackAvgAggregateInputType
    _sum?: FeedbackSumAggregateInputType
    _min?: FeedbackMinAggregateInputType
    _max?: FeedbackMaxAggregateInputType
  }

  export type FeedbackGroupByOutputType = {
    id: string
    content: string
    rating: number
    createdAt: Date
    organizationId: string
    dropPointId: string
    donationId: string
    _count: FeedbackCountAggregateOutputType | null
    _avg: FeedbackAvgAggregateOutputType | null
    _sum: FeedbackSumAggregateOutputType | null
    _min: FeedbackMinAggregateOutputType | null
    _max: FeedbackMaxAggregateOutputType | null
  }

  type GetFeedbackGroupByPayload<T extends FeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    rating?: boolean
    createdAt?: boolean
    organizationId?: boolean
    dropPointId?: boolean
    donationId?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    dropPoint?: boolean | DropPointDefaultArgs<ExtArgs>
    donation?: boolean | DonationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedback"]>

  export type FeedbackSelectScalar = {
    id?: boolean
    content?: boolean
    rating?: boolean
    createdAt?: boolean
    organizationId?: boolean
    dropPointId?: boolean
    donationId?: boolean
  }

  export type FeedbackInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    dropPoint?: boolean | DropPointDefaultArgs<ExtArgs>
    donation?: boolean | DonationDefaultArgs<ExtArgs>
  }


  export type $FeedbackPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Feedback"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      dropPoint: Prisma.$DropPointPayload<ExtArgs>
      donation: Prisma.$DonationPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      content: string
      rating: number
      createdAt: Date
      organizationId: string
      dropPointId: string
      donationId: string
    }, ExtArgs["result"]["feedback"]>
    composites: {}
  }


  type FeedbackGetPayload<S extends boolean | null | undefined | FeedbackDefaultArgs> = $Result.GetResult<Prisma.$FeedbackPayload, S>

  type FeedbackCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<FeedbackFindManyArgs, 'select' | 'include'> & {
      select?: FeedbackCountAggregateInputType | true
    }

  export interface FeedbackDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Feedback'], meta: { name: 'Feedback' } }
    /**
     * Find zero or one Feedback that matches the filter.
     * @param {FeedbackFindUniqueArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FeedbackFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackFindUniqueArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Feedback that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FeedbackFindUniqueOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FeedbackFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Feedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FeedbackFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFindFirstArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Feedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindFirstOrThrowArgs} args - Arguments to find a Feedback
     * @example
     * // Get one Feedback
     * const feedback = await prisma.feedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FeedbackFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedback.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedbackWithIdOnly = await prisma.feedback.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FeedbackFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Feedback.
     * @param {FeedbackCreateArgs} args - Arguments to create a Feedback.
     * @example
     * // Create one Feedback
     * const Feedback = await prisma.feedback.create({
     *   data: {
     *     // ... data to create a Feedback
     *   }
     * })
     * 
    **/
    create<T extends FeedbackCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackCreateArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Feedbacks.
     *     @param {FeedbackCreateManyArgs} args - Arguments to create many Feedbacks.
     *     @example
     *     // Create many Feedbacks
     *     const feedback = await prisma.feedback.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FeedbackCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Feedback.
     * @param {FeedbackDeleteArgs} args - Arguments to delete one Feedback.
     * @example
     * // Delete one Feedback
     * const Feedback = await prisma.feedback.delete({
     *   where: {
     *     // ... filter to delete one Feedback
     *   }
     * })
     * 
    **/
    delete<T extends FeedbackDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackDeleteArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Feedback.
     * @param {FeedbackUpdateArgs} args - Arguments to update one Feedback.
     * @example
     * // Update one Feedback
     * const feedback = await prisma.feedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FeedbackUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackUpdateArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Feedbacks.
     * @param {FeedbackDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FeedbackDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FeedbackDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedback = await prisma.feedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FeedbackUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Feedback.
     * @param {FeedbackUpsertArgs} args - Arguments to update or create a Feedback.
     * @example
     * // Update or create a Feedback
     * const feedback = await prisma.feedback.upsert({
     *   create: {
     *     // ... data to create a Feedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedback we want to update
     *   }
     * })
    **/
    upsert<T extends FeedbackUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FeedbackUpsertArgs<ExtArgs>>
    ): Prisma__FeedbackClient<$Result.GetResult<Prisma.$FeedbackPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * @param {FeedbackFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const feedback = await prisma.feedback.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: FeedbackFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Feedback.
     * @param {FeedbackAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const feedback = await prisma.feedback.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: FeedbackAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedback.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends FeedbackCountArgs>(
      args?: Subset<T, FeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackAggregateArgs>(args: Subset<T, FeedbackAggregateArgs>): Prisma.PrismaPromise<GetFeedbackAggregateType<T>>

    /**
     * Group by Feedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Feedback model
   */
  readonly fields: FeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Feedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    dropPoint<T extends DropPointDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DropPointDefaultArgs<ExtArgs>>): Prisma__DropPointClient<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    donation<T extends DonationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DonationDefaultArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Feedback model
   */ 
  interface FeedbackFieldRefs {
    readonly id: FieldRef<"Feedback", 'String'>
    readonly content: FieldRef<"Feedback", 'String'>
    readonly rating: FieldRef<"Feedback", 'Int'>
    readonly createdAt: FieldRef<"Feedback", 'DateTime'>
    readonly organizationId: FieldRef<"Feedback", 'String'>
    readonly dropPointId: FieldRef<"Feedback", 'String'>
    readonly donationId: FieldRef<"Feedback", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Feedback findUnique
   */
  export type FeedbackFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }


  /**
   * Feedback findUniqueOrThrow
   */
  export type FeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where: FeedbackWhereUniqueInput
  }


  /**
   * Feedback findFirst
   */
  export type FeedbackFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }


  /**
   * Feedback findFirstOrThrow
   */
  export type FeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedback to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Feedbacks.
     */
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }


  /**
   * Feedback findMany
   */
  export type FeedbackFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter, which Feedbacks to fetch.
     */
    where?: FeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Feedbacks to fetch.
     */
    orderBy?: FeedbackOrderByWithRelationInput | FeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Feedbacks.
     */
    cursor?: FeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Feedbacks.
     */
    skip?: number
    distinct?: FeedbackScalarFieldEnum | FeedbackScalarFieldEnum[]
  }


  /**
   * Feedback create
   */
  export type FeedbackCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a Feedback.
     */
    data: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
  }


  /**
   * Feedback createMany
   */
  export type FeedbackCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Feedbacks.
     */
    data: FeedbackCreateManyInput | FeedbackCreateManyInput[]
  }


  /**
   * Feedback update
   */
  export type FeedbackUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a Feedback.
     */
    data: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
    /**
     * Choose, which Feedback to update.
     */
    where: FeedbackWhereUniqueInput
  }


  /**
   * Feedback updateMany
   */
  export type FeedbackUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Feedbacks.
     */
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyInput>
    /**
     * Filter which Feedbacks to update
     */
    where?: FeedbackWhereInput
  }


  /**
   * Feedback upsert
   */
  export type FeedbackUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the Feedback to update in case it exists.
     */
    where: FeedbackWhereUniqueInput
    /**
     * In case the Feedback found by the `where` argument doesn't exist, create a new Feedback with this data.
     */
    create: XOR<FeedbackCreateInput, FeedbackUncheckedCreateInput>
    /**
     * In case the Feedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackUpdateInput, FeedbackUncheckedUpdateInput>
  }


  /**
   * Feedback delete
   */
  export type FeedbackDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
    /**
     * Filter which Feedback to delete.
     */
    where: FeedbackWhereUniqueInput
  }


  /**
   * Feedback deleteMany
   */
  export type FeedbackDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Feedbacks to delete
     */
    where?: FeedbackWhereInput
  }


  /**
   * Feedback findRaw
   */
  export type FeedbackFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Feedback aggregateRaw
   */
  export type FeedbackAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Feedback without action
   */
  export type FeedbackDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Feedback
     */
    select?: FeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FeedbackInclude<ExtArgs> | null
  }



  /**
   * Model Peripheral
   */

  export type AggregatePeripheral = {
    _count: PeripheralCountAggregateOutputType | null
    _avg: PeripheralAvgAggregateOutputType | null
    _sum: PeripheralSumAggregateOutputType | null
    _min: PeripheralMinAggregateOutputType | null
    _max: PeripheralMaxAggregateOutputType | null
  }

  export type PeripheralAvgAggregateOutputType = {
    quantity: number | null
  }

  export type PeripheralSumAggregateOutputType = {
    quantity: number | null
  }

  export type PeripheralMinAggregateOutputType = {
    id: string | null
    type: string | null
    brand: string | null
    model: string | null
    condition: string | null
    quantity: number | null
    donationId: string | null
  }

  export type PeripheralMaxAggregateOutputType = {
    id: string | null
    type: string | null
    brand: string | null
    model: string | null
    condition: string | null
    quantity: number | null
    donationId: string | null
  }

  export type PeripheralCountAggregateOutputType = {
    id: number
    type: number
    brand: number
    model: number
    condition: number
    quantity: number
    donationId: number
    _all: number
  }


  export type PeripheralAvgAggregateInputType = {
    quantity?: true
  }

  export type PeripheralSumAggregateInputType = {
    quantity?: true
  }

  export type PeripheralMinAggregateInputType = {
    id?: true
    type?: true
    brand?: true
    model?: true
    condition?: true
    quantity?: true
    donationId?: true
  }

  export type PeripheralMaxAggregateInputType = {
    id?: true
    type?: true
    brand?: true
    model?: true
    condition?: true
    quantity?: true
    donationId?: true
  }

  export type PeripheralCountAggregateInputType = {
    id?: true
    type?: true
    brand?: true
    model?: true
    condition?: true
    quantity?: true
    donationId?: true
    _all?: true
  }

  export type PeripheralAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Peripheral to aggregate.
     */
    where?: PeripheralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Peripherals to fetch.
     */
    orderBy?: PeripheralOrderByWithRelationInput | PeripheralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PeripheralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Peripherals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Peripherals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Peripherals
    **/
    _count?: true | PeripheralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PeripheralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PeripheralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PeripheralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PeripheralMaxAggregateInputType
  }

  export type GetPeripheralAggregateType<T extends PeripheralAggregateArgs> = {
        [P in keyof T & keyof AggregatePeripheral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePeripheral[P]>
      : GetScalarType<T[P], AggregatePeripheral[P]>
  }




  export type PeripheralGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PeripheralWhereInput
    orderBy?: PeripheralOrderByWithAggregationInput | PeripheralOrderByWithAggregationInput[]
    by: PeripheralScalarFieldEnum[] | PeripheralScalarFieldEnum
    having?: PeripheralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PeripheralCountAggregateInputType | true
    _avg?: PeripheralAvgAggregateInputType
    _sum?: PeripheralSumAggregateInputType
    _min?: PeripheralMinAggregateInputType
    _max?: PeripheralMaxAggregateInputType
  }

  export type PeripheralGroupByOutputType = {
    id: string
    type: string
    brand: string
    model: string
    condition: string
    quantity: number
    donationId: string
    _count: PeripheralCountAggregateOutputType | null
    _avg: PeripheralAvgAggregateOutputType | null
    _sum: PeripheralSumAggregateOutputType | null
    _min: PeripheralMinAggregateOutputType | null
    _max: PeripheralMaxAggregateOutputType | null
  }

  type GetPeripheralGroupByPayload<T extends PeripheralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PeripheralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PeripheralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PeripheralGroupByOutputType[P]>
            : GetScalarType<T[P], PeripheralGroupByOutputType[P]>
        }
      >
    >


  export type PeripheralSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    brand?: boolean
    model?: boolean
    condition?: boolean
    quantity?: boolean
    donationId?: boolean
    donation?: boolean | DonationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["peripheral"]>

  export type PeripheralSelectScalar = {
    id?: boolean
    type?: boolean
    brand?: boolean
    model?: boolean
    condition?: boolean
    quantity?: boolean
    donationId?: boolean
  }

  export type PeripheralInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    donation?: boolean | DonationDefaultArgs<ExtArgs>
  }


  export type $PeripheralPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Peripheral"
    objects: {
      donation: Prisma.$DonationPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      type: string
      brand: string
      model: string
      condition: string
      quantity: number
      donationId: string
    }, ExtArgs["result"]["peripheral"]>
    composites: {}
  }


  type PeripheralGetPayload<S extends boolean | null | undefined | PeripheralDefaultArgs> = $Result.GetResult<Prisma.$PeripheralPayload, S>

  type PeripheralCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PeripheralFindManyArgs, 'select' | 'include'> & {
      select?: PeripheralCountAggregateInputType | true
    }

  export interface PeripheralDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Peripheral'], meta: { name: 'Peripheral' } }
    /**
     * Find zero or one Peripheral that matches the filter.
     * @param {PeripheralFindUniqueArgs} args - Arguments to find a Peripheral
     * @example
     * // Get one Peripheral
     * const peripheral = await prisma.peripheral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PeripheralFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PeripheralFindUniqueArgs<ExtArgs>>
    ): Prisma__PeripheralClient<$Result.GetResult<Prisma.$PeripheralPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Peripheral that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PeripheralFindUniqueOrThrowArgs} args - Arguments to find a Peripheral
     * @example
     * // Get one Peripheral
     * const peripheral = await prisma.peripheral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PeripheralFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PeripheralFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PeripheralClient<$Result.GetResult<Prisma.$PeripheralPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Peripheral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeripheralFindFirstArgs} args - Arguments to find a Peripheral
     * @example
     * // Get one Peripheral
     * const peripheral = await prisma.peripheral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PeripheralFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PeripheralFindFirstArgs<ExtArgs>>
    ): Prisma__PeripheralClient<$Result.GetResult<Prisma.$PeripheralPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Peripheral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeripheralFindFirstOrThrowArgs} args - Arguments to find a Peripheral
     * @example
     * // Get one Peripheral
     * const peripheral = await prisma.peripheral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PeripheralFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PeripheralFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PeripheralClient<$Result.GetResult<Prisma.$PeripheralPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Peripherals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeripheralFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Peripherals
     * const peripherals = await prisma.peripheral.findMany()
     * 
     * // Get first 10 Peripherals
     * const peripherals = await prisma.peripheral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const peripheralWithIdOnly = await prisma.peripheral.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PeripheralFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PeripheralFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeripheralPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Peripheral.
     * @param {PeripheralCreateArgs} args - Arguments to create a Peripheral.
     * @example
     * // Create one Peripheral
     * const Peripheral = await prisma.peripheral.create({
     *   data: {
     *     // ... data to create a Peripheral
     *   }
     * })
     * 
    **/
    create<T extends PeripheralCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PeripheralCreateArgs<ExtArgs>>
    ): Prisma__PeripheralClient<$Result.GetResult<Prisma.$PeripheralPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Peripherals.
     *     @param {PeripheralCreateManyArgs} args - Arguments to create many Peripherals.
     *     @example
     *     // Create many Peripherals
     *     const peripheral = await prisma.peripheral.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PeripheralCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PeripheralCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Peripheral.
     * @param {PeripheralDeleteArgs} args - Arguments to delete one Peripheral.
     * @example
     * // Delete one Peripheral
     * const Peripheral = await prisma.peripheral.delete({
     *   where: {
     *     // ... filter to delete one Peripheral
     *   }
     * })
     * 
    **/
    delete<T extends PeripheralDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PeripheralDeleteArgs<ExtArgs>>
    ): Prisma__PeripheralClient<$Result.GetResult<Prisma.$PeripheralPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Peripheral.
     * @param {PeripheralUpdateArgs} args - Arguments to update one Peripheral.
     * @example
     * // Update one Peripheral
     * const peripheral = await prisma.peripheral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PeripheralUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PeripheralUpdateArgs<ExtArgs>>
    ): Prisma__PeripheralClient<$Result.GetResult<Prisma.$PeripheralPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Peripherals.
     * @param {PeripheralDeleteManyArgs} args - Arguments to filter Peripherals to delete.
     * @example
     * // Delete a few Peripherals
     * const { count } = await prisma.peripheral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PeripheralDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PeripheralDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Peripherals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeripheralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Peripherals
     * const peripheral = await prisma.peripheral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PeripheralUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PeripheralUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Peripheral.
     * @param {PeripheralUpsertArgs} args - Arguments to update or create a Peripheral.
     * @example
     * // Update or create a Peripheral
     * const peripheral = await prisma.peripheral.upsert({
     *   create: {
     *     // ... data to create a Peripheral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Peripheral we want to update
     *   }
     * })
    **/
    upsert<T extends PeripheralUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PeripheralUpsertArgs<ExtArgs>>
    ): Prisma__PeripheralClient<$Result.GetResult<Prisma.$PeripheralPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Peripherals that matches the filter.
     * @param {PeripheralFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const peripheral = await prisma.peripheral.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: PeripheralFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Peripheral.
     * @param {PeripheralAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const peripheral = await prisma.peripheral.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: PeripheralAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Peripherals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeripheralCountArgs} args - Arguments to filter Peripherals to count.
     * @example
     * // Count the number of Peripherals
     * const count = await prisma.peripheral.count({
     *   where: {
     *     // ... the filter for the Peripherals we want to count
     *   }
     * })
    **/
    count<T extends PeripheralCountArgs>(
      args?: Subset<T, PeripheralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PeripheralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Peripheral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeripheralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PeripheralAggregateArgs>(args: Subset<T, PeripheralAggregateArgs>): Prisma.PrismaPromise<GetPeripheralAggregateType<T>>

    /**
     * Group by Peripheral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeripheralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PeripheralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PeripheralGroupByArgs['orderBy'] }
        : { orderBy?: PeripheralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PeripheralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPeripheralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Peripheral model
   */
  readonly fields: PeripheralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Peripheral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PeripheralClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    donation<T extends DonationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DonationDefaultArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Peripheral model
   */ 
  interface PeripheralFieldRefs {
    readonly id: FieldRef<"Peripheral", 'String'>
    readonly type: FieldRef<"Peripheral", 'String'>
    readonly brand: FieldRef<"Peripheral", 'String'>
    readonly model: FieldRef<"Peripheral", 'String'>
    readonly condition: FieldRef<"Peripheral", 'String'>
    readonly quantity: FieldRef<"Peripheral", 'Int'>
    readonly donationId: FieldRef<"Peripheral", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Peripheral findUnique
   */
  export type PeripheralFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
    /**
     * Filter, which Peripheral to fetch.
     */
    where: PeripheralWhereUniqueInput
  }


  /**
   * Peripheral findUniqueOrThrow
   */
  export type PeripheralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
    /**
     * Filter, which Peripheral to fetch.
     */
    where: PeripheralWhereUniqueInput
  }


  /**
   * Peripheral findFirst
   */
  export type PeripheralFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
    /**
     * Filter, which Peripheral to fetch.
     */
    where?: PeripheralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Peripherals to fetch.
     */
    orderBy?: PeripheralOrderByWithRelationInput | PeripheralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Peripherals.
     */
    cursor?: PeripheralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Peripherals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Peripherals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Peripherals.
     */
    distinct?: PeripheralScalarFieldEnum | PeripheralScalarFieldEnum[]
  }


  /**
   * Peripheral findFirstOrThrow
   */
  export type PeripheralFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
    /**
     * Filter, which Peripheral to fetch.
     */
    where?: PeripheralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Peripherals to fetch.
     */
    orderBy?: PeripheralOrderByWithRelationInput | PeripheralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Peripherals.
     */
    cursor?: PeripheralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Peripherals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Peripherals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Peripherals.
     */
    distinct?: PeripheralScalarFieldEnum | PeripheralScalarFieldEnum[]
  }


  /**
   * Peripheral findMany
   */
  export type PeripheralFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
    /**
     * Filter, which Peripherals to fetch.
     */
    where?: PeripheralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Peripherals to fetch.
     */
    orderBy?: PeripheralOrderByWithRelationInput | PeripheralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Peripherals.
     */
    cursor?: PeripheralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Peripherals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Peripherals.
     */
    skip?: number
    distinct?: PeripheralScalarFieldEnum | PeripheralScalarFieldEnum[]
  }


  /**
   * Peripheral create
   */
  export type PeripheralCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
    /**
     * The data needed to create a Peripheral.
     */
    data: XOR<PeripheralCreateInput, PeripheralUncheckedCreateInput>
  }


  /**
   * Peripheral createMany
   */
  export type PeripheralCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Peripherals.
     */
    data: PeripheralCreateManyInput | PeripheralCreateManyInput[]
  }


  /**
   * Peripheral update
   */
  export type PeripheralUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
    /**
     * The data needed to update a Peripheral.
     */
    data: XOR<PeripheralUpdateInput, PeripheralUncheckedUpdateInput>
    /**
     * Choose, which Peripheral to update.
     */
    where: PeripheralWhereUniqueInput
  }


  /**
   * Peripheral updateMany
   */
  export type PeripheralUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Peripherals.
     */
    data: XOR<PeripheralUpdateManyMutationInput, PeripheralUncheckedUpdateManyInput>
    /**
     * Filter which Peripherals to update
     */
    where?: PeripheralWhereInput
  }


  /**
   * Peripheral upsert
   */
  export type PeripheralUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
    /**
     * The filter to search for the Peripheral to update in case it exists.
     */
    where: PeripheralWhereUniqueInput
    /**
     * In case the Peripheral found by the `where` argument doesn't exist, create a new Peripheral with this data.
     */
    create: XOR<PeripheralCreateInput, PeripheralUncheckedCreateInput>
    /**
     * In case the Peripheral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PeripheralUpdateInput, PeripheralUncheckedUpdateInput>
  }


  /**
   * Peripheral delete
   */
  export type PeripheralDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
    /**
     * Filter which Peripheral to delete.
     */
    where: PeripheralWhereUniqueInput
  }


  /**
   * Peripheral deleteMany
   */
  export type PeripheralDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Peripherals to delete
     */
    where?: PeripheralWhereInput
  }


  /**
   * Peripheral findRaw
   */
  export type PeripheralFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Peripheral aggregateRaw
   */
  export type PeripheralAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Peripheral without action
   */
  export type PeripheralDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
  }



  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CityMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: string
    name: string
    _count: CityCountAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    users?: boolean | City$usersArgs<ExtArgs>
    advertisements?: boolean | City$advertisementsArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type CityInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | City$usersArgs<ExtArgs>
    advertisements?: boolean | City$advertisementsArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CityPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      advertisements: Prisma.$AdvertisementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      name: string
    }, ExtArgs["result"]["city"]>
    composites: {}
  }


  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CityFindManyArgs, 'select' | 'include'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one City that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
    **/
    create<T extends CityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CityCreateArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Cities.
     *     @param {CityCreateManyArgs} args - Arguments to create many Cities.
     *     @example
     *     // Create many Cities
     *     const city = await prisma.city.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
    **/
    delete<T extends CityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CityDeleteArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CityUpdateArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
    **/
    upsert<T extends CityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CityUpsertArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Cities that matches the filter.
     * @param {CityFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const city = await prisma.city.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CityFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a City.
     * @param {CityAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const city = await prisma.city.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CityAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends City$usersArgs<ExtArgs> = {}>(args?: Subset<T, City$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'> | Null>;

    advertisements<T extends City$advertisementsArgs<ExtArgs> = {}>(args?: Subset<T, City$advertisementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the City model
   */ 
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'String'>
    readonly name: FieldRef<"City", 'String'>
  }
    

  // Custom InputTypes

  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }


  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }


  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }


  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }


  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }


  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }


  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
  }


  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }


  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
  }


  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }


  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }


  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
  }


  /**
   * City findRaw
   */
  export type CityFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * City aggregateRaw
   */
  export type CityAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * City.users
   */
  export type City$usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * City.advertisements
   */
  export type City$advertisementsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    where?: AdvertisementWhereInput
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    cursor?: AdvertisementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }


  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
  }



  /**
   * Model Advertisement
   */

  export type AggregateAdvertisement = {
    _count: AdvertisementCountAggregateOutputType | null
    _avg: AdvertisementAvgAggregateOutputType | null
    _sum: AdvertisementSumAggregateOutputType | null
    _min: AdvertisementMinAggregateOutputType | null
    _max: AdvertisementMaxAggregateOutputType | null
  }

  export type AdvertisementAvgAggregateOutputType = {
    pointsSpent: number | null
  }

  export type AdvertisementSumAggregateOutputType = {
    pointsSpent: number | null
  }

  export type AdvertisementMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    cityId: string | null
    title: string | null
    pointsSpent: number | null
    link: string | null
    imageUrl: Buffer | null
    isActive: boolean | null
    startDate: Date | null
    expiryDate: Date | null
  }

  export type AdvertisementMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    cityId: string | null
    title: string | null
    pointsSpent: number | null
    link: string | null
    imageUrl: Buffer | null
    isActive: boolean | null
    startDate: Date | null
    expiryDate: Date | null
  }

  export type AdvertisementCountAggregateOutputType = {
    id: number
    organizationId: number
    cityId: number
    title: number
    pointsSpent: number
    link: number
    imageUrl: number
    isActive: number
    startDate: number
    expiryDate: number
    _all: number
  }


  export type AdvertisementAvgAggregateInputType = {
    pointsSpent?: true
  }

  export type AdvertisementSumAggregateInputType = {
    pointsSpent?: true
  }

  export type AdvertisementMinAggregateInputType = {
    id?: true
    organizationId?: true
    cityId?: true
    title?: true
    pointsSpent?: true
    link?: true
    imageUrl?: true
    isActive?: true
    startDate?: true
    expiryDate?: true
  }

  export type AdvertisementMaxAggregateInputType = {
    id?: true
    organizationId?: true
    cityId?: true
    title?: true
    pointsSpent?: true
    link?: true
    imageUrl?: true
    isActive?: true
    startDate?: true
    expiryDate?: true
  }

  export type AdvertisementCountAggregateInputType = {
    id?: true
    organizationId?: true
    cityId?: true
    title?: true
    pointsSpent?: true
    link?: true
    imageUrl?: true
    isActive?: true
    startDate?: true
    expiryDate?: true
    _all?: true
  }

  export type AdvertisementAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advertisement to aggregate.
     */
    where?: AdvertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
     */
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdvertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Advertisements
    **/
    _count?: true | AdvertisementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdvertisementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdvertisementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdvertisementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdvertisementMaxAggregateInputType
  }

  export type GetAdvertisementAggregateType<T extends AdvertisementAggregateArgs> = {
        [P in keyof T & keyof AggregateAdvertisement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvertisement[P]>
      : GetScalarType<T[P], AggregateAdvertisement[P]>
  }




  export type AdvertisementGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AdvertisementWhereInput
    orderBy?: AdvertisementOrderByWithAggregationInput | AdvertisementOrderByWithAggregationInput[]
    by: AdvertisementScalarFieldEnum[] | AdvertisementScalarFieldEnum
    having?: AdvertisementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdvertisementCountAggregateInputType | true
    _avg?: AdvertisementAvgAggregateInputType
    _sum?: AdvertisementSumAggregateInputType
    _min?: AdvertisementMinAggregateInputType
    _max?: AdvertisementMaxAggregateInputType
  }

  export type AdvertisementGroupByOutputType = {
    id: string
    organizationId: string
    cityId: string
    title: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate: Date
    expiryDate: Date
    _count: AdvertisementCountAggregateOutputType | null
    _avg: AdvertisementAvgAggregateOutputType | null
    _sum: AdvertisementSumAggregateOutputType | null
    _min: AdvertisementMinAggregateOutputType | null
    _max: AdvertisementMaxAggregateOutputType | null
  }

  type GetAdvertisementGroupByPayload<T extends AdvertisementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvertisementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdvertisementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdvertisementGroupByOutputType[P]>
            : GetScalarType<T[P], AdvertisementGroupByOutputType[P]>
        }
      >
    >


  export type AdvertisementSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    cityId?: boolean
    title?: boolean
    pointsSpent?: boolean
    link?: boolean
    imageUrl?: boolean
    isActive?: boolean
    startDate?: boolean
    expiryDate?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    interactions?: boolean | Advertisement$interactionsArgs<ExtArgs>
    _count?: boolean | AdvertisementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["advertisement"]>

  export type AdvertisementSelectScalar = {
    id?: boolean
    organizationId?: boolean
    cityId?: boolean
    title?: boolean
    pointsSpent?: boolean
    link?: boolean
    imageUrl?: boolean
    isActive?: boolean
    startDate?: boolean
    expiryDate?: boolean
  }

  export type AdvertisementInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    interactions?: boolean | Advertisement$interactionsArgs<ExtArgs>
    _count?: boolean | AdvertisementCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AdvertisementPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Advertisement"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      city: Prisma.$CityPayload<ExtArgs>
      interactions: Prisma.$AdInteractionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      organizationId: string
      cityId: string
      title: string
      pointsSpent: number
      link: string
      imageUrl: Buffer
      isActive: boolean
      startDate: Date
      expiryDate: Date
    }, ExtArgs["result"]["advertisement"]>
    composites: {}
  }


  type AdvertisementGetPayload<S extends boolean | null | undefined | AdvertisementDefaultArgs> = $Result.GetResult<Prisma.$AdvertisementPayload, S>

  type AdvertisementCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AdvertisementFindManyArgs, 'select' | 'include'> & {
      select?: AdvertisementCountAggregateInputType | true
    }

  export interface AdvertisementDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Advertisement'], meta: { name: 'Advertisement' } }
    /**
     * Find zero or one Advertisement that matches the filter.
     * @param {AdvertisementFindUniqueArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdvertisementFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdvertisementFindUniqueArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Advertisement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdvertisementFindUniqueOrThrowArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdvertisementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvertisementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Advertisement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementFindFirstArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdvertisementFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvertisementFindFirstArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Advertisement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementFindFirstOrThrowArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdvertisementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvertisementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Advertisements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Advertisements
     * const advertisements = await prisma.advertisement.findMany()
     * 
     * // Get first 10 Advertisements
     * const advertisements = await prisma.advertisement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const advertisementWithIdOnly = await prisma.advertisement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdvertisementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvertisementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Advertisement.
     * @param {AdvertisementCreateArgs} args - Arguments to create a Advertisement.
     * @example
     * // Create one Advertisement
     * const Advertisement = await prisma.advertisement.create({
     *   data: {
     *     // ... data to create a Advertisement
     *   }
     * })
     * 
    **/
    create<T extends AdvertisementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdvertisementCreateArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Advertisements.
     *     @param {AdvertisementCreateManyArgs} args - Arguments to create many Advertisements.
     *     @example
     *     // Create many Advertisements
     *     const advertisement = await prisma.advertisement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdvertisementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvertisementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Advertisement.
     * @param {AdvertisementDeleteArgs} args - Arguments to delete one Advertisement.
     * @example
     * // Delete one Advertisement
     * const Advertisement = await prisma.advertisement.delete({
     *   where: {
     *     // ... filter to delete one Advertisement
     *   }
     * })
     * 
    **/
    delete<T extends AdvertisementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdvertisementDeleteArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Advertisement.
     * @param {AdvertisementUpdateArgs} args - Arguments to update one Advertisement.
     * @example
     * // Update one Advertisement
     * const advertisement = await prisma.advertisement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdvertisementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdvertisementUpdateArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Advertisements.
     * @param {AdvertisementDeleteManyArgs} args - Arguments to filter Advertisements to delete.
     * @example
     * // Delete a few Advertisements
     * const { count } = await prisma.advertisement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdvertisementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvertisementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Advertisements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Advertisements
     * const advertisement = await prisma.advertisement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdvertisementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdvertisementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Advertisement.
     * @param {AdvertisementUpsertArgs} args - Arguments to update or create a Advertisement.
     * @example
     * // Update or create a Advertisement
     * const advertisement = await prisma.advertisement.upsert({
     *   create: {
     *     // ... data to create a Advertisement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Advertisement we want to update
     *   }
     * })
    **/
    upsert<T extends AdvertisementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdvertisementUpsertArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Advertisements that matches the filter.
     * @param {AdvertisementFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const advertisement = await prisma.advertisement.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: AdvertisementFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Advertisement.
     * @param {AdvertisementAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const advertisement = await prisma.advertisement.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: AdvertisementAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Advertisements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementCountArgs} args - Arguments to filter Advertisements to count.
     * @example
     * // Count the number of Advertisements
     * const count = await prisma.advertisement.count({
     *   where: {
     *     // ... the filter for the Advertisements we want to count
     *   }
     * })
    **/
    count<T extends AdvertisementCountArgs>(
      args?: Subset<T, AdvertisementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvertisementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Advertisement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvertisementAggregateArgs>(args: Subset<T, AdvertisementAggregateArgs>): Prisma.PrismaPromise<GetAdvertisementAggregateType<T>>

    /**
     * Group by Advertisement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdvertisementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdvertisementGroupByArgs['orderBy'] }
        : { orderBy?: AdvertisementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdvertisementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvertisementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Advertisement model
   */
  readonly fields: AdvertisementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Advertisement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdvertisementClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    interactions<T extends Advertisement$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, Advertisement$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdInteractionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Advertisement model
   */ 
  interface AdvertisementFieldRefs {
    readonly id: FieldRef<"Advertisement", 'String'>
    readonly organizationId: FieldRef<"Advertisement", 'String'>
    readonly cityId: FieldRef<"Advertisement", 'String'>
    readonly title: FieldRef<"Advertisement", 'String'>
    readonly pointsSpent: FieldRef<"Advertisement", 'Float'>
    readonly link: FieldRef<"Advertisement", 'String'>
    readonly imageUrl: FieldRef<"Advertisement", 'Bytes'>
    readonly isActive: FieldRef<"Advertisement", 'Boolean'>
    readonly startDate: FieldRef<"Advertisement", 'DateTime'>
    readonly expiryDate: FieldRef<"Advertisement", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Advertisement findUnique
   */
  export type AdvertisementFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter, which Advertisement to fetch.
     */
    where: AdvertisementWhereUniqueInput
  }


  /**
   * Advertisement findUniqueOrThrow
   */
  export type AdvertisementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter, which Advertisement to fetch.
     */
    where: AdvertisementWhereUniqueInput
  }


  /**
   * Advertisement findFirst
   */
  export type AdvertisementFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter, which Advertisement to fetch.
     */
    where?: AdvertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
     */
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advertisements.
     */
    cursor?: AdvertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advertisements.
     */
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }


  /**
   * Advertisement findFirstOrThrow
   */
  export type AdvertisementFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter, which Advertisement to fetch.
     */
    where?: AdvertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
     */
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advertisements.
     */
    cursor?: AdvertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advertisements.
     */
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }


  /**
   * Advertisement findMany
   */
  export type AdvertisementFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter, which Advertisements to fetch.
     */
    where?: AdvertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
     */
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Advertisements.
     */
    cursor?: AdvertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
     */
    skip?: number
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }


  /**
   * Advertisement create
   */
  export type AdvertisementCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * The data needed to create a Advertisement.
     */
    data: XOR<AdvertisementCreateInput, AdvertisementUncheckedCreateInput>
  }


  /**
   * Advertisement createMany
   */
  export type AdvertisementCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Advertisements.
     */
    data: AdvertisementCreateManyInput | AdvertisementCreateManyInput[]
  }


  /**
   * Advertisement update
   */
  export type AdvertisementUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * The data needed to update a Advertisement.
     */
    data: XOR<AdvertisementUpdateInput, AdvertisementUncheckedUpdateInput>
    /**
     * Choose, which Advertisement to update.
     */
    where: AdvertisementWhereUniqueInput
  }


  /**
   * Advertisement updateMany
   */
  export type AdvertisementUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Advertisements.
     */
    data: XOR<AdvertisementUpdateManyMutationInput, AdvertisementUncheckedUpdateManyInput>
    /**
     * Filter which Advertisements to update
     */
    where?: AdvertisementWhereInput
  }


  /**
   * Advertisement upsert
   */
  export type AdvertisementUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * The filter to search for the Advertisement to update in case it exists.
     */
    where: AdvertisementWhereUniqueInput
    /**
     * In case the Advertisement found by the `where` argument doesn't exist, create a new Advertisement with this data.
     */
    create: XOR<AdvertisementCreateInput, AdvertisementUncheckedCreateInput>
    /**
     * In case the Advertisement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdvertisementUpdateInput, AdvertisementUncheckedUpdateInput>
  }


  /**
   * Advertisement delete
   */
  export type AdvertisementDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter which Advertisement to delete.
     */
    where: AdvertisementWhereUniqueInput
  }


  /**
   * Advertisement deleteMany
   */
  export type AdvertisementDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advertisements to delete
     */
    where?: AdvertisementWhereInput
  }


  /**
   * Advertisement findRaw
   */
  export type AdvertisementFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Advertisement aggregateRaw
   */
  export type AdvertisementAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Advertisement.interactions
   */
  export type Advertisement$interactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
    where?: AdInteractionWhereInput
    orderBy?: AdInteractionOrderByWithRelationInput | AdInteractionOrderByWithRelationInput[]
    cursor?: AdInteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdInteractionScalarFieldEnum | AdInteractionScalarFieldEnum[]
  }


  /**
   * Advertisement without action
   */
  export type AdvertisementDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
  }



  /**
   * Model AdInteraction
   */

  export type AggregateAdInteraction = {
    _count: AdInteractionCountAggregateOutputType | null
    _min: AdInteractionMinAggregateOutputType | null
    _max: AdInteractionMaxAggregateOutputType | null
  }

  export type AdInteractionMinAggregateOutputType = {
    id: string | null
    advertisementId: string | null
    clickedAt: Date | null
  }

  export type AdInteractionMaxAggregateOutputType = {
    id: string | null
    advertisementId: string | null
    clickedAt: Date | null
  }

  export type AdInteractionCountAggregateOutputType = {
    id: number
    advertisementId: number
    clickedAt: number
    _all: number
  }


  export type AdInteractionMinAggregateInputType = {
    id?: true
    advertisementId?: true
    clickedAt?: true
  }

  export type AdInteractionMaxAggregateInputType = {
    id?: true
    advertisementId?: true
    clickedAt?: true
  }

  export type AdInteractionCountAggregateInputType = {
    id?: true
    advertisementId?: true
    clickedAt?: true
    _all?: true
  }

  export type AdInteractionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdInteraction to aggregate.
     */
    where?: AdInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdInteractions to fetch.
     */
    orderBy?: AdInteractionOrderByWithRelationInput | AdInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdInteractions
    **/
    _count?: true | AdInteractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdInteractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdInteractionMaxAggregateInputType
  }

  export type GetAdInteractionAggregateType<T extends AdInteractionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdInteraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdInteraction[P]>
      : GetScalarType<T[P], AggregateAdInteraction[P]>
  }




  export type AdInteractionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AdInteractionWhereInput
    orderBy?: AdInteractionOrderByWithAggregationInput | AdInteractionOrderByWithAggregationInput[]
    by: AdInteractionScalarFieldEnum[] | AdInteractionScalarFieldEnum
    having?: AdInteractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdInteractionCountAggregateInputType | true
    _min?: AdInteractionMinAggregateInputType
    _max?: AdInteractionMaxAggregateInputType
  }

  export type AdInteractionGroupByOutputType = {
    id: string
    advertisementId: string
    clickedAt: Date
    _count: AdInteractionCountAggregateOutputType | null
    _min: AdInteractionMinAggregateOutputType | null
    _max: AdInteractionMaxAggregateOutputType | null
  }

  type GetAdInteractionGroupByPayload<T extends AdInteractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdInteractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdInteractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdInteractionGroupByOutputType[P]>
            : GetScalarType<T[P], AdInteractionGroupByOutputType[P]>
        }
      >
    >


  export type AdInteractionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    advertisementId?: boolean
    clickedAt?: boolean
    advertisement?: boolean | AdvertisementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adInteraction"]>

  export type AdInteractionSelectScalar = {
    id?: boolean
    advertisementId?: boolean
    clickedAt?: boolean
  }

  export type AdInteractionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    advertisement?: boolean | AdvertisementDefaultArgs<ExtArgs>
  }


  export type $AdInteractionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "AdInteraction"
    objects: {
      advertisement: Prisma.$AdvertisementPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      advertisementId: string
      clickedAt: Date
    }, ExtArgs["result"]["adInteraction"]>
    composites: {}
  }


  type AdInteractionGetPayload<S extends boolean | null | undefined | AdInteractionDefaultArgs> = $Result.GetResult<Prisma.$AdInteractionPayload, S>

  type AdInteractionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AdInteractionFindManyArgs, 'select' | 'include'> & {
      select?: AdInteractionCountAggregateInputType | true
    }

  export interface AdInteractionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdInteraction'], meta: { name: 'AdInteraction' } }
    /**
     * Find zero or one AdInteraction that matches the filter.
     * @param {AdInteractionFindUniqueArgs} args - Arguments to find a AdInteraction
     * @example
     * // Get one AdInteraction
     * const adInteraction = await prisma.adInteraction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdInteractionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdInteractionFindUniqueArgs<ExtArgs>>
    ): Prisma__AdInteractionClient<$Result.GetResult<Prisma.$AdInteractionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AdInteraction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdInteractionFindUniqueOrThrowArgs} args - Arguments to find a AdInteraction
     * @example
     * // Get one AdInteraction
     * const adInteraction = await prisma.adInteraction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdInteractionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdInteractionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdInteractionClient<$Result.GetResult<Prisma.$AdInteractionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AdInteraction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdInteractionFindFirstArgs} args - Arguments to find a AdInteraction
     * @example
     * // Get one AdInteraction
     * const adInteraction = await prisma.adInteraction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdInteractionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdInteractionFindFirstArgs<ExtArgs>>
    ): Prisma__AdInteractionClient<$Result.GetResult<Prisma.$AdInteractionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AdInteraction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdInteractionFindFirstOrThrowArgs} args - Arguments to find a AdInteraction
     * @example
     * // Get one AdInteraction
     * const adInteraction = await prisma.adInteraction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdInteractionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdInteractionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdInteractionClient<$Result.GetResult<Prisma.$AdInteractionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AdInteractions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdInteractionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdInteractions
     * const adInteractions = await prisma.adInteraction.findMany()
     * 
     * // Get first 10 AdInteractions
     * const adInteractions = await prisma.adInteraction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adInteractionWithIdOnly = await prisma.adInteraction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdInteractionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdInteractionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdInteractionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AdInteraction.
     * @param {AdInteractionCreateArgs} args - Arguments to create a AdInteraction.
     * @example
     * // Create one AdInteraction
     * const AdInteraction = await prisma.adInteraction.create({
     *   data: {
     *     // ... data to create a AdInteraction
     *   }
     * })
     * 
    **/
    create<T extends AdInteractionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdInteractionCreateArgs<ExtArgs>>
    ): Prisma__AdInteractionClient<$Result.GetResult<Prisma.$AdInteractionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AdInteractions.
     *     @param {AdInteractionCreateManyArgs} args - Arguments to create many AdInteractions.
     *     @example
     *     // Create many AdInteractions
     *     const adInteraction = await prisma.adInteraction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdInteractionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdInteractionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdInteraction.
     * @param {AdInteractionDeleteArgs} args - Arguments to delete one AdInteraction.
     * @example
     * // Delete one AdInteraction
     * const AdInteraction = await prisma.adInteraction.delete({
     *   where: {
     *     // ... filter to delete one AdInteraction
     *   }
     * })
     * 
    **/
    delete<T extends AdInteractionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdInteractionDeleteArgs<ExtArgs>>
    ): Prisma__AdInteractionClient<$Result.GetResult<Prisma.$AdInteractionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AdInteraction.
     * @param {AdInteractionUpdateArgs} args - Arguments to update one AdInteraction.
     * @example
     * // Update one AdInteraction
     * const adInteraction = await prisma.adInteraction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdInteractionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdInteractionUpdateArgs<ExtArgs>>
    ): Prisma__AdInteractionClient<$Result.GetResult<Prisma.$AdInteractionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AdInteractions.
     * @param {AdInteractionDeleteManyArgs} args - Arguments to filter AdInteractions to delete.
     * @example
     * // Delete a few AdInteractions
     * const { count } = await prisma.adInteraction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdInteractionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdInteractionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdInteractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdInteractions
     * const adInteraction = await prisma.adInteraction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdInteractionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdInteractionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdInteraction.
     * @param {AdInteractionUpsertArgs} args - Arguments to update or create a AdInteraction.
     * @example
     * // Update or create a AdInteraction
     * const adInteraction = await prisma.adInteraction.upsert({
     *   create: {
     *     // ... data to create a AdInteraction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdInteraction we want to update
     *   }
     * })
    **/
    upsert<T extends AdInteractionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdInteractionUpsertArgs<ExtArgs>>
    ): Prisma__AdInteractionClient<$Result.GetResult<Prisma.$AdInteractionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more AdInteractions that matches the filter.
     * @param {AdInteractionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const adInteraction = await prisma.adInteraction.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: AdInteractionFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AdInteraction.
     * @param {AdInteractionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const adInteraction = await prisma.adInteraction.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: AdInteractionAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of AdInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdInteractionCountArgs} args - Arguments to filter AdInteractions to count.
     * @example
     * // Count the number of AdInteractions
     * const count = await prisma.adInteraction.count({
     *   where: {
     *     // ... the filter for the AdInteractions we want to count
     *   }
     * })
    **/
    count<T extends AdInteractionCountArgs>(
      args?: Subset<T, AdInteractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdInteractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdInteractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdInteractionAggregateArgs>(args: Subset<T, AdInteractionAggregateArgs>): Prisma.PrismaPromise<GetAdInteractionAggregateType<T>>

    /**
     * Group by AdInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdInteractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdInteractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdInteractionGroupByArgs['orderBy'] }
        : { orderBy?: AdInteractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdInteractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdInteractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdInteraction model
   */
  readonly fields: AdInteractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdInteraction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdInteractionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    advertisement<T extends AdvertisementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdvertisementDefaultArgs<ExtArgs>>): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AdInteraction model
   */ 
  interface AdInteractionFieldRefs {
    readonly id: FieldRef<"AdInteraction", 'String'>
    readonly advertisementId: FieldRef<"AdInteraction", 'String'>
    readonly clickedAt: FieldRef<"AdInteraction", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * AdInteraction findUnique
   */
  export type AdInteractionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
    /**
     * Filter, which AdInteraction to fetch.
     */
    where: AdInteractionWhereUniqueInput
  }


  /**
   * AdInteraction findUniqueOrThrow
   */
  export type AdInteractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
    /**
     * Filter, which AdInteraction to fetch.
     */
    where: AdInteractionWhereUniqueInput
  }


  /**
   * AdInteraction findFirst
   */
  export type AdInteractionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
    /**
     * Filter, which AdInteraction to fetch.
     */
    where?: AdInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdInteractions to fetch.
     */
    orderBy?: AdInteractionOrderByWithRelationInput | AdInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdInteractions.
     */
    cursor?: AdInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdInteractions.
     */
    distinct?: AdInteractionScalarFieldEnum | AdInteractionScalarFieldEnum[]
  }


  /**
   * AdInteraction findFirstOrThrow
   */
  export type AdInteractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
    /**
     * Filter, which AdInteraction to fetch.
     */
    where?: AdInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdInteractions to fetch.
     */
    orderBy?: AdInteractionOrderByWithRelationInput | AdInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdInteractions.
     */
    cursor?: AdInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdInteractions.
     */
    distinct?: AdInteractionScalarFieldEnum | AdInteractionScalarFieldEnum[]
  }


  /**
   * AdInteraction findMany
   */
  export type AdInteractionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
    /**
     * Filter, which AdInteractions to fetch.
     */
    where?: AdInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdInteractions to fetch.
     */
    orderBy?: AdInteractionOrderByWithRelationInput | AdInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdInteractions.
     */
    cursor?: AdInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdInteractions.
     */
    skip?: number
    distinct?: AdInteractionScalarFieldEnum | AdInteractionScalarFieldEnum[]
  }


  /**
   * AdInteraction create
   */
  export type AdInteractionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
    /**
     * The data needed to create a AdInteraction.
     */
    data: XOR<AdInteractionCreateInput, AdInteractionUncheckedCreateInput>
  }


  /**
   * AdInteraction createMany
   */
  export type AdInteractionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdInteractions.
     */
    data: AdInteractionCreateManyInput | AdInteractionCreateManyInput[]
  }


  /**
   * AdInteraction update
   */
  export type AdInteractionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
    /**
     * The data needed to update a AdInteraction.
     */
    data: XOR<AdInteractionUpdateInput, AdInteractionUncheckedUpdateInput>
    /**
     * Choose, which AdInteraction to update.
     */
    where: AdInteractionWhereUniqueInput
  }


  /**
   * AdInteraction updateMany
   */
  export type AdInteractionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdInteractions.
     */
    data: XOR<AdInteractionUpdateManyMutationInput, AdInteractionUncheckedUpdateManyInput>
    /**
     * Filter which AdInteractions to update
     */
    where?: AdInteractionWhereInput
  }


  /**
   * AdInteraction upsert
   */
  export type AdInteractionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
    /**
     * The filter to search for the AdInteraction to update in case it exists.
     */
    where: AdInteractionWhereUniqueInput
    /**
     * In case the AdInteraction found by the `where` argument doesn't exist, create a new AdInteraction with this data.
     */
    create: XOR<AdInteractionCreateInput, AdInteractionUncheckedCreateInput>
    /**
     * In case the AdInteraction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdInteractionUpdateInput, AdInteractionUncheckedUpdateInput>
  }


  /**
   * AdInteraction delete
   */
  export type AdInteractionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
    /**
     * Filter which AdInteraction to delete.
     */
    where: AdInteractionWhereUniqueInput
  }


  /**
   * AdInteraction deleteMany
   */
  export type AdInteractionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdInteractions to delete
     */
    where?: AdInteractionWhereInput
  }


  /**
   * AdInteraction findRaw
   */
  export type AdInteractionFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * AdInteraction aggregateRaw
   */
  export type AdInteractionAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * AdInteraction without action
   */
  export type AdInteractionDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
  }



  /**
   * Model KeyValueStore
   */

  export type AggregateKeyValueStore = {
    _count: KeyValueStoreCountAggregateOutputType | null
    _min: KeyValueStoreMinAggregateOutputType | null
    _max: KeyValueStoreMaxAggregateOutputType | null
  }

  export type KeyValueStoreMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
  }

  export type KeyValueStoreMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
  }

  export type KeyValueStoreCountAggregateOutputType = {
    id: number
    key: number
    value: number
    _all: number
  }


  export type KeyValueStoreMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type KeyValueStoreMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
  }

  export type KeyValueStoreCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    _all?: true
  }

  export type KeyValueStoreAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeyValueStore to aggregate.
     */
    where?: KeyValueStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyValueStores to fetch.
     */
    orderBy?: KeyValueStoreOrderByWithRelationInput | KeyValueStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KeyValueStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyValueStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyValueStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KeyValueStores
    **/
    _count?: true | KeyValueStoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeyValueStoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeyValueStoreMaxAggregateInputType
  }

  export type GetKeyValueStoreAggregateType<T extends KeyValueStoreAggregateArgs> = {
        [P in keyof T & keyof AggregateKeyValueStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeyValueStore[P]>
      : GetScalarType<T[P], AggregateKeyValueStore[P]>
  }




  export type KeyValueStoreGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: KeyValueStoreWhereInput
    orderBy?: KeyValueStoreOrderByWithAggregationInput | KeyValueStoreOrderByWithAggregationInput[]
    by: KeyValueStoreScalarFieldEnum[] | KeyValueStoreScalarFieldEnum
    having?: KeyValueStoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeyValueStoreCountAggregateInputType | true
    _min?: KeyValueStoreMinAggregateInputType
    _max?: KeyValueStoreMaxAggregateInputType
  }

  export type KeyValueStoreGroupByOutputType = {
    id: string
    key: string
    value: string
    _count: KeyValueStoreCountAggregateOutputType | null
    _min: KeyValueStoreMinAggregateOutputType | null
    _max: KeyValueStoreMaxAggregateOutputType | null
  }

  type GetKeyValueStoreGroupByPayload<T extends KeyValueStoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeyValueStoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeyValueStoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeyValueStoreGroupByOutputType[P]>
            : GetScalarType<T[P], KeyValueStoreGroupByOutputType[P]>
        }
      >
    >


  export type KeyValueStoreSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
  }, ExtArgs["result"]["keyValueStore"]>

  export type KeyValueStoreSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
  }


  export type $KeyValueStorePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "KeyValueStore"
    objects: {}
    scalars: $Extensions.GetResult<{
      id: string
      key: string
      value: string
    }, ExtArgs["result"]["keyValueStore"]>
    composites: {}
  }


  type KeyValueStoreGetPayload<S extends boolean | null | undefined | KeyValueStoreDefaultArgs> = $Result.GetResult<Prisma.$KeyValueStorePayload, S>

  type KeyValueStoreCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<KeyValueStoreFindManyArgs, 'select' | 'include'> & {
      select?: KeyValueStoreCountAggregateInputType | true
    }

  export interface KeyValueStoreDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KeyValueStore'], meta: { name: 'KeyValueStore' } }
    /**
     * Find zero or one KeyValueStore that matches the filter.
     * @param {KeyValueStoreFindUniqueArgs} args - Arguments to find a KeyValueStore
     * @example
     * // Get one KeyValueStore
     * const keyValueStore = await prisma.keyValueStore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends KeyValueStoreFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, KeyValueStoreFindUniqueArgs<ExtArgs>>
    ): Prisma__KeyValueStoreClient<$Result.GetResult<Prisma.$KeyValueStorePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one KeyValueStore that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {KeyValueStoreFindUniqueOrThrowArgs} args - Arguments to find a KeyValueStore
     * @example
     * // Get one KeyValueStore
     * const keyValueStore = await prisma.keyValueStore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends KeyValueStoreFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, KeyValueStoreFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__KeyValueStoreClient<$Result.GetResult<Prisma.$KeyValueStorePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first KeyValueStore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyValueStoreFindFirstArgs} args - Arguments to find a KeyValueStore
     * @example
     * // Get one KeyValueStore
     * const keyValueStore = await prisma.keyValueStore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends KeyValueStoreFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, KeyValueStoreFindFirstArgs<ExtArgs>>
    ): Prisma__KeyValueStoreClient<$Result.GetResult<Prisma.$KeyValueStorePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first KeyValueStore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyValueStoreFindFirstOrThrowArgs} args - Arguments to find a KeyValueStore
     * @example
     * // Get one KeyValueStore
     * const keyValueStore = await prisma.keyValueStore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends KeyValueStoreFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, KeyValueStoreFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__KeyValueStoreClient<$Result.GetResult<Prisma.$KeyValueStorePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more KeyValueStores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyValueStoreFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KeyValueStores
     * const keyValueStores = await prisma.keyValueStore.findMany()
     * 
     * // Get first 10 KeyValueStores
     * const keyValueStores = await prisma.keyValueStore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keyValueStoreWithIdOnly = await prisma.keyValueStore.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends KeyValueStoreFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, KeyValueStoreFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KeyValueStorePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a KeyValueStore.
     * @param {KeyValueStoreCreateArgs} args - Arguments to create a KeyValueStore.
     * @example
     * // Create one KeyValueStore
     * const KeyValueStore = await prisma.keyValueStore.create({
     *   data: {
     *     // ... data to create a KeyValueStore
     *   }
     * })
     * 
    **/
    create<T extends KeyValueStoreCreateArgs<ExtArgs>>(
      args: SelectSubset<T, KeyValueStoreCreateArgs<ExtArgs>>
    ): Prisma__KeyValueStoreClient<$Result.GetResult<Prisma.$KeyValueStorePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many KeyValueStores.
     *     @param {KeyValueStoreCreateManyArgs} args - Arguments to create many KeyValueStores.
     *     @example
     *     // Create many KeyValueStores
     *     const keyValueStore = await prisma.keyValueStore.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends KeyValueStoreCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, KeyValueStoreCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a KeyValueStore.
     * @param {KeyValueStoreDeleteArgs} args - Arguments to delete one KeyValueStore.
     * @example
     * // Delete one KeyValueStore
     * const KeyValueStore = await prisma.keyValueStore.delete({
     *   where: {
     *     // ... filter to delete one KeyValueStore
     *   }
     * })
     * 
    **/
    delete<T extends KeyValueStoreDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, KeyValueStoreDeleteArgs<ExtArgs>>
    ): Prisma__KeyValueStoreClient<$Result.GetResult<Prisma.$KeyValueStorePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one KeyValueStore.
     * @param {KeyValueStoreUpdateArgs} args - Arguments to update one KeyValueStore.
     * @example
     * // Update one KeyValueStore
     * const keyValueStore = await prisma.keyValueStore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends KeyValueStoreUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, KeyValueStoreUpdateArgs<ExtArgs>>
    ): Prisma__KeyValueStoreClient<$Result.GetResult<Prisma.$KeyValueStorePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more KeyValueStores.
     * @param {KeyValueStoreDeleteManyArgs} args - Arguments to filter KeyValueStores to delete.
     * @example
     * // Delete a few KeyValueStores
     * const { count } = await prisma.keyValueStore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends KeyValueStoreDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, KeyValueStoreDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KeyValueStores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyValueStoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KeyValueStores
     * const keyValueStore = await prisma.keyValueStore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends KeyValueStoreUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, KeyValueStoreUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one KeyValueStore.
     * @param {KeyValueStoreUpsertArgs} args - Arguments to update or create a KeyValueStore.
     * @example
     * // Update or create a KeyValueStore
     * const keyValueStore = await prisma.keyValueStore.upsert({
     *   create: {
     *     // ... data to create a KeyValueStore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KeyValueStore we want to update
     *   }
     * })
    **/
    upsert<T extends KeyValueStoreUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, KeyValueStoreUpsertArgs<ExtArgs>>
    ): Prisma__KeyValueStoreClient<$Result.GetResult<Prisma.$KeyValueStorePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more KeyValueStores that matches the filter.
     * @param {KeyValueStoreFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const keyValueStore = await prisma.keyValueStore.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: KeyValueStoreFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a KeyValueStore.
     * @param {KeyValueStoreAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const keyValueStore = await prisma.keyValueStore.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: KeyValueStoreAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of KeyValueStores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyValueStoreCountArgs} args - Arguments to filter KeyValueStores to count.
     * @example
     * // Count the number of KeyValueStores
     * const count = await prisma.keyValueStore.count({
     *   where: {
     *     // ... the filter for the KeyValueStores we want to count
     *   }
     * })
    **/
    count<T extends KeyValueStoreCountArgs>(
      args?: Subset<T, KeyValueStoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeyValueStoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KeyValueStore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyValueStoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeyValueStoreAggregateArgs>(args: Subset<T, KeyValueStoreAggregateArgs>): Prisma.PrismaPromise<GetKeyValueStoreAggregateType<T>>

    /**
     * Group by KeyValueStore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeyValueStoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KeyValueStoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KeyValueStoreGroupByArgs['orderBy'] }
        : { orderBy?: KeyValueStoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KeyValueStoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeyValueStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KeyValueStore model
   */
  readonly fields: KeyValueStoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KeyValueStore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KeyValueStoreClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the KeyValueStore model
   */ 
  interface KeyValueStoreFieldRefs {
    readonly id: FieldRef<"KeyValueStore", 'String'>
    readonly key: FieldRef<"KeyValueStore", 'String'>
    readonly value: FieldRef<"KeyValueStore", 'String'>
  }
    

  // Custom InputTypes

  /**
   * KeyValueStore findUnique
   */
  export type KeyValueStoreFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyValueStore
     */
    select?: KeyValueStoreSelect<ExtArgs> | null
    /**
     * Filter, which KeyValueStore to fetch.
     */
    where: KeyValueStoreWhereUniqueInput
  }


  /**
   * KeyValueStore findUniqueOrThrow
   */
  export type KeyValueStoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyValueStore
     */
    select?: KeyValueStoreSelect<ExtArgs> | null
    /**
     * Filter, which KeyValueStore to fetch.
     */
    where: KeyValueStoreWhereUniqueInput
  }


  /**
   * KeyValueStore findFirst
   */
  export type KeyValueStoreFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyValueStore
     */
    select?: KeyValueStoreSelect<ExtArgs> | null
    /**
     * Filter, which KeyValueStore to fetch.
     */
    where?: KeyValueStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyValueStores to fetch.
     */
    orderBy?: KeyValueStoreOrderByWithRelationInput | KeyValueStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeyValueStores.
     */
    cursor?: KeyValueStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyValueStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyValueStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeyValueStores.
     */
    distinct?: KeyValueStoreScalarFieldEnum | KeyValueStoreScalarFieldEnum[]
  }


  /**
   * KeyValueStore findFirstOrThrow
   */
  export type KeyValueStoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyValueStore
     */
    select?: KeyValueStoreSelect<ExtArgs> | null
    /**
     * Filter, which KeyValueStore to fetch.
     */
    where?: KeyValueStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyValueStores to fetch.
     */
    orderBy?: KeyValueStoreOrderByWithRelationInput | KeyValueStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KeyValueStores.
     */
    cursor?: KeyValueStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyValueStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyValueStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KeyValueStores.
     */
    distinct?: KeyValueStoreScalarFieldEnum | KeyValueStoreScalarFieldEnum[]
  }


  /**
   * KeyValueStore findMany
   */
  export type KeyValueStoreFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyValueStore
     */
    select?: KeyValueStoreSelect<ExtArgs> | null
    /**
     * Filter, which KeyValueStores to fetch.
     */
    where?: KeyValueStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KeyValueStores to fetch.
     */
    orderBy?: KeyValueStoreOrderByWithRelationInput | KeyValueStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KeyValueStores.
     */
    cursor?: KeyValueStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KeyValueStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KeyValueStores.
     */
    skip?: number
    distinct?: KeyValueStoreScalarFieldEnum | KeyValueStoreScalarFieldEnum[]
  }


  /**
   * KeyValueStore create
   */
  export type KeyValueStoreCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyValueStore
     */
    select?: KeyValueStoreSelect<ExtArgs> | null
    /**
     * The data needed to create a KeyValueStore.
     */
    data: XOR<KeyValueStoreCreateInput, KeyValueStoreUncheckedCreateInput>
  }


  /**
   * KeyValueStore createMany
   */
  export type KeyValueStoreCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KeyValueStores.
     */
    data: KeyValueStoreCreateManyInput | KeyValueStoreCreateManyInput[]
  }


  /**
   * KeyValueStore update
   */
  export type KeyValueStoreUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyValueStore
     */
    select?: KeyValueStoreSelect<ExtArgs> | null
    /**
     * The data needed to update a KeyValueStore.
     */
    data: XOR<KeyValueStoreUpdateInput, KeyValueStoreUncheckedUpdateInput>
    /**
     * Choose, which KeyValueStore to update.
     */
    where: KeyValueStoreWhereUniqueInput
  }


  /**
   * KeyValueStore updateMany
   */
  export type KeyValueStoreUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KeyValueStores.
     */
    data: XOR<KeyValueStoreUpdateManyMutationInput, KeyValueStoreUncheckedUpdateManyInput>
    /**
     * Filter which KeyValueStores to update
     */
    where?: KeyValueStoreWhereInput
  }


  /**
   * KeyValueStore upsert
   */
  export type KeyValueStoreUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyValueStore
     */
    select?: KeyValueStoreSelect<ExtArgs> | null
    /**
     * The filter to search for the KeyValueStore to update in case it exists.
     */
    where: KeyValueStoreWhereUniqueInput
    /**
     * In case the KeyValueStore found by the `where` argument doesn't exist, create a new KeyValueStore with this data.
     */
    create: XOR<KeyValueStoreCreateInput, KeyValueStoreUncheckedCreateInput>
    /**
     * In case the KeyValueStore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KeyValueStoreUpdateInput, KeyValueStoreUncheckedUpdateInput>
  }


  /**
   * KeyValueStore delete
   */
  export type KeyValueStoreDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyValueStore
     */
    select?: KeyValueStoreSelect<ExtArgs> | null
    /**
     * Filter which KeyValueStore to delete.
     */
    where: KeyValueStoreWhereUniqueInput
  }


  /**
   * KeyValueStore deleteMany
   */
  export type KeyValueStoreDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which KeyValueStores to delete
     */
    where?: KeyValueStoreWhereInput
  }


  /**
   * KeyValueStore findRaw
   */
  export type KeyValueStoreFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * KeyValueStore aggregateRaw
   */
  export type KeyValueStoreAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * KeyValueStore without action
   */
  export type KeyValueStoreDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeyValueStore
     */
    select?: KeyValueStoreSelect<ExtArgs> | null
  }



  /**
   * Model Listing
   */

  export type AggregateListing = {
    _count: ListingCountAggregateOutputType | null
    _avg: ListingAvgAggregateOutputType | null
    _sum: ListingSumAggregateOutputType | null
    _min: ListingMinAggregateOutputType | null
    _max: ListingMaxAggregateOutputType | null
  }

  export type ListingAvgAggregateOutputType = {
    price: number | null
  }

  export type ListingSumAggregateOutputType = {
    price: number | null
  }

  export type ListingMinAggregateOutputType = {
    id: string | null
    title: string | null
    price: number | null
    categoryId: string | null
    conditionId: string | null
    description: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    status: string | null
  }

  export type ListingMaxAggregateOutputType = {
    id: string | null
    title: string | null
    price: number | null
    categoryId: string | null
    conditionId: string | null
    description: string | null
    location: string | null
    createdAt: Date | null
    updatedAt: Date | null
    userId: string | null
    status: string | null
  }

  export type ListingCountAggregateOutputType = {
    id: number
    title: number
    price: number
    categoryId: number
    conditionId: number
    description: number
    location: number
    createdAt: number
    updatedAt: number
    userId: number
    status: number
    _all: number
  }


  export type ListingAvgAggregateInputType = {
    price?: true
  }

  export type ListingSumAggregateInputType = {
    price?: true
  }

  export type ListingMinAggregateInputType = {
    id?: true
    title?: true
    price?: true
    categoryId?: true
    conditionId?: true
    description?: true
    location?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    status?: true
  }

  export type ListingMaxAggregateInputType = {
    id?: true
    title?: true
    price?: true
    categoryId?: true
    conditionId?: true
    description?: true
    location?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    status?: true
  }

  export type ListingCountAggregateInputType = {
    id?: true
    title?: true
    price?: true
    categoryId?: true
    conditionId?: true
    description?: true
    location?: true
    createdAt?: true
    updatedAt?: true
    userId?: true
    status?: true
    _all?: true
  }

  export type ListingAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Listing to aggregate.
     */
    where?: ListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Listings to fetch.
     */
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Listings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Listings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Listings
    **/
    _count?: true | ListingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ListingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ListingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ListingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ListingMaxAggregateInputType
  }

  export type GetListingAggregateType<T extends ListingAggregateArgs> = {
        [P in keyof T & keyof AggregateListing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateListing[P]>
      : GetScalarType<T[P], AggregateListing[P]>
  }




  export type ListingGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithAggregationInput | ListingOrderByWithAggregationInput[]
    by: ListingScalarFieldEnum[] | ListingScalarFieldEnum
    having?: ListingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ListingCountAggregateInputType | true
    _avg?: ListingAvgAggregateInputType
    _sum?: ListingSumAggregateInputType
    _min?: ListingMinAggregateInputType
    _max?: ListingMaxAggregateInputType
  }

  export type ListingGroupByOutputType = {
    id: string
    title: string
    price: number
    categoryId: string
    conditionId: string
    description: string
    location: string
    createdAt: Date
    updatedAt: Date
    userId: string
    status: string
    _count: ListingCountAggregateOutputType | null
    _avg: ListingAvgAggregateOutputType | null
    _sum: ListingSumAggregateOutputType | null
    _min: ListingMinAggregateOutputType | null
    _max: ListingMaxAggregateOutputType | null
  }

  type GetListingGroupByPayload<T extends ListingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ListingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ListingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ListingGroupByOutputType[P]>
            : GetScalarType<T[P], ListingGroupByOutputType[P]>
        }
      >
    >


  export type ListingSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    price?: boolean
    categoryId?: boolean
    conditionId?: boolean
    description?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    status?: boolean
    photos?: boolean | Listing$photosArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    condition?: boolean | ConditionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    sales?: boolean | Listing$salesArgs<ExtArgs>
    conversations?: boolean | Listing$conversationsArgs<ExtArgs>
    savedByUsers?: boolean | Listing$savedByUsersArgs<ExtArgs>
    reports?: boolean | Listing$reportsArgs<ExtArgs>
    _count?: boolean | ListingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["listing"]>

  export type ListingSelectScalar = {
    id?: boolean
    title?: boolean
    price?: boolean
    categoryId?: boolean
    conditionId?: boolean
    description?: boolean
    location?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    userId?: boolean
    status?: boolean
  }

  export type ListingInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    photos?: boolean | Listing$photosArgs<ExtArgs>
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    condition?: boolean | ConditionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    sales?: boolean | Listing$salesArgs<ExtArgs>
    conversations?: boolean | Listing$conversationsArgs<ExtArgs>
    savedByUsers?: boolean | Listing$savedByUsersArgs<ExtArgs>
    reports?: boolean | Listing$reportsArgs<ExtArgs>
    _count?: boolean | ListingCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ListingPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Listing"
    objects: {
      photos: Prisma.$PhotoPayload<ExtArgs>[]
      category: Prisma.$CategoryPayload<ExtArgs>
      condition: Prisma.$ConditionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      sales: Prisma.$SalePayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      savedByUsers: Prisma.$SavedListingPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      title: string
      price: number
      categoryId: string
      conditionId: string
      description: string
      location: string
      createdAt: Date
      updatedAt: Date
      userId: string
      status: string
    }, ExtArgs["result"]["listing"]>
    composites: {}
  }


  type ListingGetPayload<S extends boolean | null | undefined | ListingDefaultArgs> = $Result.GetResult<Prisma.$ListingPayload, S>

  type ListingCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ListingFindManyArgs, 'select' | 'include'> & {
      select?: ListingCountAggregateInputType | true
    }

  export interface ListingDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Listing'], meta: { name: 'Listing' } }
    /**
     * Find zero or one Listing that matches the filter.
     * @param {ListingFindUniqueArgs} args - Arguments to find a Listing
     * @example
     * // Get one Listing
     * const listing = await prisma.listing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ListingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ListingFindUniqueArgs<ExtArgs>>
    ): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Listing that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ListingFindUniqueOrThrowArgs} args - Arguments to find a Listing
     * @example
     * // Get one Listing
     * const listing = await prisma.listing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ListingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ListingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Listing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingFindFirstArgs} args - Arguments to find a Listing
     * @example
     * // Get one Listing
     * const listing = await prisma.listing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ListingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ListingFindFirstArgs<ExtArgs>>
    ): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Listing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingFindFirstOrThrowArgs} args - Arguments to find a Listing
     * @example
     * // Get one Listing
     * const listing = await prisma.listing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ListingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ListingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Listings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Listings
     * const listings = await prisma.listing.findMany()
     * 
     * // Get first 10 Listings
     * const listings = await prisma.listing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const listingWithIdOnly = await prisma.listing.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ListingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ListingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Listing.
     * @param {ListingCreateArgs} args - Arguments to create a Listing.
     * @example
     * // Create one Listing
     * const Listing = await prisma.listing.create({
     *   data: {
     *     // ... data to create a Listing
     *   }
     * })
     * 
    **/
    create<T extends ListingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ListingCreateArgs<ExtArgs>>
    ): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Listings.
     *     @param {ListingCreateManyArgs} args - Arguments to create many Listings.
     *     @example
     *     // Create many Listings
     *     const listing = await prisma.listing.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ListingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ListingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Listing.
     * @param {ListingDeleteArgs} args - Arguments to delete one Listing.
     * @example
     * // Delete one Listing
     * const Listing = await prisma.listing.delete({
     *   where: {
     *     // ... filter to delete one Listing
     *   }
     * })
     * 
    **/
    delete<T extends ListingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ListingDeleteArgs<ExtArgs>>
    ): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Listing.
     * @param {ListingUpdateArgs} args - Arguments to update one Listing.
     * @example
     * // Update one Listing
     * const listing = await prisma.listing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ListingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ListingUpdateArgs<ExtArgs>>
    ): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Listings.
     * @param {ListingDeleteManyArgs} args - Arguments to filter Listings to delete.
     * @example
     * // Delete a few Listings
     * const { count } = await prisma.listing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ListingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ListingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Listings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Listings
     * const listing = await prisma.listing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ListingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ListingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Listing.
     * @param {ListingUpsertArgs} args - Arguments to update or create a Listing.
     * @example
     * // Update or create a Listing
     * const listing = await prisma.listing.upsert({
     *   create: {
     *     // ... data to create a Listing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Listing we want to update
     *   }
     * })
    **/
    upsert<T extends ListingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ListingUpsertArgs<ExtArgs>>
    ): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Listings that matches the filter.
     * @param {ListingFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const listing = await prisma.listing.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ListingFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Listing.
     * @param {ListingAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const listing = await prisma.listing.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ListingAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Listings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingCountArgs} args - Arguments to filter Listings to count.
     * @example
     * // Count the number of Listings
     * const count = await prisma.listing.count({
     *   where: {
     *     // ... the filter for the Listings we want to count
     *   }
     * })
    **/
    count<T extends ListingCountArgs>(
      args?: Subset<T, ListingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ListingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Listing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ListingAggregateArgs>(args: Subset<T, ListingAggregateArgs>): Prisma.PrismaPromise<GetListingAggregateType<T>>

    /**
     * Group by Listing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ListingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ListingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ListingGroupByArgs['orderBy'] }
        : { orderBy?: ListingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ListingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetListingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Listing model
   */
  readonly fields: ListingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Listing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ListingClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    photos<T extends Listing$photosArgs<ExtArgs> = {}>(args?: Subset<T, Listing$photosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'findMany'> | Null>;

    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    condition<T extends ConditionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConditionDefaultArgs<ExtArgs>>): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    sales<T extends Listing$salesArgs<ExtArgs> = {}>(args?: Subset<T, Listing$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, 'findMany'> | Null>;

    conversations<T extends Listing$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Listing$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findMany'> | Null>;

    savedByUsers<T extends Listing$savedByUsersArgs<ExtArgs> = {}>(args?: Subset<T, Listing$savedByUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedListingPayload<ExtArgs>, T, 'findMany'> | Null>;

    reports<T extends Listing$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Listing$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Listing model
   */ 
  interface ListingFieldRefs {
    readonly id: FieldRef<"Listing", 'String'>
    readonly title: FieldRef<"Listing", 'String'>
    readonly price: FieldRef<"Listing", 'Float'>
    readonly categoryId: FieldRef<"Listing", 'String'>
    readonly conditionId: FieldRef<"Listing", 'String'>
    readonly description: FieldRef<"Listing", 'String'>
    readonly location: FieldRef<"Listing", 'String'>
    readonly createdAt: FieldRef<"Listing", 'DateTime'>
    readonly updatedAt: FieldRef<"Listing", 'DateTime'>
    readonly userId: FieldRef<"Listing", 'String'>
    readonly status: FieldRef<"Listing", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Listing findUnique
   */
  export type ListingFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listing to fetch.
     */
    where: ListingWhereUniqueInput
  }


  /**
   * Listing findUniqueOrThrow
   */
  export type ListingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listing to fetch.
     */
    where: ListingWhereUniqueInput
  }


  /**
   * Listing findFirst
   */
  export type ListingFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listing to fetch.
     */
    where?: ListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Listings to fetch.
     */
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Listings.
     */
    cursor?: ListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Listings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Listings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Listings.
     */
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }


  /**
   * Listing findFirstOrThrow
   */
  export type ListingFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listing to fetch.
     */
    where?: ListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Listings to fetch.
     */
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Listings.
     */
    cursor?: ListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Listings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Listings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Listings.
     */
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }


  /**
   * Listing findMany
   */
  export type ListingFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter, which Listings to fetch.
     */
    where?: ListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Listings to fetch.
     */
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Listings.
     */
    cursor?: ListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Listings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Listings.
     */
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }


  /**
   * Listing create
   */
  export type ListingCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * The data needed to create a Listing.
     */
    data: XOR<ListingCreateInput, ListingUncheckedCreateInput>
  }


  /**
   * Listing createMany
   */
  export type ListingCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Listings.
     */
    data: ListingCreateManyInput | ListingCreateManyInput[]
  }


  /**
   * Listing update
   */
  export type ListingUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * The data needed to update a Listing.
     */
    data: XOR<ListingUpdateInput, ListingUncheckedUpdateInput>
    /**
     * Choose, which Listing to update.
     */
    where: ListingWhereUniqueInput
  }


  /**
   * Listing updateMany
   */
  export type ListingUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Listings.
     */
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyInput>
    /**
     * Filter which Listings to update
     */
    where?: ListingWhereInput
  }


  /**
   * Listing upsert
   */
  export type ListingUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * The filter to search for the Listing to update in case it exists.
     */
    where: ListingWhereUniqueInput
    /**
     * In case the Listing found by the `where` argument doesn't exist, create a new Listing with this data.
     */
    create: XOR<ListingCreateInput, ListingUncheckedCreateInput>
    /**
     * In case the Listing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ListingUpdateInput, ListingUncheckedUpdateInput>
  }


  /**
   * Listing delete
   */
  export type ListingDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListingInclude<ExtArgs> | null
    /**
     * Filter which Listing to delete.
     */
    where: ListingWhereUniqueInput
  }


  /**
   * Listing deleteMany
   */
  export type ListingDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Listings to delete
     */
    where?: ListingWhereInput
  }


  /**
   * Listing findRaw
   */
  export type ListingFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Listing aggregateRaw
   */
  export type ListingAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Listing.photos
   */
  export type Listing$photosArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
    where?: PhotoWhereInput
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    cursor?: PhotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }


  /**
   * Listing.sales
   */
  export type Listing$salesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }


  /**
   * Listing.conversations
   */
  export type Listing$conversationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }


  /**
   * Listing.savedByUsers
   */
  export type Listing$savedByUsersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedListing
     */
    select?: SavedListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SavedListingInclude<ExtArgs> | null
    where?: SavedListingWhereInput
    orderBy?: SavedListingOrderByWithRelationInput | SavedListingOrderByWithRelationInput[]
    cursor?: SavedListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedListingScalarFieldEnum | SavedListingScalarFieldEnum[]
  }


  /**
   * Listing.reports
   */
  export type Listing$reportsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }


  /**
   * Listing without action
   */
  export type ListingDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListingInclude<ExtArgs> | null
  }



  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    listingId: string | null
    reportedById: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    listingId: string | null
    reportedById: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    listingId: number
    reportedById: number
    reason: number
    createdAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    listingId?: true
    reportedById?: true
    reason?: true
    createdAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    listingId?: true
    reportedById?: true
    reason?: true
    createdAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    listingId?: true
    reportedById?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    listingId: string
    reportedById: string
    reason: string
    createdAt: Date
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    listingId?: boolean
    reportedById?: boolean
    reason?: boolean
    createdAt?: boolean
    listing?: boolean | ListingDefaultArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    listingId?: boolean
    reportedById?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type ReportInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    listing?: boolean | ListingDefaultArgs<ExtArgs>
    reportedBy?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $ReportPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      listing: Prisma.$ListingPayload<ExtArgs>
      reportedBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      listingId: string
      reportedById: string
      reason: string
      createdAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }


  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReportFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReportFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReportFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
    **/
    create<T extends ReportCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportCreateArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Reports.
     *     @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     *     @example
     *     // Create many Reports
     *     const report = await prisma.report.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReportCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
    **/
    delete<T extends ReportDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReportUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReportDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReportUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
    **/
    upsert<T extends ReportUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>
    ): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * @param {ReportFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const report = await prisma.report.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ReportFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Report.
     * @param {ReportAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const report = await prisma.report.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ReportAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    listing<T extends ListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ListingDefaultArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    reportedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly listingId: FieldRef<"Report", 'String'>
    readonly reportedById: FieldRef<"Report", 'String'>
    readonly reason: FieldRef<"Report", 'String'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }


  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }


  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }


  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }


  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
  }


  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }


  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }


  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }


  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }


  /**
   * Report findRaw
   */
  export type ReportFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Report aggregateRaw
   */
  export type ReportAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReportInclude<ExtArgs> | null
  }



  /**
   * Model SavedListing
   */

  export type AggregateSavedListing = {
    _count: SavedListingCountAggregateOutputType | null
    _min: SavedListingMinAggregateOutputType | null
    _max: SavedListingMaxAggregateOutputType | null
  }

  export type SavedListingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    listingId: string | null
    createdAt: Date | null
  }

  export type SavedListingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    listingId: string | null
    createdAt: Date | null
  }

  export type SavedListingCountAggregateOutputType = {
    id: number
    userId: number
    listingId: number
    createdAt: number
    _all: number
  }


  export type SavedListingMinAggregateInputType = {
    id?: true
    userId?: true
    listingId?: true
    createdAt?: true
  }

  export type SavedListingMaxAggregateInputType = {
    id?: true
    userId?: true
    listingId?: true
    createdAt?: true
  }

  export type SavedListingCountAggregateInputType = {
    id?: true
    userId?: true
    listingId?: true
    createdAt?: true
    _all?: true
  }

  export type SavedListingAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedListing to aggregate.
     */
    where?: SavedListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedListings to fetch.
     */
    orderBy?: SavedListingOrderByWithRelationInput | SavedListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SavedListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SavedListings
    **/
    _count?: true | SavedListingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavedListingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavedListingMaxAggregateInputType
  }

  export type GetSavedListingAggregateType<T extends SavedListingAggregateArgs> = {
        [P in keyof T & keyof AggregateSavedListing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavedListing[P]>
      : GetScalarType<T[P], AggregateSavedListing[P]>
  }




  export type SavedListingGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SavedListingWhereInput
    orderBy?: SavedListingOrderByWithAggregationInput | SavedListingOrderByWithAggregationInput[]
    by: SavedListingScalarFieldEnum[] | SavedListingScalarFieldEnum
    having?: SavedListingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavedListingCountAggregateInputType | true
    _min?: SavedListingMinAggregateInputType
    _max?: SavedListingMaxAggregateInputType
  }

  export type SavedListingGroupByOutputType = {
    id: string
    userId: string
    listingId: string
    createdAt: Date
    _count: SavedListingCountAggregateOutputType | null
    _min: SavedListingMinAggregateOutputType | null
    _max: SavedListingMaxAggregateOutputType | null
  }

  type GetSavedListingGroupByPayload<T extends SavedListingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavedListingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavedListingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavedListingGroupByOutputType[P]>
            : GetScalarType<T[P], SavedListingGroupByOutputType[P]>
        }
      >
    >


  export type SavedListingSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    listingId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    listing?: boolean | ListingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedListing"]>

  export type SavedListingSelectScalar = {
    id?: boolean
    userId?: boolean
    listingId?: boolean
    createdAt?: boolean
  }

  export type SavedListingInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    listing?: boolean | ListingDefaultArgs<ExtArgs>
  }


  export type $SavedListingPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "SavedListing"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      listing: Prisma.$ListingPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      userId: string
      listingId: string
      createdAt: Date
    }, ExtArgs["result"]["savedListing"]>
    composites: {}
  }


  type SavedListingGetPayload<S extends boolean | null | undefined | SavedListingDefaultArgs> = $Result.GetResult<Prisma.$SavedListingPayload, S>

  type SavedListingCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SavedListingFindManyArgs, 'select' | 'include'> & {
      select?: SavedListingCountAggregateInputType | true
    }

  export interface SavedListingDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SavedListing'], meta: { name: 'SavedListing' } }
    /**
     * Find zero or one SavedListing that matches the filter.
     * @param {SavedListingFindUniqueArgs} args - Arguments to find a SavedListing
     * @example
     * // Get one SavedListing
     * const savedListing = await prisma.savedListing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SavedListingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SavedListingFindUniqueArgs<ExtArgs>>
    ): Prisma__SavedListingClient<$Result.GetResult<Prisma.$SavedListingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one SavedListing that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SavedListingFindUniqueOrThrowArgs} args - Arguments to find a SavedListing
     * @example
     * // Get one SavedListing
     * const savedListing = await prisma.savedListing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SavedListingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SavedListingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SavedListingClient<$Result.GetResult<Prisma.$SavedListingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first SavedListing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedListingFindFirstArgs} args - Arguments to find a SavedListing
     * @example
     * // Get one SavedListing
     * const savedListing = await prisma.savedListing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SavedListingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SavedListingFindFirstArgs<ExtArgs>>
    ): Prisma__SavedListingClient<$Result.GetResult<Prisma.$SavedListingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first SavedListing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedListingFindFirstOrThrowArgs} args - Arguments to find a SavedListing
     * @example
     * // Get one SavedListing
     * const savedListing = await prisma.savedListing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SavedListingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SavedListingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SavedListingClient<$Result.GetResult<Prisma.$SavedListingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more SavedListings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedListingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedListings
     * const savedListings = await prisma.savedListing.findMany()
     * 
     * // Get first 10 SavedListings
     * const savedListings = await prisma.savedListing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const savedListingWithIdOnly = await prisma.savedListing.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SavedListingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SavedListingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedListingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a SavedListing.
     * @param {SavedListingCreateArgs} args - Arguments to create a SavedListing.
     * @example
     * // Create one SavedListing
     * const SavedListing = await prisma.savedListing.create({
     *   data: {
     *     // ... data to create a SavedListing
     *   }
     * })
     * 
    **/
    create<T extends SavedListingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SavedListingCreateArgs<ExtArgs>>
    ): Prisma__SavedListingClient<$Result.GetResult<Prisma.$SavedListingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many SavedListings.
     *     @param {SavedListingCreateManyArgs} args - Arguments to create many SavedListings.
     *     @example
     *     // Create many SavedListings
     *     const savedListing = await prisma.savedListing.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SavedListingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SavedListingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SavedListing.
     * @param {SavedListingDeleteArgs} args - Arguments to delete one SavedListing.
     * @example
     * // Delete one SavedListing
     * const SavedListing = await prisma.savedListing.delete({
     *   where: {
     *     // ... filter to delete one SavedListing
     *   }
     * })
     * 
    **/
    delete<T extends SavedListingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SavedListingDeleteArgs<ExtArgs>>
    ): Prisma__SavedListingClient<$Result.GetResult<Prisma.$SavedListingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one SavedListing.
     * @param {SavedListingUpdateArgs} args - Arguments to update one SavedListing.
     * @example
     * // Update one SavedListing
     * const savedListing = await prisma.savedListing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SavedListingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SavedListingUpdateArgs<ExtArgs>>
    ): Prisma__SavedListingClient<$Result.GetResult<Prisma.$SavedListingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more SavedListings.
     * @param {SavedListingDeleteManyArgs} args - Arguments to filter SavedListings to delete.
     * @example
     * // Delete a few SavedListings
     * const { count } = await prisma.savedListing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SavedListingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SavedListingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedListingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedListings
     * const savedListing = await prisma.savedListing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SavedListingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SavedListingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SavedListing.
     * @param {SavedListingUpsertArgs} args - Arguments to update or create a SavedListing.
     * @example
     * // Update or create a SavedListing
     * const savedListing = await prisma.savedListing.upsert({
     *   create: {
     *     // ... data to create a SavedListing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedListing we want to update
     *   }
     * })
    **/
    upsert<T extends SavedListingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SavedListingUpsertArgs<ExtArgs>>
    ): Prisma__SavedListingClient<$Result.GetResult<Prisma.$SavedListingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more SavedListings that matches the filter.
     * @param {SavedListingFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const savedListing = await prisma.savedListing.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: SavedListingFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SavedListing.
     * @param {SavedListingAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const savedListing = await prisma.savedListing.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: SavedListingAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of SavedListings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedListingCountArgs} args - Arguments to filter SavedListings to count.
     * @example
     * // Count the number of SavedListings
     * const count = await prisma.savedListing.count({
     *   where: {
     *     // ... the filter for the SavedListings we want to count
     *   }
     * })
    **/
    count<T extends SavedListingCountArgs>(
      args?: Subset<T, SavedListingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavedListingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavedListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedListingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedListingAggregateArgs>(args: Subset<T, SavedListingAggregateArgs>): Prisma.PrismaPromise<GetSavedListingAggregateType<T>>

    /**
     * Group by SavedListing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedListingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SavedListingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SavedListingGroupByArgs['orderBy'] }
        : { orderBy?: SavedListingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SavedListingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedListingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SavedListing model
   */
  readonly fields: SavedListingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SavedListing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SavedListingClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    listing<T extends ListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ListingDefaultArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the SavedListing model
   */ 
  interface SavedListingFieldRefs {
    readonly id: FieldRef<"SavedListing", 'String'>
    readonly userId: FieldRef<"SavedListing", 'String'>
    readonly listingId: FieldRef<"SavedListing", 'String'>
    readonly createdAt: FieldRef<"SavedListing", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * SavedListing findUnique
   */
  export type SavedListingFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedListing
     */
    select?: SavedListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SavedListingInclude<ExtArgs> | null
    /**
     * Filter, which SavedListing to fetch.
     */
    where: SavedListingWhereUniqueInput
  }


  /**
   * SavedListing findUniqueOrThrow
   */
  export type SavedListingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedListing
     */
    select?: SavedListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SavedListingInclude<ExtArgs> | null
    /**
     * Filter, which SavedListing to fetch.
     */
    where: SavedListingWhereUniqueInput
  }


  /**
   * SavedListing findFirst
   */
  export type SavedListingFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedListing
     */
    select?: SavedListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SavedListingInclude<ExtArgs> | null
    /**
     * Filter, which SavedListing to fetch.
     */
    where?: SavedListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedListings to fetch.
     */
    orderBy?: SavedListingOrderByWithRelationInput | SavedListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedListings.
     */
    cursor?: SavedListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedListings.
     */
    distinct?: SavedListingScalarFieldEnum | SavedListingScalarFieldEnum[]
  }


  /**
   * SavedListing findFirstOrThrow
   */
  export type SavedListingFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedListing
     */
    select?: SavedListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SavedListingInclude<ExtArgs> | null
    /**
     * Filter, which SavedListing to fetch.
     */
    where?: SavedListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedListings to fetch.
     */
    orderBy?: SavedListingOrderByWithRelationInput | SavedListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedListings.
     */
    cursor?: SavedListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedListings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedListings.
     */
    distinct?: SavedListingScalarFieldEnum | SavedListingScalarFieldEnum[]
  }


  /**
   * SavedListing findMany
   */
  export type SavedListingFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedListing
     */
    select?: SavedListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SavedListingInclude<ExtArgs> | null
    /**
     * Filter, which SavedListings to fetch.
     */
    where?: SavedListingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedListings to fetch.
     */
    orderBy?: SavedListingOrderByWithRelationInput | SavedListingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SavedListings.
     */
    cursor?: SavedListingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedListings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedListings.
     */
    skip?: number
    distinct?: SavedListingScalarFieldEnum | SavedListingScalarFieldEnum[]
  }


  /**
   * SavedListing create
   */
  export type SavedListingCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedListing
     */
    select?: SavedListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SavedListingInclude<ExtArgs> | null
    /**
     * The data needed to create a SavedListing.
     */
    data: XOR<SavedListingCreateInput, SavedListingUncheckedCreateInput>
  }


  /**
   * SavedListing createMany
   */
  export type SavedListingCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SavedListings.
     */
    data: SavedListingCreateManyInput | SavedListingCreateManyInput[]
  }


  /**
   * SavedListing update
   */
  export type SavedListingUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedListing
     */
    select?: SavedListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SavedListingInclude<ExtArgs> | null
    /**
     * The data needed to update a SavedListing.
     */
    data: XOR<SavedListingUpdateInput, SavedListingUncheckedUpdateInput>
    /**
     * Choose, which SavedListing to update.
     */
    where: SavedListingWhereUniqueInput
  }


  /**
   * SavedListing updateMany
   */
  export type SavedListingUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SavedListings.
     */
    data: XOR<SavedListingUpdateManyMutationInput, SavedListingUncheckedUpdateManyInput>
    /**
     * Filter which SavedListings to update
     */
    where?: SavedListingWhereInput
  }


  /**
   * SavedListing upsert
   */
  export type SavedListingUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedListing
     */
    select?: SavedListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SavedListingInclude<ExtArgs> | null
    /**
     * The filter to search for the SavedListing to update in case it exists.
     */
    where: SavedListingWhereUniqueInput
    /**
     * In case the SavedListing found by the `where` argument doesn't exist, create a new SavedListing with this data.
     */
    create: XOR<SavedListingCreateInput, SavedListingUncheckedCreateInput>
    /**
     * In case the SavedListing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SavedListingUpdateInput, SavedListingUncheckedUpdateInput>
  }


  /**
   * SavedListing delete
   */
  export type SavedListingDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedListing
     */
    select?: SavedListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SavedListingInclude<ExtArgs> | null
    /**
     * Filter which SavedListing to delete.
     */
    where: SavedListingWhereUniqueInput
  }


  /**
   * SavedListing deleteMany
   */
  export type SavedListingDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedListings to delete
     */
    where?: SavedListingWhereInput
  }


  /**
   * SavedListing findRaw
   */
  export type SavedListingFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * SavedListing aggregateRaw
   */
  export type SavedListingAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * SavedListing without action
   */
  export type SavedListingDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedListing
     */
    select?: SavedListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SavedListingInclude<ExtArgs> | null
  }



  /**
   * Model Sale
   */

  export type AggregateSale = {
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  export type SaleAvgAggregateOutputType = {
    salePrice: number | null
  }

  export type SaleSumAggregateOutputType = {
    salePrice: number | null
  }

  export type SaleMinAggregateOutputType = {
    id: string | null
    buyerId: string | null
    listingId: string | null
    conversationId: string | null
    salePrice: number | null
    saleDate: Date | null
  }

  export type SaleMaxAggregateOutputType = {
    id: string | null
    buyerId: string | null
    listingId: string | null
    conversationId: string | null
    salePrice: number | null
    saleDate: Date | null
  }

  export type SaleCountAggregateOutputType = {
    id: number
    buyerId: number
    listingId: number
    conversationId: number
    salePrice: number
    saleDate: number
    _all: number
  }


  export type SaleAvgAggregateInputType = {
    salePrice?: true
  }

  export type SaleSumAggregateInputType = {
    salePrice?: true
  }

  export type SaleMinAggregateInputType = {
    id?: true
    buyerId?: true
    listingId?: true
    conversationId?: true
    salePrice?: true
    saleDate?: true
  }

  export type SaleMaxAggregateInputType = {
    id?: true
    buyerId?: true
    listingId?: true
    conversationId?: true
    salePrice?: true
    saleDate?: true
  }

  export type SaleCountAggregateInputType = {
    id?: true
    buyerId?: true
    listingId?: true
    conversationId?: true
    salePrice?: true
    saleDate?: true
    _all?: true
  }

  export type SaleAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sale to aggregate.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sales
    **/
    _count?: true | SaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleMaxAggregateInputType
  }

  export type GetSaleAggregateType<T extends SaleAggregateArgs> = {
        [P in keyof T & keyof AggregateSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSale[P]>
      : GetScalarType<T[P], AggregateSale[P]>
  }




  export type SaleGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithAggregationInput | SaleOrderByWithAggregationInput[]
    by: SaleScalarFieldEnum[] | SaleScalarFieldEnum
    having?: SaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleCountAggregateInputType | true
    _avg?: SaleAvgAggregateInputType
    _sum?: SaleSumAggregateInputType
    _min?: SaleMinAggregateInputType
    _max?: SaleMaxAggregateInputType
  }

  export type SaleGroupByOutputType = {
    id: string
    buyerId: string
    listingId: string
    conversationId: string | null
    salePrice: number
    saleDate: Date
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  type GetSaleGroupByPayload<T extends SaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleGroupByOutputType[P]>
            : GetScalarType<T[P], SaleGroupByOutputType[P]>
        }
      >
    >


  export type SaleSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    buyerId?: boolean
    listingId?: boolean
    conversationId?: boolean
    salePrice?: boolean
    saleDate?: boolean
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    listing?: boolean | ListingDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    rating?: boolean | Sale$ratingArgs<ExtArgs>
    _count?: boolean | SaleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectScalar = {
    id?: boolean
    buyerId?: boolean
    listingId?: boolean
    conversationId?: boolean
    salePrice?: boolean
    saleDate?: boolean
  }

  export type SaleInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    buyer?: boolean | UserDefaultArgs<ExtArgs>
    listing?: boolean | ListingDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    rating?: boolean | Sale$ratingArgs<ExtArgs>
    _count?: boolean | SaleCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $SalePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Sale"
    objects: {
      buyer: Prisma.$UserPayload<ExtArgs>
      listing: Prisma.$ListingPayload<ExtArgs>
      conversation: Prisma.$ConversationPayload<ExtArgs> | null
      rating: Prisma.$RatingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      buyerId: string
      listingId: string
      conversationId: string | null
      salePrice: number
      saleDate: Date
    }, ExtArgs["result"]["sale"]>
    composites: {}
  }


  type SaleGetPayload<S extends boolean | null | undefined | SaleDefaultArgs> = $Result.GetResult<Prisma.$SalePayload, S>

  type SaleCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SaleFindManyArgs, 'select' | 'include'> & {
      select?: SaleCountAggregateInputType | true
    }

  export interface SaleDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sale'], meta: { name: 'Sale' } }
    /**
     * Find zero or one Sale that matches the filter.
     * @param {SaleFindUniqueArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SaleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SaleFindUniqueArgs<ExtArgs>>
    ): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Sale that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SaleFindUniqueOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SaleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SaleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Sale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SaleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SaleFindFirstArgs<ExtArgs>>
    ): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Sale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SaleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SaleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sales
     * const sales = await prisma.sale.findMany()
     * 
     * // Get first 10 Sales
     * const sales = await prisma.sale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleWithIdOnly = await prisma.sale.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SaleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SaleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Sale.
     * @param {SaleCreateArgs} args - Arguments to create a Sale.
     * @example
     * // Create one Sale
     * const Sale = await prisma.sale.create({
     *   data: {
     *     // ... data to create a Sale
     *   }
     * })
     * 
    **/
    create<T extends SaleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SaleCreateArgs<ExtArgs>>
    ): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Sales.
     *     @param {SaleCreateManyArgs} args - Arguments to create many Sales.
     *     @example
     *     // Create many Sales
     *     const sale = await prisma.sale.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SaleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SaleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sale.
     * @param {SaleDeleteArgs} args - Arguments to delete one Sale.
     * @example
     * // Delete one Sale
     * const Sale = await prisma.sale.delete({
     *   where: {
     *     // ... filter to delete one Sale
     *   }
     * })
     * 
    **/
    delete<T extends SaleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SaleDeleteArgs<ExtArgs>>
    ): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Sale.
     * @param {SaleUpdateArgs} args - Arguments to update one Sale.
     * @example
     * // Update one Sale
     * const sale = await prisma.sale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SaleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SaleUpdateArgs<ExtArgs>>
    ): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Sales.
     * @param {SaleDeleteManyArgs} args - Arguments to filter Sales to delete.
     * @example
     * // Delete a few Sales
     * const { count } = await prisma.sale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SaleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SaleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SaleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SaleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sale.
     * @param {SaleUpsertArgs} args - Arguments to update or create a Sale.
     * @example
     * // Update or create a Sale
     * const sale = await prisma.sale.upsert({
     *   create: {
     *     // ... data to create a Sale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sale we want to update
     *   }
     * })
    **/
    upsert<T extends SaleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SaleUpsertArgs<ExtArgs>>
    ): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Sales that matches the filter.
     * @param {SaleFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const sale = await prisma.sale.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: SaleFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Sale.
     * @param {SaleAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const sale = await prisma.sale.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: SaleAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleCountArgs} args - Arguments to filter Sales to count.
     * @example
     * // Count the number of Sales
     * const count = await prisma.sale.count({
     *   where: {
     *     // ... the filter for the Sales we want to count
     *   }
     * })
    **/
    count<T extends SaleCountArgs>(
      args?: Subset<T, SaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleAggregateArgs>(args: Subset<T, SaleAggregateArgs>): Prisma.PrismaPromise<GetSaleAggregateType<T>>

    /**
     * Group by Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleGroupByArgs['orderBy'] }
        : { orderBy?: SaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sale model
   */
  readonly fields: SaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    buyer<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    listing<T extends ListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ListingDefaultArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    rating<T extends Sale$ratingArgs<ExtArgs> = {}>(args?: Subset<T, Sale$ratingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Sale model
   */ 
  interface SaleFieldRefs {
    readonly id: FieldRef<"Sale", 'String'>
    readonly buyerId: FieldRef<"Sale", 'String'>
    readonly listingId: FieldRef<"Sale", 'String'>
    readonly conversationId: FieldRef<"Sale", 'String'>
    readonly salePrice: FieldRef<"Sale", 'Float'>
    readonly saleDate: FieldRef<"Sale", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Sale findUnique
   */
  export type SaleFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }


  /**
   * Sale findUniqueOrThrow
   */
  export type SaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }


  /**
   * Sale findFirst
   */
  export type SaleFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }


  /**
   * Sale findFirstOrThrow
   */
  export type SaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }


  /**
   * Sale findMany
   */
  export type SaleFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sales to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }


  /**
   * Sale create
   */
  export type SaleCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to create a Sale.
     */
    data: XOR<SaleCreateInput, SaleUncheckedCreateInput>
  }


  /**
   * Sale createMany
   */
  export type SaleCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
  }


  /**
   * Sale update
   */
  export type SaleUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to update a Sale.
     */
    data: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
    /**
     * Choose, which Sale to update.
     */
    where: SaleWhereUniqueInput
  }


  /**
   * Sale updateMany
   */
  export type SaleUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sales.
     */
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SaleWhereInput
  }


  /**
   * Sale upsert
   */
  export type SaleUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The filter to search for the Sale to update in case it exists.
     */
    where: SaleWhereUniqueInput
    /**
     * In case the Sale found by the `where` argument doesn't exist, create a new Sale with this data.
     */
    create: XOR<SaleCreateInput, SaleUncheckedCreateInput>
    /**
     * In case the Sale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
  }


  /**
   * Sale delete
   */
  export type SaleDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter which Sale to delete.
     */
    where: SaleWhereUniqueInput
  }


  /**
   * Sale deleteMany
   */
  export type SaleDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sales to delete
     */
    where?: SaleWhereInput
  }


  /**
   * Sale findRaw
   */
  export type SaleFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Sale aggregateRaw
   */
  export type SaleAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Sale.rating
   */
  export type Sale$ratingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    cursor?: RatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }


  /**
   * Sale without action
   */
  export type SaleDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleInclude<ExtArgs> | null
  }



  /**
   * Model Rating
   */

  export type AggregateRating = {
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  export type RatingAvgAggregateOutputType = {
    value: number | null
  }

  export type RatingSumAggregateOutputType = {
    value: number | null
  }

  export type RatingMinAggregateOutputType = {
    id: string | null
    value: number | null
    comment: string | null
    saleId: string | null
    raterId: string | null
    rateeId: string | null
    createdAt: Date | null
    type: string | null
  }

  export type RatingMaxAggregateOutputType = {
    id: string | null
    value: number | null
    comment: string | null
    saleId: string | null
    raterId: string | null
    rateeId: string | null
    createdAt: Date | null
    type: string | null
  }

  export type RatingCountAggregateOutputType = {
    id: number
    value: number
    comment: number
    saleId: number
    raterId: number
    rateeId: number
    createdAt: number
    type: number
    _all: number
  }


  export type RatingAvgAggregateInputType = {
    value?: true
  }

  export type RatingSumAggregateInputType = {
    value?: true
  }

  export type RatingMinAggregateInputType = {
    id?: true
    value?: true
    comment?: true
    saleId?: true
    raterId?: true
    rateeId?: true
    createdAt?: true
    type?: true
  }

  export type RatingMaxAggregateInputType = {
    id?: true
    value?: true
    comment?: true
    saleId?: true
    raterId?: true
    rateeId?: true
    createdAt?: true
    type?: true
  }

  export type RatingCountAggregateInputType = {
    id?: true
    value?: true
    comment?: true
    saleId?: true
    raterId?: true
    rateeId?: true
    createdAt?: true
    type?: true
    _all?: true
  }

  export type RatingAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rating to aggregate.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ratings
    **/
    _count?: true | RatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RatingMaxAggregateInputType
  }

  export type GetRatingAggregateType<T extends RatingAggregateArgs> = {
        [P in keyof T & keyof AggregateRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRating[P]>
      : GetScalarType<T[P], AggregateRating[P]>
  }




  export type RatingGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: RatingWhereInput
    orderBy?: RatingOrderByWithAggregationInput | RatingOrderByWithAggregationInput[]
    by: RatingScalarFieldEnum[] | RatingScalarFieldEnum
    having?: RatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RatingCountAggregateInputType | true
    _avg?: RatingAvgAggregateInputType
    _sum?: RatingSumAggregateInputType
    _min?: RatingMinAggregateInputType
    _max?: RatingMaxAggregateInputType
  }

  export type RatingGroupByOutputType = {
    id: string
    value: number
    comment: string | null
    saleId: string
    raterId: string
    rateeId: string
    createdAt: Date
    type: string
    _count: RatingCountAggregateOutputType | null
    _avg: RatingAvgAggregateOutputType | null
    _sum: RatingSumAggregateOutputType | null
    _min: RatingMinAggregateOutputType | null
    _max: RatingMaxAggregateOutputType | null
  }

  type GetRatingGroupByPayload<T extends RatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RatingGroupByOutputType[P]>
            : GetScalarType<T[P], RatingGroupByOutputType[P]>
        }
      >
    >


  export type RatingSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    comment?: boolean
    saleId?: boolean
    raterId?: boolean
    rateeId?: boolean
    createdAt?: boolean
    type?: boolean
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    rater?: boolean | UserDefaultArgs<ExtArgs>
    ratee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rating"]>

  export type RatingSelectScalar = {
    id?: boolean
    value?: boolean
    comment?: boolean
    saleId?: boolean
    raterId?: boolean
    rateeId?: boolean
    createdAt?: boolean
    type?: boolean
  }

  export type RatingInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    sale?: boolean | SaleDefaultArgs<ExtArgs>
    rater?: boolean | UserDefaultArgs<ExtArgs>
    ratee?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $RatingPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Rating"
    objects: {
      sale: Prisma.$SalePayload<ExtArgs>
      rater: Prisma.$UserPayload<ExtArgs>
      ratee: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      value: number
      comment: string | null
      saleId: string
      raterId: string
      rateeId: string
      createdAt: Date
      type: string
    }, ExtArgs["result"]["rating"]>
    composites: {}
  }


  type RatingGetPayload<S extends boolean | null | undefined | RatingDefaultArgs> = $Result.GetResult<Prisma.$RatingPayload, S>

  type RatingCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<RatingFindManyArgs, 'select' | 'include'> & {
      select?: RatingCountAggregateInputType | true
    }

  export interface RatingDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rating'], meta: { name: 'Rating' } }
    /**
     * Find zero or one Rating that matches the filter.
     * @param {RatingFindUniqueArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RatingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RatingFindUniqueArgs<ExtArgs>>
    ): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Rating that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RatingFindUniqueOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RatingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RatingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Rating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RatingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RatingFindFirstArgs<ExtArgs>>
    ): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Rating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindFirstOrThrowArgs} args - Arguments to find a Rating
     * @example
     * // Get one Rating
     * const rating = await prisma.rating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RatingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RatingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Ratings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ratings
     * const ratings = await prisma.rating.findMany()
     * 
     * // Get first 10 Ratings
     * const ratings = await prisma.rating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ratingWithIdOnly = await prisma.rating.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RatingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RatingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Rating.
     * @param {RatingCreateArgs} args - Arguments to create a Rating.
     * @example
     * // Create one Rating
     * const Rating = await prisma.rating.create({
     *   data: {
     *     // ... data to create a Rating
     *   }
     * })
     * 
    **/
    create<T extends RatingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RatingCreateArgs<ExtArgs>>
    ): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Ratings.
     *     @param {RatingCreateManyArgs} args - Arguments to create many Ratings.
     *     @example
     *     // Create many Ratings
     *     const rating = await prisma.rating.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RatingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RatingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rating.
     * @param {RatingDeleteArgs} args - Arguments to delete one Rating.
     * @example
     * // Delete one Rating
     * const Rating = await prisma.rating.delete({
     *   where: {
     *     // ... filter to delete one Rating
     *   }
     * })
     * 
    **/
    delete<T extends RatingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RatingDeleteArgs<ExtArgs>>
    ): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Rating.
     * @param {RatingUpdateArgs} args - Arguments to update one Rating.
     * @example
     * // Update one Rating
     * const rating = await prisma.rating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RatingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RatingUpdateArgs<ExtArgs>>
    ): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Ratings.
     * @param {RatingDeleteManyArgs} args - Arguments to filter Ratings to delete.
     * @example
     * // Delete a few Ratings
     * const { count } = await prisma.rating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RatingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RatingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ratings
     * const rating = await prisma.rating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RatingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RatingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rating.
     * @param {RatingUpsertArgs} args - Arguments to update or create a Rating.
     * @example
     * // Update or create a Rating
     * const rating = await prisma.rating.upsert({
     *   create: {
     *     // ... data to create a Rating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rating we want to update
     *   }
     * })
    **/
    upsert<T extends RatingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RatingUpsertArgs<ExtArgs>>
    ): Prisma__RatingClient<$Result.GetResult<Prisma.$RatingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Ratings that matches the filter.
     * @param {RatingFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const rating = await prisma.rating.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: RatingFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Rating.
     * @param {RatingAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const rating = await prisma.rating.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: RatingAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Ratings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingCountArgs} args - Arguments to filter Ratings to count.
     * @example
     * // Count the number of Ratings
     * const count = await prisma.rating.count({
     *   where: {
     *     // ... the filter for the Ratings we want to count
     *   }
     * })
    **/
    count<T extends RatingCountArgs>(
      args?: Subset<T, RatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RatingAggregateArgs>(args: Subset<T, RatingAggregateArgs>): Prisma.PrismaPromise<GetRatingAggregateType<T>>

    /**
     * Group by Rating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RatingGroupByArgs['orderBy'] }
        : { orderBy?: RatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rating model
   */
  readonly fields: RatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RatingClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    sale<T extends SaleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SaleDefaultArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    rater<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    ratee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Rating model
   */ 
  interface RatingFieldRefs {
    readonly id: FieldRef<"Rating", 'String'>
    readonly value: FieldRef<"Rating", 'Int'>
    readonly comment: FieldRef<"Rating", 'String'>
    readonly saleId: FieldRef<"Rating", 'String'>
    readonly raterId: FieldRef<"Rating", 'String'>
    readonly rateeId: FieldRef<"Rating", 'String'>
    readonly createdAt: FieldRef<"Rating", 'DateTime'>
    readonly type: FieldRef<"Rating", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Rating findUnique
   */
  export type RatingFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where: RatingWhereUniqueInput
  }


  /**
   * Rating findUniqueOrThrow
   */
  export type RatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where: RatingWhereUniqueInput
  }


  /**
   * Rating findFirst
   */
  export type RatingFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }


  /**
   * Rating findFirstOrThrow
   */
  export type RatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Rating to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ratings.
     */
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }


  /**
   * Rating findMany
   */
  export type RatingFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter, which Ratings to fetch.
     */
    where?: RatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ratings to fetch.
     */
    orderBy?: RatingOrderByWithRelationInput | RatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ratings.
     */
    cursor?: RatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ratings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ratings.
     */
    skip?: number
    distinct?: RatingScalarFieldEnum | RatingScalarFieldEnum[]
  }


  /**
   * Rating create
   */
  export type RatingCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The data needed to create a Rating.
     */
    data: XOR<RatingCreateInput, RatingUncheckedCreateInput>
  }


  /**
   * Rating createMany
   */
  export type RatingCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ratings.
     */
    data: RatingCreateManyInput | RatingCreateManyInput[]
  }


  /**
   * Rating update
   */
  export type RatingUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The data needed to update a Rating.
     */
    data: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
    /**
     * Choose, which Rating to update.
     */
    where: RatingWhereUniqueInput
  }


  /**
   * Rating updateMany
   */
  export type RatingUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ratings.
     */
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyInput>
    /**
     * Filter which Ratings to update
     */
    where?: RatingWhereInput
  }


  /**
   * Rating upsert
   */
  export type RatingUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * The filter to search for the Rating to update in case it exists.
     */
    where: RatingWhereUniqueInput
    /**
     * In case the Rating found by the `where` argument doesn't exist, create a new Rating with this data.
     */
    create: XOR<RatingCreateInput, RatingUncheckedCreateInput>
    /**
     * In case the Rating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RatingUpdateInput, RatingUncheckedUpdateInput>
  }


  /**
   * Rating delete
   */
  export type RatingDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
    /**
     * Filter which Rating to delete.
     */
    where: RatingWhereUniqueInput
  }


  /**
   * Rating deleteMany
   */
  export type RatingDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ratings to delete
     */
    where?: RatingWhereInput
  }


  /**
   * Rating findRaw
   */
  export type RatingFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Rating aggregateRaw
   */
  export type RatingAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Rating without action
   */
  export type RatingDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rating
     */
    select?: RatingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RatingInclude<ExtArgs> | null
  }



  /**
   * Model Photo
   */

  export type AggregatePhoto = {
    _count: PhotoCountAggregateOutputType | null
    _min: PhotoMinAggregateOutputType | null
    _max: PhotoMaxAggregateOutputType | null
  }

  export type PhotoMinAggregateOutputType = {
    id: string | null
    imageUrl: Buffer | null
    listingId: string | null
  }

  export type PhotoMaxAggregateOutputType = {
    id: string | null
    imageUrl: Buffer | null
    listingId: string | null
  }

  export type PhotoCountAggregateOutputType = {
    id: number
    imageUrl: number
    listingId: number
    _all: number
  }


  export type PhotoMinAggregateInputType = {
    id?: true
    imageUrl?: true
    listingId?: true
  }

  export type PhotoMaxAggregateInputType = {
    id?: true
    imageUrl?: true
    listingId?: true
  }

  export type PhotoCountAggregateInputType = {
    id?: true
    imageUrl?: true
    listingId?: true
    _all?: true
  }

  export type PhotoAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Photo to aggregate.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Photos
    **/
    _count?: true | PhotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhotoMaxAggregateInputType
  }

  export type GetPhotoAggregateType<T extends PhotoAggregateArgs> = {
        [P in keyof T & keyof AggregatePhoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhoto[P]>
      : GetScalarType<T[P], AggregatePhoto[P]>
  }




  export type PhotoGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PhotoWhereInput
    orderBy?: PhotoOrderByWithAggregationInput | PhotoOrderByWithAggregationInput[]
    by: PhotoScalarFieldEnum[] | PhotoScalarFieldEnum
    having?: PhotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhotoCountAggregateInputType | true
    _min?: PhotoMinAggregateInputType
    _max?: PhotoMaxAggregateInputType
  }

  export type PhotoGroupByOutputType = {
    id: string
    imageUrl: Buffer
    listingId: string
    _count: PhotoCountAggregateOutputType | null
    _min: PhotoMinAggregateOutputType | null
    _max: PhotoMaxAggregateOutputType | null
  }

  type GetPhotoGroupByPayload<T extends PhotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhotoGroupByOutputType[P]>
            : GetScalarType<T[P], PhotoGroupByOutputType[P]>
        }
      >
    >


  export type PhotoSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    imageUrl?: boolean
    listingId?: boolean
    listing?: boolean | ListingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["photo"]>

  export type PhotoSelectScalar = {
    id?: boolean
    imageUrl?: boolean
    listingId?: boolean
  }

  export type PhotoInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    listing?: boolean | ListingDefaultArgs<ExtArgs>
  }


  export type $PhotoPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Photo"
    objects: {
      listing: Prisma.$ListingPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      imageUrl: Buffer
      listingId: string
    }, ExtArgs["result"]["photo"]>
    composites: {}
  }


  type PhotoGetPayload<S extends boolean | null | undefined | PhotoDefaultArgs> = $Result.GetResult<Prisma.$PhotoPayload, S>

  type PhotoCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PhotoFindManyArgs, 'select' | 'include'> & {
      select?: PhotoCountAggregateInputType | true
    }

  export interface PhotoDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Photo'], meta: { name: 'Photo' } }
    /**
     * Find zero or one Photo that matches the filter.
     * @param {PhotoFindUniqueArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PhotoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PhotoFindUniqueArgs<ExtArgs>>
    ): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Photo that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PhotoFindUniqueOrThrowArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PhotoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PhotoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Photo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoFindFirstArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PhotoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PhotoFindFirstArgs<ExtArgs>>
    ): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Photo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoFindFirstOrThrowArgs} args - Arguments to find a Photo
     * @example
     * // Get one Photo
     * const photo = await prisma.photo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PhotoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PhotoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Photos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Photos
     * const photos = await prisma.photo.findMany()
     * 
     * // Get first 10 Photos
     * const photos = await prisma.photo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const photoWithIdOnly = await prisma.photo.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PhotoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PhotoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Photo.
     * @param {PhotoCreateArgs} args - Arguments to create a Photo.
     * @example
     * // Create one Photo
     * const Photo = await prisma.photo.create({
     *   data: {
     *     // ... data to create a Photo
     *   }
     * })
     * 
    **/
    create<T extends PhotoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PhotoCreateArgs<ExtArgs>>
    ): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Photos.
     *     @param {PhotoCreateManyArgs} args - Arguments to create many Photos.
     *     @example
     *     // Create many Photos
     *     const photo = await prisma.photo.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PhotoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PhotoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Photo.
     * @param {PhotoDeleteArgs} args - Arguments to delete one Photo.
     * @example
     * // Delete one Photo
     * const Photo = await prisma.photo.delete({
     *   where: {
     *     // ... filter to delete one Photo
     *   }
     * })
     * 
    **/
    delete<T extends PhotoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PhotoDeleteArgs<ExtArgs>>
    ): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Photo.
     * @param {PhotoUpdateArgs} args - Arguments to update one Photo.
     * @example
     * // Update one Photo
     * const photo = await prisma.photo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PhotoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PhotoUpdateArgs<ExtArgs>>
    ): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Photos.
     * @param {PhotoDeleteManyArgs} args - Arguments to filter Photos to delete.
     * @example
     * // Delete a few Photos
     * const { count } = await prisma.photo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PhotoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PhotoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Photos
     * const photo = await prisma.photo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PhotoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PhotoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Photo.
     * @param {PhotoUpsertArgs} args - Arguments to update or create a Photo.
     * @example
     * // Update or create a Photo
     * const photo = await prisma.photo.upsert({
     *   create: {
     *     // ... data to create a Photo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Photo we want to update
     *   }
     * })
    **/
    upsert<T extends PhotoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PhotoUpsertArgs<ExtArgs>>
    ): Prisma__PhotoClient<$Result.GetResult<Prisma.$PhotoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Photos that matches the filter.
     * @param {PhotoFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const photo = await prisma.photo.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: PhotoFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Photo.
     * @param {PhotoAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const photo = await prisma.photo.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: PhotoAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Photos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoCountArgs} args - Arguments to filter Photos to count.
     * @example
     * // Count the number of Photos
     * const count = await prisma.photo.count({
     *   where: {
     *     // ... the filter for the Photos we want to count
     *   }
     * })
    **/
    count<T extends PhotoCountArgs>(
      args?: Subset<T, PhotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Photo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhotoAggregateArgs>(args: Subset<T, PhotoAggregateArgs>): Prisma.PrismaPromise<GetPhotoAggregateType<T>>

    /**
     * Group by Photo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhotoGroupByArgs['orderBy'] }
        : { orderBy?: PhotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Photo model
   */
  readonly fields: PhotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Photo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhotoClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    listing<T extends ListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ListingDefaultArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Photo model
   */ 
  interface PhotoFieldRefs {
    readonly id: FieldRef<"Photo", 'String'>
    readonly imageUrl: FieldRef<"Photo", 'Bytes'>
    readonly listingId: FieldRef<"Photo", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Photo findUnique
   */
  export type PhotoFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where: PhotoWhereUniqueInput
  }


  /**
   * Photo findUniqueOrThrow
   */
  export type PhotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where: PhotoWhereUniqueInput
  }


  /**
   * Photo findFirst
   */
  export type PhotoFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Photos.
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Photos.
     */
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }


  /**
   * Photo findFirstOrThrow
   */
  export type PhotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photo to fetch.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Photos.
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Photos.
     */
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }


  /**
   * Photo findMany
   */
  export type PhotoFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter, which Photos to fetch.
     */
    where?: PhotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Photos to fetch.
     */
    orderBy?: PhotoOrderByWithRelationInput | PhotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Photos.
     */
    cursor?: PhotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Photos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Photos.
     */
    skip?: number
    distinct?: PhotoScalarFieldEnum | PhotoScalarFieldEnum[]
  }


  /**
   * Photo create
   */
  export type PhotoCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * The data needed to create a Photo.
     */
    data: XOR<PhotoCreateInput, PhotoUncheckedCreateInput>
  }


  /**
   * Photo createMany
   */
  export type PhotoCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Photos.
     */
    data: PhotoCreateManyInput | PhotoCreateManyInput[]
  }


  /**
   * Photo update
   */
  export type PhotoUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * The data needed to update a Photo.
     */
    data: XOR<PhotoUpdateInput, PhotoUncheckedUpdateInput>
    /**
     * Choose, which Photo to update.
     */
    where: PhotoWhereUniqueInput
  }


  /**
   * Photo updateMany
   */
  export type PhotoUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Photos.
     */
    data: XOR<PhotoUpdateManyMutationInput, PhotoUncheckedUpdateManyInput>
    /**
     * Filter which Photos to update
     */
    where?: PhotoWhereInput
  }


  /**
   * Photo upsert
   */
  export type PhotoUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * The filter to search for the Photo to update in case it exists.
     */
    where: PhotoWhereUniqueInput
    /**
     * In case the Photo found by the `where` argument doesn't exist, create a new Photo with this data.
     */
    create: XOR<PhotoCreateInput, PhotoUncheckedCreateInput>
    /**
     * In case the Photo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhotoUpdateInput, PhotoUncheckedUpdateInput>
  }


  /**
   * Photo delete
   */
  export type PhotoDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
    /**
     * Filter which Photo to delete.
     */
    where: PhotoWhereUniqueInput
  }


  /**
   * Photo deleteMany
   */
  export type PhotoDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Photos to delete
     */
    where?: PhotoWhereInput
  }


  /**
   * Photo findRaw
   */
  export type PhotoFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Photo aggregateRaw
   */
  export type PhotoAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Photo without action
   */
  export type PhotoDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Photo
     */
    select?: PhotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PhotoInclude<ExtArgs> | null
  }



  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: string
    name: string
    _count: CategoryCountAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    listings?: boolean | Category$listingsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    listings?: boolean | Category$listingsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CategoryPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      listings: Prisma.$ListingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      name: string
    }, ExtArgs["result"]["category"]>
    composites: {}
  }


  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends CategoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Categories.
     *     @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends CategoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * @param {CategoryFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const category = await prisma.category.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CategoryFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Category.
     * @param {CategoryAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const category = await prisma.category.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CategoryAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    listings<T extends Category$listingsArgs<ExtArgs> = {}>(args?: Subset<T, Category$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'String'>
    readonly name: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }


  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
  }


  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }


  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }


  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }


  /**
   * Category findRaw
   */
  export type CategoryFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Category aggregateRaw
   */
  export type CategoryAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Category.listings
   */
  export type Category$listingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    cursor?: ListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }


  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
  }



  /**
   * Model Condition
   */

  export type AggregateCondition = {
    _count: ConditionCountAggregateOutputType | null
    _min: ConditionMinAggregateOutputType | null
    _max: ConditionMaxAggregateOutputType | null
  }

  export type ConditionMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type ConditionMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type ConditionCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ConditionMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ConditionMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ConditionCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ConditionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Condition to aggregate.
     */
    where?: ConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditions to fetch.
     */
    orderBy?: ConditionOrderByWithRelationInput | ConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conditions
    **/
    _count?: true | ConditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConditionMaxAggregateInputType
  }

  export type GetConditionAggregateType<T extends ConditionAggregateArgs> = {
        [P in keyof T & keyof AggregateCondition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCondition[P]>
      : GetScalarType<T[P], AggregateCondition[P]>
  }




  export type ConditionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ConditionWhereInput
    orderBy?: ConditionOrderByWithAggregationInput | ConditionOrderByWithAggregationInput[]
    by: ConditionScalarFieldEnum[] | ConditionScalarFieldEnum
    having?: ConditionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConditionCountAggregateInputType | true
    _min?: ConditionMinAggregateInputType
    _max?: ConditionMaxAggregateInputType
  }

  export type ConditionGroupByOutputType = {
    id: string
    name: string
    _count: ConditionCountAggregateOutputType | null
    _min: ConditionMinAggregateOutputType | null
    _max: ConditionMaxAggregateOutputType | null
  }

  type GetConditionGroupByPayload<T extends ConditionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConditionGroupByOutputType[P]>
            : GetScalarType<T[P], ConditionGroupByOutputType[P]>
        }
      >
    >


  export type ConditionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    listings?: boolean | Condition$listingsArgs<ExtArgs>
    _count?: boolean | ConditionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["condition"]>

  export type ConditionSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type ConditionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    listings?: boolean | Condition$listingsArgs<ExtArgs>
    _count?: boolean | ConditionCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ConditionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Condition"
    objects: {
      listings: Prisma.$ListingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      name: string
    }, ExtArgs["result"]["condition"]>
    composites: {}
  }


  type ConditionGetPayload<S extends boolean | null | undefined | ConditionDefaultArgs> = $Result.GetResult<Prisma.$ConditionPayload, S>

  type ConditionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ConditionFindManyArgs, 'select' | 'include'> & {
      select?: ConditionCountAggregateInputType | true
    }

  export interface ConditionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Condition'], meta: { name: 'Condition' } }
    /**
     * Find zero or one Condition that matches the filter.
     * @param {ConditionFindUniqueArgs} args - Arguments to find a Condition
     * @example
     * // Get one Condition
     * const condition = await prisma.condition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConditionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConditionFindUniqueArgs<ExtArgs>>
    ): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Condition that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConditionFindUniqueOrThrowArgs} args - Arguments to find a Condition
     * @example
     * // Get one Condition
     * const condition = await prisma.condition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConditionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConditionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Condition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionFindFirstArgs} args - Arguments to find a Condition
     * @example
     * // Get one Condition
     * const condition = await prisma.condition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConditionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConditionFindFirstArgs<ExtArgs>>
    ): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Condition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionFindFirstOrThrowArgs} args - Arguments to find a Condition
     * @example
     * // Get one Condition
     * const condition = await prisma.condition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConditionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConditionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Conditions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conditions
     * const conditions = await prisma.condition.findMany()
     * 
     * // Get first 10 Conditions
     * const conditions = await prisma.condition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conditionWithIdOnly = await prisma.condition.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConditionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConditionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Condition.
     * @param {ConditionCreateArgs} args - Arguments to create a Condition.
     * @example
     * // Create one Condition
     * const Condition = await prisma.condition.create({
     *   data: {
     *     // ... data to create a Condition
     *   }
     * })
     * 
    **/
    create<T extends ConditionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConditionCreateArgs<ExtArgs>>
    ): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Conditions.
     *     @param {ConditionCreateManyArgs} args - Arguments to create many Conditions.
     *     @example
     *     // Create many Conditions
     *     const condition = await prisma.condition.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConditionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConditionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Condition.
     * @param {ConditionDeleteArgs} args - Arguments to delete one Condition.
     * @example
     * // Delete one Condition
     * const Condition = await prisma.condition.delete({
     *   where: {
     *     // ... filter to delete one Condition
     *   }
     * })
     * 
    **/
    delete<T extends ConditionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConditionDeleteArgs<ExtArgs>>
    ): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Condition.
     * @param {ConditionUpdateArgs} args - Arguments to update one Condition.
     * @example
     * // Update one Condition
     * const condition = await prisma.condition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConditionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConditionUpdateArgs<ExtArgs>>
    ): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Conditions.
     * @param {ConditionDeleteManyArgs} args - Arguments to filter Conditions to delete.
     * @example
     * // Delete a few Conditions
     * const { count } = await prisma.condition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConditionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConditionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conditions
     * const condition = await prisma.condition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConditionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConditionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Condition.
     * @param {ConditionUpsertArgs} args - Arguments to update or create a Condition.
     * @example
     * // Update or create a Condition
     * const condition = await prisma.condition.upsert({
     *   create: {
     *     // ... data to create a Condition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Condition we want to update
     *   }
     * })
    **/
    upsert<T extends ConditionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConditionUpsertArgs<ExtArgs>>
    ): Prisma__ConditionClient<$Result.GetResult<Prisma.$ConditionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Conditions that matches the filter.
     * @param {ConditionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const condition = await prisma.condition.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ConditionFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Condition.
     * @param {ConditionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const condition = await prisma.condition.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ConditionAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Conditions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionCountArgs} args - Arguments to filter Conditions to count.
     * @example
     * // Count the number of Conditions
     * const count = await prisma.condition.count({
     *   where: {
     *     // ... the filter for the Conditions we want to count
     *   }
     * })
    **/
    count<T extends ConditionCountArgs>(
      args?: Subset<T, ConditionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Condition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConditionAggregateArgs>(args: Subset<T, ConditionAggregateArgs>): Prisma.PrismaPromise<GetConditionAggregateType<T>>

    /**
     * Group by Condition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConditionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConditionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConditionGroupByArgs['orderBy'] }
        : { orderBy?: ConditionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConditionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConditionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Condition model
   */
  readonly fields: ConditionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Condition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConditionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    listings<T extends Condition$listingsArgs<ExtArgs> = {}>(args?: Subset<T, Condition$listingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Condition model
   */ 
  interface ConditionFieldRefs {
    readonly id: FieldRef<"Condition", 'String'>
    readonly name: FieldRef<"Condition", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Condition findUnique
   */
  export type ConditionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionInclude<ExtArgs> | null
    /**
     * Filter, which Condition to fetch.
     */
    where: ConditionWhereUniqueInput
  }


  /**
   * Condition findUniqueOrThrow
   */
  export type ConditionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionInclude<ExtArgs> | null
    /**
     * Filter, which Condition to fetch.
     */
    where: ConditionWhereUniqueInput
  }


  /**
   * Condition findFirst
   */
  export type ConditionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionInclude<ExtArgs> | null
    /**
     * Filter, which Condition to fetch.
     */
    where?: ConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditions to fetch.
     */
    orderBy?: ConditionOrderByWithRelationInput | ConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conditions.
     */
    cursor?: ConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conditions.
     */
    distinct?: ConditionScalarFieldEnum | ConditionScalarFieldEnum[]
  }


  /**
   * Condition findFirstOrThrow
   */
  export type ConditionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionInclude<ExtArgs> | null
    /**
     * Filter, which Condition to fetch.
     */
    where?: ConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditions to fetch.
     */
    orderBy?: ConditionOrderByWithRelationInput | ConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conditions.
     */
    cursor?: ConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conditions.
     */
    distinct?: ConditionScalarFieldEnum | ConditionScalarFieldEnum[]
  }


  /**
   * Condition findMany
   */
  export type ConditionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionInclude<ExtArgs> | null
    /**
     * Filter, which Conditions to fetch.
     */
    where?: ConditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conditions to fetch.
     */
    orderBy?: ConditionOrderByWithRelationInput | ConditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conditions.
     */
    cursor?: ConditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conditions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conditions.
     */
    skip?: number
    distinct?: ConditionScalarFieldEnum | ConditionScalarFieldEnum[]
  }


  /**
   * Condition create
   */
  export type ConditionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionInclude<ExtArgs> | null
    /**
     * The data needed to create a Condition.
     */
    data: XOR<ConditionCreateInput, ConditionUncheckedCreateInput>
  }


  /**
   * Condition createMany
   */
  export type ConditionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conditions.
     */
    data: ConditionCreateManyInput | ConditionCreateManyInput[]
  }


  /**
   * Condition update
   */
  export type ConditionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionInclude<ExtArgs> | null
    /**
     * The data needed to update a Condition.
     */
    data: XOR<ConditionUpdateInput, ConditionUncheckedUpdateInput>
    /**
     * Choose, which Condition to update.
     */
    where: ConditionWhereUniqueInput
  }


  /**
   * Condition updateMany
   */
  export type ConditionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conditions.
     */
    data: XOR<ConditionUpdateManyMutationInput, ConditionUncheckedUpdateManyInput>
    /**
     * Filter which Conditions to update
     */
    where?: ConditionWhereInput
  }


  /**
   * Condition upsert
   */
  export type ConditionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionInclude<ExtArgs> | null
    /**
     * The filter to search for the Condition to update in case it exists.
     */
    where: ConditionWhereUniqueInput
    /**
     * In case the Condition found by the `where` argument doesn't exist, create a new Condition with this data.
     */
    create: XOR<ConditionCreateInput, ConditionUncheckedCreateInput>
    /**
     * In case the Condition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConditionUpdateInput, ConditionUncheckedUpdateInput>
  }


  /**
   * Condition delete
   */
  export type ConditionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionInclude<ExtArgs> | null
    /**
     * Filter which Condition to delete.
     */
    where: ConditionWhereUniqueInput
  }


  /**
   * Condition deleteMany
   */
  export type ConditionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conditions to delete
     */
    where?: ConditionWhereInput
  }


  /**
   * Condition findRaw
   */
  export type ConditionFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Condition aggregateRaw
   */
  export type ConditionAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Condition.listings
   */
  export type Condition$listingsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Listing
     */
    select?: ListingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ListingInclude<ExtArgs> | null
    where?: ListingWhereInput
    orderBy?: ListingOrderByWithRelationInput | ListingOrderByWithRelationInput[]
    cursor?: ListingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ListingScalarFieldEnum | ListingScalarFieldEnum[]
  }


  /**
   * Condition without action
   */
  export type ConditionDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Condition
     */
    select?: ConditionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConditionInclude<ExtArgs> | null
  }



  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    user1Id: string | null
    user2Id: string | null
    listingId: string | null
    createdAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    user1Id: string | null
    user2Id: string | null
    listingId: string | null
    createdAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    user1Id: number
    user2Id: number
    listingId: number
    createdAt: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    user1Id?: true
    user2Id?: true
    listingId?: true
    createdAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    user1Id?: true
    user2Id?: true
    listingId?: true
    createdAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    user1Id?: true
    user2Id?: true
    listingId?: true
    createdAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    user1Id: string
    user2Id: string
    listingId: string
    createdAt: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user1Id?: boolean
    user2Id?: boolean
    listingId?: boolean
    createdAt?: boolean
    user1?: boolean | UserDefaultArgs<ExtArgs>
    user2?: boolean | UserDefaultArgs<ExtArgs>
    listing?: boolean | ListingDefaultArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    Sale?: boolean | Conversation$SaleArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    user1Id?: boolean
    user2Id?: boolean
    listingId?: boolean
    createdAt?: boolean
  }

  export type ConversationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    user1?: boolean | UserDefaultArgs<ExtArgs>
    user2?: boolean | UserDefaultArgs<ExtArgs>
    listing?: boolean | ListingDefaultArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    Sale?: boolean | Conversation$SaleArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ConversationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      user1: Prisma.$UserPayload<ExtArgs>
      user2: Prisma.$UserPayload<ExtArgs>
      listing: Prisma.$ListingPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
      Sale: Prisma.$SalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      user1Id: string
      user2Id: string
      listingId: string
      createdAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }


  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ConversationFindManyArgs, 'select' | 'include'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ConversationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Conversation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ConversationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ConversationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
    **/
    create<T extends ConversationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Conversations.
     *     @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     *     @example
     *     // Create many Conversations
     *     const conversation = await prisma.conversation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ConversationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
    **/
    delete<T extends ConversationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ConversationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ConversationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ConversationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
    **/
    upsert<T extends ConversationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>
    ): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Conversations that matches the filter.
     * @param {ConversationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const conversation = await prisma.conversation.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ConversationFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Conversation.
     * @param {ConversationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const conversation = await prisma.conversation.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ConversationAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user1<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user2<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    listing<T extends ListingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ListingDefaultArgs<ExtArgs>>): Prisma__ListingClient<$Result.GetResult<Prisma.$ListingPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findMany'> | Null>;

    Sale<T extends Conversation$SaleArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$SaleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Conversation model
   */ 
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly user1Id: FieldRef<"Conversation", 'String'>
    readonly user2Id: FieldRef<"Conversation", 'String'>
    readonly listingId: FieldRef<"Conversation", 'String'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }


  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }


  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }


  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }


  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
  }


  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
  }


  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }


  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }


  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
  }


  /**
   * Conversation findRaw
   */
  export type ConversationFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Conversation aggregateRaw
   */
  export type ConversationAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Conversation.Sale
   */
  export type Conversation$SaleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }


  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ConversationInclude<ExtArgs> | null
  }



  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    senderId: string | null
    conversationId: string | null
    imageFileId: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    senderId: string | null
    conversationId: string | null
    imageFileId: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    content: number
    senderId: number
    conversationId: number
    imageFileId: number
    read: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    content?: true
    senderId?: true
    conversationId?: true
    imageFileId?: true
    read?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    content?: true
    senderId?: true
    conversationId?: true
    imageFileId?: true
    read?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    content?: true
    senderId?: true
    conversationId?: true
    imageFileId?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    content: string | null
    senderId: string
    conversationId: string
    imageFileId: string | null
    read: boolean
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    senderId?: boolean
    conversationId?: boolean
    imageFileId?: boolean
    read?: boolean
    createdAt?: boolean
    sender?: boolean | UserDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    content?: boolean
    senderId?: boolean
    conversationId?: boolean
    imageFileId?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type MessageInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    sender?: boolean | UserDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }


  export type $MessagePayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>
      conversation: Prisma.$ConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      content: string | null
      senderId: string
      conversationId: string
      imageFileId: string | null
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }


  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<MessageFindManyArgs, 'select' | 'include'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MessageFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Message that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MessageFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MessageFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
    **/
    create<T extends MessageCreateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageCreateArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Messages.
     *     @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     *     @example
     *     // Create many Messages
     *     const message = await prisma.message.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MessageCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
    **/
    delete<T extends MessageDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MessageUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MessageDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MessageUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
    **/
    upsert<T extends MessageUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>
    ): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Messages that matches the filter.
     * @param {MessageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const message = await prisma.message.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: MessageFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Message.
     * @param {MessageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const message = await prisma.message.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: MessageAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Message model
   */ 
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly imageFileId: FieldRef<"Message", 'String'>
    readonly read: FieldRef<"Message", 'Boolean'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }


  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }


  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
  }


  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
  }


  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }


  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }


  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
  }


  /**
   * Message findRaw
   */
  export type MessageFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Message aggregateRaw
   */
  export type MessageAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: MessageInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    password: 'password',
    cityId: 'cityId',
    gender: 'gender',
    contactNumber: 'contactNumber',
    profilePicture: 'profilePicture',
    createdAt: 'createdAt',
    reportedListingCount: 'reportedListingCount'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    organizationname: 'organizationname',
    email: 'email',
    password: 'password',
    address: 'address',
    contactNumber: 'contactNumber',
    secRegistrationNumber: 'secRegistrationNumber',
    verificationStatus: 'verificationStatus',
    lifetimePoints: 'lifetimePoints',
    totalPoints: 'totalPoints',
    type: 'type',
    profilePicture: 'profilePicture',
    createdAt: 'createdAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    url: 'url',
    uploadedBy: 'uploadedBy',
    organizationId: 'organizationId',
    createdAt: 'createdAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const DropPointScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    openingTime: 'openingTime',
    closingTime: 'closingTime',
    description: 'description',
    managerId: 'managerId',
    password: 'password'
  };

  export type DropPointScalarFieldEnum = (typeof DropPointScalarFieldEnum)[keyof typeof DropPointScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const ManagerScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phoneNumber: 'phoneNumber',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ManagerScalarFieldEnum = (typeof ManagerScalarFieldEnum)[keyof typeof ManagerScalarFieldEnum]


  export const DonationScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    dropPointId: 'dropPointId',
    createdAt: 'createdAt',
    expectedDateOfArrival: 'expectedDateOfArrival',
    confirmedByName: 'confirmedByName',
    confirmedByEmail: 'confirmedByEmail',
    status: 'status',
    isSubmitted: 'isSubmitted',
    points: 'points'
  };

  export type DonationScalarFieldEnum = (typeof DonationScalarFieldEnum)[keyof typeof DonationScalarFieldEnum]


  export const FeedbackScalarFieldEnum: {
    id: 'id',
    content: 'content',
    rating: 'rating',
    createdAt: 'createdAt',
    organizationId: 'organizationId',
    dropPointId: 'dropPointId',
    donationId: 'donationId'
  };

  export type FeedbackScalarFieldEnum = (typeof FeedbackScalarFieldEnum)[keyof typeof FeedbackScalarFieldEnum]


  export const PeripheralScalarFieldEnum: {
    id: 'id',
    type: 'type',
    brand: 'brand',
    model: 'model',
    condition: 'condition',
    quantity: 'quantity',
    donationId: 'donationId'
  };

  export type PeripheralScalarFieldEnum = (typeof PeripheralScalarFieldEnum)[keyof typeof PeripheralScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const AdvertisementScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    cityId: 'cityId',
    title: 'title',
    pointsSpent: 'pointsSpent',
    link: 'link',
    imageUrl: 'imageUrl',
    isActive: 'isActive',
    startDate: 'startDate',
    expiryDate: 'expiryDate'
  };

  export type AdvertisementScalarFieldEnum = (typeof AdvertisementScalarFieldEnum)[keyof typeof AdvertisementScalarFieldEnum]


  export const AdInteractionScalarFieldEnum: {
    id: 'id',
    advertisementId: 'advertisementId',
    clickedAt: 'clickedAt'
  };

  export type AdInteractionScalarFieldEnum = (typeof AdInteractionScalarFieldEnum)[keyof typeof AdInteractionScalarFieldEnum]


  export const KeyValueStoreScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value'
  };

  export type KeyValueStoreScalarFieldEnum = (typeof KeyValueStoreScalarFieldEnum)[keyof typeof KeyValueStoreScalarFieldEnum]


  export const ListingScalarFieldEnum: {
    id: 'id',
    title: 'title',
    price: 'price',
    categoryId: 'categoryId',
    conditionId: 'conditionId',
    description: 'description',
    location: 'location',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    userId: 'userId',
    status: 'status'
  };

  export type ListingScalarFieldEnum = (typeof ListingScalarFieldEnum)[keyof typeof ListingScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    listingId: 'listingId',
    reportedById: 'reportedById',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const SavedListingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    listingId: 'listingId',
    createdAt: 'createdAt'
  };

  export type SavedListingScalarFieldEnum = (typeof SavedListingScalarFieldEnum)[keyof typeof SavedListingScalarFieldEnum]


  export const SaleScalarFieldEnum: {
    id: 'id',
    buyerId: 'buyerId',
    listingId: 'listingId',
    conversationId: 'conversationId',
    salePrice: 'salePrice',
    saleDate: 'saleDate'
  };

  export type SaleScalarFieldEnum = (typeof SaleScalarFieldEnum)[keyof typeof SaleScalarFieldEnum]


  export const RatingScalarFieldEnum: {
    id: 'id',
    value: 'value',
    comment: 'comment',
    saleId: 'saleId',
    raterId: 'raterId',
    rateeId: 'rateeId',
    createdAt: 'createdAt',
    type: 'type'
  };

  export type RatingScalarFieldEnum = (typeof RatingScalarFieldEnum)[keyof typeof RatingScalarFieldEnum]


  export const PhotoScalarFieldEnum: {
    id: 'id',
    imageUrl: 'imageUrl',
    listingId: 'listingId'
  };

  export type PhotoScalarFieldEnum = (typeof PhotoScalarFieldEnum)[keyof typeof PhotoScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ConditionScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ConditionScalarFieldEnum = (typeof ConditionScalarFieldEnum)[keyof typeof ConditionScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    user1Id: 'user1Id',
    user2Id: 'user2Id',
    listingId: 'listingId',
    createdAt: 'createdAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    senderId: 'senderId',
    conversationId: 'conversationId',
    imageFileId: 'imageFileId',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter | string
    email?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    password?: StringFilter | string
    cityId?: StringFilter | string
    gender?: StringFilter | string
    contactNumber?: StringFilter | string
    profilePicture?: BytesNullableFilter | Buffer | null
    createdAt?: DateTimeFilter | Date | string
    reportedListingCount?: IntFilter | number
    city?: XOR<CityRelationFilter, CityWhereInput>
    listings?: ListingListRelationFilter
    purchases?: SaleListRelationFilter
    conversationsInitiated?: ConversationListRelationFilter
    conversationsReceived?: ConversationListRelationFilter
    sentMessages?: MessageListRelationFilter
    givenRatings?: RatingListRelationFilter
    receivedRatings?: RatingListRelationFilter
    savedListings?: SavedListingListRelationFilter
    reportsMade?: ReportListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    cityId?: SortOrder
    gender?: SortOrder
    contactNumber?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    reportedListingCount?: SortOrder
    city?: CityOrderByWithRelationInput
    listings?: ListingOrderByRelationAggregateInput
    purchases?: SaleOrderByRelationAggregateInput
    conversationsInitiated?: ConversationOrderByRelationAggregateInput
    conversationsReceived?: ConversationOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    givenRatings?: RatingOrderByRelationAggregateInput
    receivedRatings?: RatingOrderByRelationAggregateInput
    savedListings?: SavedListingOrderByRelationAggregateInput
    reportsMade?: ReportOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    cityId?: SortOrder
    gender?: SortOrder
    contactNumber?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    reportedListingCount?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    cityId?: StringWithAggregatesFilter | string
    gender?: StringWithAggregatesFilter | string
    contactNumber?: StringWithAggregatesFilter | string
    profilePicture?: BytesNullableWithAggregatesFilter | Buffer | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    reportedListingCount?: IntWithAggregatesFilter | number
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter | string
    organizationname?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    address?: StringFilter | string
    contactNumber?: StringFilter | string
    secRegistrationNumber?: StringNullableFilter | string | null
    verificationStatus?: StringFilter | string
    lifetimePoints?: FloatFilter | number
    totalPoints?: FloatFilter | number
    type?: StringFilter | string
    profilePicture?: BytesNullableFilter | Buffer | null
    createdAt?: DateTimeFilter | Date | string
    submittedDocuments?: DocumentListRelationFilter
    donations?: DonationListRelationFilter
    advertisements?: AdvertisementListRelationFilter
    feedbacksGiven?: FeedbackListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    organizationname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    contactNumber?: SortOrder
    secRegistrationNumber?: SortOrder
    verificationStatus?: SortOrder
    lifetimePoints?: SortOrder
    totalPoints?: SortOrder
    type?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    submittedDocuments?: DocumentOrderByRelationAggregateInput
    donations?: DonationOrderByRelationAggregateInput
    advertisements?: AdvertisementOrderByRelationAggregateInput
    feedbacksGiven?: FeedbackOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = {
    id?: string
    organizationname?: string
    email?: string
    contactNumber?: string
    secRegistrationNumber?: string
  }

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    organizationname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    contactNumber?: SortOrder
    secRegistrationNumber?: SortOrder
    verificationStatus?: SortOrder
    lifetimePoints?: SortOrder
    totalPoints?: SortOrder
    type?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _avg?: OrganizationAvgOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
    _sum?: OrganizationSumOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    organizationname?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
    contactNumber?: StringWithAggregatesFilter | string
    secRegistrationNumber?: StringNullableWithAggregatesFilter | string | null
    verificationStatus?: StringWithAggregatesFilter | string
    lifetimePoints?: FloatWithAggregatesFilter | number
    totalPoints?: FloatWithAggregatesFilter | number
    type?: StringWithAggregatesFilter | string
    profilePicture?: BytesNullableWithAggregatesFilter | Buffer | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter | string
    filename?: StringFilter | string
    url?: StringFilter | string
    uploadedBy?: StringFilter | string
    organizationId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput> | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = {
    id?: string
  }

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    filename?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
    uploadedBy?: StringWithAggregatesFilter | string
    organizationId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DropPointWhereInput = {
    AND?: DropPointWhereInput | DropPointWhereInput[]
    OR?: DropPointWhereInput[]
    NOT?: DropPointWhereInput | DropPointWhereInput[]
    id?: StringFilter | string
    name?: StringFilter | string
    location?: StringFilter | string
    openingTime?: StringFilter | string
    closingTime?: StringFilter | string
    description?: StringFilter | string
    managerId?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
    manager?: XOR<ManagerRelationFilter, ManagerWhereInput> | null
    donations?: DonationListRelationFilter
    feedbacksGiven?: FeedbackListRelationFilter
  }

  export type DropPointOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    password?: SortOrder
    manager?: ManagerOrderByWithRelationInput
    donations?: DonationOrderByRelationAggregateInput
    feedbacksGiven?: FeedbackOrderByRelationAggregateInput
  }

  export type DropPointWhereUniqueInput = {
    id?: string
  }

  export type DropPointOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    password?: SortOrder
    _count?: DropPointCountOrderByAggregateInput
    _max?: DropPointMaxOrderByAggregateInput
    _min?: DropPointMinOrderByAggregateInput
  }

  export type DropPointScalarWhereWithAggregatesInput = {
    AND?: DropPointScalarWhereWithAggregatesInput | DropPointScalarWhereWithAggregatesInput[]
    OR?: DropPointScalarWhereWithAggregatesInput[]
    NOT?: DropPointScalarWhereWithAggregatesInput | DropPointScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    location?: StringWithAggregatesFilter | string
    openingTime?: StringWithAggregatesFilter | string
    closingTime?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    managerId?: StringNullableWithAggregatesFilter | string | null
    password?: StringNullableWithAggregatesFilter | string | null
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type AdminWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
  }

  export type ManagerWhereInput = {
    AND?: ManagerWhereInput | ManagerWhereInput[]
    OR?: ManagerWhereInput[]
    NOT?: ManagerWhereInput | ManagerWhereInput[]
    id?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    email?: StringFilter | string
    phoneNumber?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    dropPoint?: DropPointListRelationFilter
  }

  export type ManagerOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dropPoint?: DropPointOrderByRelationAggregateInput
  }

  export type ManagerWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type ManagerOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ManagerCountOrderByAggregateInput
    _max?: ManagerMaxOrderByAggregateInput
    _min?: ManagerMinOrderByAggregateInput
  }

  export type ManagerScalarWhereWithAggregatesInput = {
    AND?: ManagerScalarWhereWithAggregatesInput | ManagerScalarWhereWithAggregatesInput[]
    OR?: ManagerScalarWhereWithAggregatesInput[]
    NOT?: ManagerScalarWhereWithAggregatesInput | ManagerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    phoneNumber?: StringNullableWithAggregatesFilter | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DonationWhereInput = {
    AND?: DonationWhereInput | DonationWhereInput[]
    OR?: DonationWhereInput[]
    NOT?: DonationWhereInput | DonationWhereInput[]
    id?: StringFilter | string
    organizationId?: StringFilter | string
    dropPointId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    expectedDateOfArrival?: DateTimeNullableFilter | Date | string | null
    confirmedByName?: StringNullableFilter | string | null
    confirmedByEmail?: StringNullableFilter | string | null
    status?: StringNullableFilter | string | null
    isSubmitted?: BoolFilter | boolean
    points?: FloatNullableFilter | number | null
    feedback?: XOR<FeedbackRelationFilter, FeedbackWhereInput> | null
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    dropPoint?: XOR<DropPointRelationFilter, DropPointWhereInput>
    peripherals?: PeripheralListRelationFilter
  }

  export type DonationOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    dropPointId?: SortOrder
    createdAt?: SortOrder
    expectedDateOfArrival?: SortOrder
    confirmedByName?: SortOrder
    confirmedByEmail?: SortOrder
    status?: SortOrder
    isSubmitted?: SortOrder
    points?: SortOrder
    feedback?: FeedbackOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    dropPoint?: DropPointOrderByWithRelationInput
    peripherals?: PeripheralOrderByRelationAggregateInput
  }

  export type DonationWhereUniqueInput = {
    id?: string
  }

  export type DonationOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    dropPointId?: SortOrder
    createdAt?: SortOrder
    expectedDateOfArrival?: SortOrder
    confirmedByName?: SortOrder
    confirmedByEmail?: SortOrder
    status?: SortOrder
    isSubmitted?: SortOrder
    points?: SortOrder
    _count?: DonationCountOrderByAggregateInput
    _avg?: DonationAvgOrderByAggregateInput
    _max?: DonationMaxOrderByAggregateInput
    _min?: DonationMinOrderByAggregateInput
    _sum?: DonationSumOrderByAggregateInput
  }

  export type DonationScalarWhereWithAggregatesInput = {
    AND?: DonationScalarWhereWithAggregatesInput | DonationScalarWhereWithAggregatesInput[]
    OR?: DonationScalarWhereWithAggregatesInput[]
    NOT?: DonationScalarWhereWithAggregatesInput | DonationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    organizationId?: StringWithAggregatesFilter | string
    dropPointId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    expectedDateOfArrival?: DateTimeNullableWithAggregatesFilter | Date | string | null
    confirmedByName?: StringNullableWithAggregatesFilter | string | null
    confirmedByEmail?: StringNullableWithAggregatesFilter | string | null
    status?: StringNullableWithAggregatesFilter | string | null
    isSubmitted?: BoolWithAggregatesFilter | boolean
    points?: FloatNullableWithAggregatesFilter | number | null
  }

  export type FeedbackWhereInput = {
    AND?: FeedbackWhereInput | FeedbackWhereInput[]
    OR?: FeedbackWhereInput[]
    NOT?: FeedbackWhereInput | FeedbackWhereInput[]
    id?: StringFilter | string
    content?: StringFilter | string
    rating?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    organizationId?: StringFilter | string
    dropPointId?: StringFilter | string
    donationId?: StringFilter | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    dropPoint?: XOR<DropPointRelationFilter, DropPointWhereInput>
    donation?: XOR<DonationRelationFilter, DonationWhereInput>
  }

  export type FeedbackOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    organizationId?: SortOrder
    dropPointId?: SortOrder
    donationId?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    dropPoint?: DropPointOrderByWithRelationInput
    donation?: DonationOrderByWithRelationInput
  }

  export type FeedbackWhereUniqueInput = {
    id?: string
    donationId?: string
  }

  export type FeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    organizationId?: SortOrder
    dropPointId?: SortOrder
    donationId?: SortOrder
    _count?: FeedbackCountOrderByAggregateInput
    _avg?: FeedbackAvgOrderByAggregateInput
    _max?: FeedbackMaxOrderByAggregateInput
    _min?: FeedbackMinOrderByAggregateInput
    _sum?: FeedbackSumOrderByAggregateInput
  }

  export type FeedbackScalarWhereWithAggregatesInput = {
    AND?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    OR?: FeedbackScalarWhereWithAggregatesInput[]
    NOT?: FeedbackScalarWhereWithAggregatesInput | FeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    rating?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    organizationId?: StringWithAggregatesFilter | string
    dropPointId?: StringWithAggregatesFilter | string
    donationId?: StringWithAggregatesFilter | string
  }

  export type PeripheralWhereInput = {
    AND?: PeripheralWhereInput | PeripheralWhereInput[]
    OR?: PeripheralWhereInput[]
    NOT?: PeripheralWhereInput | PeripheralWhereInput[]
    id?: StringFilter | string
    type?: StringFilter | string
    brand?: StringFilter | string
    model?: StringFilter | string
    condition?: StringFilter | string
    quantity?: IntFilter | number
    donationId?: StringFilter | string
    donation?: XOR<DonationRelationFilter, DonationWhereInput>
  }

  export type PeripheralOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    condition?: SortOrder
    quantity?: SortOrder
    donationId?: SortOrder
    donation?: DonationOrderByWithRelationInput
  }

  export type PeripheralWhereUniqueInput = {
    id?: string
  }

  export type PeripheralOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    condition?: SortOrder
    quantity?: SortOrder
    donationId?: SortOrder
    _count?: PeripheralCountOrderByAggregateInput
    _avg?: PeripheralAvgOrderByAggregateInput
    _max?: PeripheralMaxOrderByAggregateInput
    _min?: PeripheralMinOrderByAggregateInput
    _sum?: PeripheralSumOrderByAggregateInput
  }

  export type PeripheralScalarWhereWithAggregatesInput = {
    AND?: PeripheralScalarWhereWithAggregatesInput | PeripheralScalarWhereWithAggregatesInput[]
    OR?: PeripheralScalarWhereWithAggregatesInput[]
    NOT?: PeripheralScalarWhereWithAggregatesInput | PeripheralScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    brand?: StringWithAggregatesFilter | string
    model?: StringWithAggregatesFilter | string
    condition?: StringWithAggregatesFilter | string
    quantity?: IntWithAggregatesFilter | number
    donationId?: StringWithAggregatesFilter | string
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: StringFilter | string
    name?: StringFilter | string
    users?: UserListRelationFilter
    advertisements?: AdvertisementListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    users?: UserOrderByRelationAggregateInput
    advertisements?: AdvertisementOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type AdvertisementWhereInput = {
    AND?: AdvertisementWhereInput | AdvertisementWhereInput[]
    OR?: AdvertisementWhereInput[]
    NOT?: AdvertisementWhereInput | AdvertisementWhereInput[]
    id?: StringFilter | string
    organizationId?: StringFilter | string
    cityId?: StringFilter | string
    title?: StringFilter | string
    pointsSpent?: FloatFilter | number
    link?: StringFilter | string
    imageUrl?: BytesFilter | Buffer
    isActive?: BoolFilter | boolean
    startDate?: DateTimeFilter | Date | string
    expiryDate?: DateTimeFilter | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    city?: XOR<CityRelationFilter, CityWhereInput>
    interactions?: AdInteractionListRelationFilter
  }

  export type AdvertisementOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    cityId?: SortOrder
    title?: SortOrder
    pointsSpent?: SortOrder
    link?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
    interactions?: AdInteractionOrderByRelationAggregateInput
  }

  export type AdvertisementWhereUniqueInput = {
    id?: string
  }

  export type AdvertisementOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    cityId?: SortOrder
    title?: SortOrder
    pointsSpent?: SortOrder
    link?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    _count?: AdvertisementCountOrderByAggregateInput
    _avg?: AdvertisementAvgOrderByAggregateInput
    _max?: AdvertisementMaxOrderByAggregateInput
    _min?: AdvertisementMinOrderByAggregateInput
    _sum?: AdvertisementSumOrderByAggregateInput
  }

  export type AdvertisementScalarWhereWithAggregatesInput = {
    AND?: AdvertisementScalarWhereWithAggregatesInput | AdvertisementScalarWhereWithAggregatesInput[]
    OR?: AdvertisementScalarWhereWithAggregatesInput[]
    NOT?: AdvertisementScalarWhereWithAggregatesInput | AdvertisementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    organizationId?: StringWithAggregatesFilter | string
    cityId?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    pointsSpent?: FloatWithAggregatesFilter | number
    link?: StringWithAggregatesFilter | string
    imageUrl?: BytesWithAggregatesFilter | Buffer
    isActive?: BoolWithAggregatesFilter | boolean
    startDate?: DateTimeWithAggregatesFilter | Date | string
    expiryDate?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AdInteractionWhereInput = {
    AND?: AdInteractionWhereInput | AdInteractionWhereInput[]
    OR?: AdInteractionWhereInput[]
    NOT?: AdInteractionWhereInput | AdInteractionWhereInput[]
    id?: StringFilter | string
    advertisementId?: StringFilter | string
    clickedAt?: DateTimeFilter | Date | string
    advertisement?: XOR<AdvertisementRelationFilter, AdvertisementWhereInput>
  }

  export type AdInteractionOrderByWithRelationInput = {
    id?: SortOrder
    advertisementId?: SortOrder
    clickedAt?: SortOrder
    advertisement?: AdvertisementOrderByWithRelationInput
  }

  export type AdInteractionWhereUniqueInput = {
    id?: string
  }

  export type AdInteractionOrderByWithAggregationInput = {
    id?: SortOrder
    advertisementId?: SortOrder
    clickedAt?: SortOrder
    _count?: AdInteractionCountOrderByAggregateInput
    _max?: AdInteractionMaxOrderByAggregateInput
    _min?: AdInteractionMinOrderByAggregateInput
  }

  export type AdInteractionScalarWhereWithAggregatesInput = {
    AND?: AdInteractionScalarWhereWithAggregatesInput | AdInteractionScalarWhereWithAggregatesInput[]
    OR?: AdInteractionScalarWhereWithAggregatesInput[]
    NOT?: AdInteractionScalarWhereWithAggregatesInput | AdInteractionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    advertisementId?: StringWithAggregatesFilter | string
    clickedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type KeyValueStoreWhereInput = {
    AND?: KeyValueStoreWhereInput | KeyValueStoreWhereInput[]
    OR?: KeyValueStoreWhereInput[]
    NOT?: KeyValueStoreWhereInput | KeyValueStoreWhereInput[]
    id?: StringFilter | string
    key?: StringFilter | string
    value?: StringFilter | string
  }

  export type KeyValueStoreOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type KeyValueStoreWhereUniqueInput = {
    id?: string
    key?: string
  }

  export type KeyValueStoreOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    _count?: KeyValueStoreCountOrderByAggregateInput
    _max?: KeyValueStoreMaxOrderByAggregateInput
    _min?: KeyValueStoreMinOrderByAggregateInput
  }

  export type KeyValueStoreScalarWhereWithAggregatesInput = {
    AND?: KeyValueStoreScalarWhereWithAggregatesInput | KeyValueStoreScalarWhereWithAggregatesInput[]
    OR?: KeyValueStoreScalarWhereWithAggregatesInput[]
    NOT?: KeyValueStoreScalarWhereWithAggregatesInput | KeyValueStoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    key?: StringWithAggregatesFilter | string
    value?: StringWithAggregatesFilter | string
  }

  export type ListingWhereInput = {
    AND?: ListingWhereInput | ListingWhereInput[]
    OR?: ListingWhereInput[]
    NOT?: ListingWhereInput | ListingWhereInput[]
    id?: StringFilter | string
    title?: StringFilter | string
    price?: FloatFilter | number
    categoryId?: StringFilter | string
    conditionId?: StringFilter | string
    description?: StringFilter | string
    location?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
    status?: StringFilter | string
    photos?: PhotoListRelationFilter
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    condition?: XOR<ConditionRelationFilter, ConditionWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    sales?: SaleListRelationFilter
    conversations?: ConversationListRelationFilter
    savedByUsers?: SavedListingListRelationFilter
    reports?: ReportListRelationFilter
  }

  export type ListingOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    conditionId?: SortOrder
    description?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    photos?: PhotoOrderByRelationAggregateInput
    category?: CategoryOrderByWithRelationInput
    condition?: ConditionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    sales?: SaleOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
    savedByUsers?: SavedListingOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
  }

  export type ListingWhereUniqueInput = {
    id?: string
  }

  export type ListingOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    conditionId?: SortOrder
    description?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    _count?: ListingCountOrderByAggregateInput
    _avg?: ListingAvgOrderByAggregateInput
    _max?: ListingMaxOrderByAggregateInput
    _min?: ListingMinOrderByAggregateInput
    _sum?: ListingSumOrderByAggregateInput
  }

  export type ListingScalarWhereWithAggregatesInput = {
    AND?: ListingScalarWhereWithAggregatesInput | ListingScalarWhereWithAggregatesInput[]
    OR?: ListingScalarWhereWithAggregatesInput[]
    NOT?: ListingScalarWhereWithAggregatesInput | ListingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    price?: FloatWithAggregatesFilter | number
    categoryId?: StringWithAggregatesFilter | string
    conditionId?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    location?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    userId?: StringWithAggregatesFilter | string
    status?: StringWithAggregatesFilter | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter | string
    listingId?: StringFilter | string
    reportedById?: StringFilter | string
    reason?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    listing?: XOR<ListingRelationFilter, ListingWhereInput>
    reportedBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    listingId?: SortOrder
    reportedById?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    listing?: ListingOrderByWithRelationInput
    reportedBy?: UserOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = {
    id?: string
  }

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    listingId?: SortOrder
    reportedById?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    listingId?: StringWithAggregatesFilter | string
    reportedById?: StringWithAggregatesFilter | string
    reason?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SavedListingWhereInput = {
    AND?: SavedListingWhereInput | SavedListingWhereInput[]
    OR?: SavedListingWhereInput[]
    NOT?: SavedListingWhereInput | SavedListingWhereInput[]
    id?: StringFilter | string
    userId?: StringFilter | string
    listingId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    listing?: XOR<ListingRelationFilter, ListingWhereInput>
  }

  export type SavedListingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    listingId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    listing?: ListingOrderByWithRelationInput
  }

  export type SavedListingWhereUniqueInput = {
    id?: string
    userId_listingId?: SavedListingUserIdListingIdCompoundUniqueInput
  }

  export type SavedListingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    listingId?: SortOrder
    createdAt?: SortOrder
    _count?: SavedListingCountOrderByAggregateInput
    _max?: SavedListingMaxOrderByAggregateInput
    _min?: SavedListingMinOrderByAggregateInput
  }

  export type SavedListingScalarWhereWithAggregatesInput = {
    AND?: SavedListingScalarWhereWithAggregatesInput | SavedListingScalarWhereWithAggregatesInput[]
    OR?: SavedListingScalarWhereWithAggregatesInput[]
    NOT?: SavedListingScalarWhereWithAggregatesInput | SavedListingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    userId?: StringWithAggregatesFilter | string
    listingId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type SaleWhereInput = {
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    id?: StringFilter | string
    buyerId?: StringFilter | string
    listingId?: StringFilter | string
    conversationId?: StringNullableFilter | string | null
    salePrice?: FloatFilter | number
    saleDate?: DateTimeFilter | Date | string
    buyer?: XOR<UserRelationFilter, UserWhereInput>
    listing?: XOR<ListingRelationFilter, ListingWhereInput>
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput> | null
    rating?: RatingListRelationFilter
  }

  export type SaleOrderByWithRelationInput = {
    id?: SortOrder
    buyerId?: SortOrder
    listingId?: SortOrder
    conversationId?: SortOrder
    salePrice?: SortOrder
    saleDate?: SortOrder
    buyer?: UserOrderByWithRelationInput
    listing?: ListingOrderByWithRelationInput
    conversation?: ConversationOrderByWithRelationInput
    rating?: RatingOrderByRelationAggregateInput
  }

  export type SaleWhereUniqueInput = {
    id?: string
  }

  export type SaleOrderByWithAggregationInput = {
    id?: SortOrder
    buyerId?: SortOrder
    listingId?: SortOrder
    conversationId?: SortOrder
    salePrice?: SortOrder
    saleDate?: SortOrder
    _count?: SaleCountOrderByAggregateInput
    _avg?: SaleAvgOrderByAggregateInput
    _max?: SaleMaxOrderByAggregateInput
    _min?: SaleMinOrderByAggregateInput
    _sum?: SaleSumOrderByAggregateInput
  }

  export type SaleScalarWhereWithAggregatesInput = {
    AND?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    OR?: SaleScalarWhereWithAggregatesInput[]
    NOT?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    buyerId?: StringWithAggregatesFilter | string
    listingId?: StringWithAggregatesFilter | string
    conversationId?: StringNullableWithAggregatesFilter | string | null
    salePrice?: FloatWithAggregatesFilter | number
    saleDate?: DateTimeWithAggregatesFilter | Date | string
  }

  export type RatingWhereInput = {
    AND?: RatingWhereInput | RatingWhereInput[]
    OR?: RatingWhereInput[]
    NOT?: RatingWhereInput | RatingWhereInput[]
    id?: StringFilter | string
    value?: IntFilter | number
    comment?: StringNullableFilter | string | null
    saleId?: StringFilter | string
    raterId?: StringFilter | string
    rateeId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    type?: StringFilter | string
    sale?: XOR<SaleRelationFilter, SaleWhereInput>
    rater?: XOR<UserRelationFilter, UserWhereInput>
    ratee?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RatingOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    comment?: SortOrder
    saleId?: SortOrder
    raterId?: SortOrder
    rateeId?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    sale?: SaleOrderByWithRelationInput
    rater?: UserOrderByWithRelationInput
    ratee?: UserOrderByWithRelationInput
  }

  export type RatingWhereUniqueInput = {
    id?: string
  }

  export type RatingOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    comment?: SortOrder
    saleId?: SortOrder
    raterId?: SortOrder
    rateeId?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
    _count?: RatingCountOrderByAggregateInput
    _avg?: RatingAvgOrderByAggregateInput
    _max?: RatingMaxOrderByAggregateInput
    _min?: RatingMinOrderByAggregateInput
    _sum?: RatingSumOrderByAggregateInput
  }

  export type RatingScalarWhereWithAggregatesInput = {
    AND?: RatingScalarWhereWithAggregatesInput | RatingScalarWhereWithAggregatesInput[]
    OR?: RatingScalarWhereWithAggregatesInput[]
    NOT?: RatingScalarWhereWithAggregatesInput | RatingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    value?: IntWithAggregatesFilter | number
    comment?: StringNullableWithAggregatesFilter | string | null
    saleId?: StringWithAggregatesFilter | string
    raterId?: StringWithAggregatesFilter | string
    rateeId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    type?: StringWithAggregatesFilter | string
  }

  export type PhotoWhereInput = {
    AND?: PhotoWhereInput | PhotoWhereInput[]
    OR?: PhotoWhereInput[]
    NOT?: PhotoWhereInput | PhotoWhereInput[]
    id?: StringFilter | string
    imageUrl?: BytesFilter | Buffer
    listingId?: StringFilter | string
    listing?: XOR<ListingRelationFilter, ListingWhereInput>
  }

  export type PhotoOrderByWithRelationInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    listingId?: SortOrder
    listing?: ListingOrderByWithRelationInput
  }

  export type PhotoWhereUniqueInput = {
    id?: string
  }

  export type PhotoOrderByWithAggregationInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    listingId?: SortOrder
    _count?: PhotoCountOrderByAggregateInput
    _max?: PhotoMaxOrderByAggregateInput
    _min?: PhotoMinOrderByAggregateInput
  }

  export type PhotoScalarWhereWithAggregatesInput = {
    AND?: PhotoScalarWhereWithAggregatesInput | PhotoScalarWhereWithAggregatesInput[]
    OR?: PhotoScalarWhereWithAggregatesInput[]
    NOT?: PhotoScalarWhereWithAggregatesInput | PhotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    imageUrl?: BytesWithAggregatesFilter | Buffer
    listingId?: StringWithAggregatesFilter | string
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: StringFilter | string
    name?: StringFilter | string
    listings?: ListingListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    listings?: ListingOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type ConditionWhereInput = {
    AND?: ConditionWhereInput | ConditionWhereInput[]
    OR?: ConditionWhereInput[]
    NOT?: ConditionWhereInput | ConditionWhereInput[]
    id?: StringFilter | string
    name?: StringFilter | string
    listings?: ListingListRelationFilter
  }

  export type ConditionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    listings?: ListingOrderByRelationAggregateInput
  }

  export type ConditionWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type ConditionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ConditionCountOrderByAggregateInput
    _max?: ConditionMaxOrderByAggregateInput
    _min?: ConditionMinOrderByAggregateInput
  }

  export type ConditionScalarWhereWithAggregatesInput = {
    AND?: ConditionScalarWhereWithAggregatesInput | ConditionScalarWhereWithAggregatesInput[]
    OR?: ConditionScalarWhereWithAggregatesInput[]
    NOT?: ConditionScalarWhereWithAggregatesInput | ConditionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter | string
    user1Id?: StringFilter | string
    user2Id?: StringFilter | string
    listingId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    user1?: XOR<UserRelationFilter, UserWhereInput>
    user2?: XOR<UserRelationFilter, UserWhereInput>
    listing?: XOR<ListingRelationFilter, ListingWhereInput>
    messages?: MessageListRelationFilter
    Sale?: SaleListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    listingId?: SortOrder
    createdAt?: SortOrder
    user1?: UserOrderByWithRelationInput
    user2?: UserOrderByWithRelationInput
    listing?: ListingOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
    Sale?: SaleOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = {
    id?: string
  }

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    listingId?: SortOrder
    createdAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    user1Id?: StringWithAggregatesFilter | string
    user2Id?: StringWithAggregatesFilter | string
    listingId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter | string
    content?: StringNullableFilter | string | null
    senderId?: StringFilter | string
    conversationId?: StringFilter | string
    imageFileId?: StringNullableFilter | string | null
    read?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
    sender?: XOR<UserRelationFilter, UserWhereInput>
    conversation?: XOR<ConversationRelationFilter, ConversationWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    conversationId?: SortOrder
    imageFileId?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    sender?: UserOrderByWithRelationInput
    conversation?: ConversationOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = {
    id?: string
  }

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    conversationId?: SortOrder
    imageFileId?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    content?: StringNullableWithAggregatesFilter | string | null
    senderId?: StringWithAggregatesFilter | string
    conversationId?: StringWithAggregatesFilter | string
    imageFileId?: StringNullableWithAggregatesFilter | string | null
    read?: BoolWithAggregatesFilter | boolean
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    city: CityCreateNestedOneWithoutUsersInput
    listings?: ListingCreateNestedManyWithoutUserInput
    purchases?: SaleCreateNestedManyWithoutBuyerInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutUser1Input
    conversationsReceived?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    givenRatings?: RatingCreateNestedManyWithoutRaterInput
    receivedRatings?: RatingCreateNestedManyWithoutRateeInput
    savedListings?: SavedListingCreateNestedManyWithoutUserInput
    reportsMade?: ReportCreateNestedManyWithoutReportedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    cityId: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    listings?: ListingUncheckedCreateNestedManyWithoutUserInput
    purchases?: SaleUncheckedCreateNestedManyWithoutBuyerInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    givenRatings?: RatingUncheckedCreateNestedManyWithoutRaterInput
    receivedRatings?: RatingUncheckedCreateNestedManyWithoutRateeInput
    savedListings?: SavedListingUncheckedCreateNestedManyWithoutUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReportedByInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    city?: CityUpdateOneRequiredWithoutUsersNestedInput
    listings?: ListingUpdateManyWithoutUserNestedInput
    purchases?: SaleUpdateManyWithoutBuyerNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsReceived?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    givenRatings?: RatingUpdateManyWithoutRaterNestedInput
    receivedRatings?: RatingUpdateManyWithoutRateeNestedInput
    savedListings?: SavedListingUpdateManyWithoutUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReportedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    listings?: ListingUncheckedUpdateManyWithoutUserNestedInput
    purchases?: SaleUncheckedUpdateManyWithoutBuyerNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    givenRatings?: RatingUncheckedUpdateManyWithoutRaterNestedInput
    receivedRatings?: RatingUncheckedUpdateManyWithoutRateeNestedInput
    savedListings?: SavedListingUncheckedUpdateManyWithoutUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReportedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    cityId: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
  }

  export type UserUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
  }

  export type OrganizationCreateInput = {
    id?: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber?: string | null
    verificationStatus?: string
    lifetimePoints?: number
    totalPoints?: number
    type: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    submittedDocuments?: DocumentCreateNestedManyWithoutOrganizationInput
    donations?: DonationCreateNestedManyWithoutOrganizationInput
    advertisements?: AdvertisementCreateNestedManyWithoutOrganizationInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber?: string | null
    verificationStatus?: string
    lifetimePoints?: number
    totalPoints?: number
    type: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    submittedDocuments?: DocumentUncheckedCreateNestedManyWithoutOrganizationInput
    donations?: DonationUncheckedCreateNestedManyWithoutOrganizationInput
    advertisements?: AdvertisementUncheckedCreateNestedManyWithoutOrganizationInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    lifetimePoints?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedDocuments?: DocumentUpdateManyWithoutOrganizationNestedInput
    donations?: DonationUpdateManyWithoutOrganizationNestedInput
    advertisements?: AdvertisementUpdateManyWithoutOrganizationNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    lifetimePoints?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedDocuments?: DocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    donations?: DonationUncheckedUpdateManyWithoutOrganizationNestedInput
    advertisements?: AdvertisementUncheckedUpdateManyWithoutOrganizationNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber?: string | null
    verificationStatus?: string
    lifetimePoints?: number
    totalPoints?: number
    type: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    lifetimePoints?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    lifetimePoints?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    filename: string
    url: string
    uploadedBy: string
    createdAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutSubmittedDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    filename: string
    url: string
    uploadedBy: string
    organizationId?: string | null
    createdAt?: Date | string
  }

  export type DocumentUpdateInput = {
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutSubmittedDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    filename: string
    url: string
    uploadedBy: string
    organizationId?: string | null
    createdAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropPointCreateInput = {
    id?: string
    name: string
    location: string
    openingTime: string
    closingTime: string
    description: string
    password?: string | null
    manager?: ManagerCreateNestedOneWithoutDropPointInput
    donations?: DonationCreateNestedManyWithoutDropPointInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutDropPointInput
  }

  export type DropPointUncheckedCreateInput = {
    id?: string
    name: string
    location: string
    openingTime: string
    closingTime: string
    description: string
    managerId?: string | null
    password?: string | null
    donations?: DonationUncheckedCreateNestedManyWithoutDropPointInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutDropPointInput
  }

  export type DropPointUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    openingTime?: StringFieldUpdateOperationsInput | string
    closingTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: ManagerUpdateOneWithoutDropPointNestedInput
    donations?: DonationUpdateManyWithoutDropPointNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutDropPointNestedInput
  }

  export type DropPointUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    openingTime?: StringFieldUpdateOperationsInput | string
    closingTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    donations?: DonationUncheckedUpdateManyWithoutDropPointNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutDropPointNestedInput
  }

  export type DropPointCreateManyInput = {
    id?: string
    name: string
    location: string
    openingTime: string
    closingTime: string
    description: string
    managerId?: string | null
    password?: string | null
  }

  export type DropPointUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    openingTime?: StringFieldUpdateOperationsInput | string
    closingTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DropPointUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    openingTime?: StringFieldUpdateOperationsInput | string
    closingTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AdminCreateInput = {
    id?: string
    email: string
    password: string
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    email: string
    password: string
  }

  export type AdminUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type AdminCreateManyInput = {
    id?: string
    email: string
    password: string
  }

  export type AdminUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
  }

  export type ManagerCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phoneNumber?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropPoint?: DropPointCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phoneNumber?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropPoint?: DropPointUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropPoint?: DropPointUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropPoint?: DropPointUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type ManagerCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phoneNumber?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManagerUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerUncheckedUpdateManyInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationCreateInput = {
    id?: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
    feedback?: FeedbackCreateNestedOneWithoutDonationInput
    organization: OrganizationCreateNestedOneWithoutDonationsInput
    dropPoint: DropPointCreateNestedOneWithoutDonationsInput
    peripherals?: PeripheralCreateNestedManyWithoutDonationInput
  }

  export type DonationUncheckedCreateInput = {
    id?: string
    organizationId: string
    dropPointId: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
    feedback?: FeedbackUncheckedCreateNestedOneWithoutDonationInput
    peripherals?: PeripheralUncheckedCreateNestedManyWithoutDonationInput
  }

  export type DonationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: FeedbackUpdateOneWithoutDonationNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutDonationsNestedInput
    dropPoint?: DropPointUpdateOneRequiredWithoutDonationsNestedInput
    peripherals?: PeripheralUpdateManyWithoutDonationNestedInput
  }

  export type DonationUncheckedUpdateInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    dropPointId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: FeedbackUncheckedUpdateOneWithoutDonationNestedInput
    peripherals?: PeripheralUncheckedUpdateManyWithoutDonationNestedInput
  }

  export type DonationCreateManyInput = {
    id?: string
    organizationId: string
    dropPointId: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
  }

  export type DonationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DonationUncheckedUpdateManyInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    dropPointId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type FeedbackCreateInput = {
    id?: string
    content: string
    rating: number
    createdAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutFeedbacksGivenInput
    dropPoint: DropPointCreateNestedOneWithoutFeedbacksGivenInput
    donation: DonationCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateInput = {
    id?: string
    content: string
    rating: number
    createdAt?: Date | string
    organizationId: string
    dropPointId: string
    donationId: string
  }

  export type FeedbackUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutFeedbacksGivenNestedInput
    dropPoint?: DropPointUpdateOneRequiredWithoutFeedbacksGivenNestedInput
    donation?: DonationUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    dropPointId?: StringFieldUpdateOperationsInput | string
    donationId?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackCreateManyInput = {
    id?: string
    content: string
    rating: number
    createdAt?: Date | string
    organizationId: string
    dropPointId: string
    donationId: string
  }

  export type FeedbackUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUncheckedUpdateManyInput = {
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    dropPointId?: StringFieldUpdateOperationsInput | string
    donationId?: StringFieldUpdateOperationsInput | string
  }

  export type PeripheralCreateInput = {
    id?: string
    type: string
    brand: string
    model: string
    condition: string
    quantity?: number
    donation: DonationCreateNestedOneWithoutPeripheralsInput
  }

  export type PeripheralUncheckedCreateInput = {
    id?: string
    type: string
    brand: string
    model: string
    condition: string
    quantity?: number
    donationId: string
  }

  export type PeripheralUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    donation?: DonationUpdateOneRequiredWithoutPeripheralsNestedInput
  }

  export type PeripheralUncheckedUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    donationId?: StringFieldUpdateOperationsInput | string
  }

  export type PeripheralCreateManyInput = {
    id?: string
    type: string
    brand: string
    model: string
    condition: string
    quantity?: number
    donationId: string
  }

  export type PeripheralUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type PeripheralUncheckedUpdateManyInput = {
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    donationId?: StringFieldUpdateOperationsInput | string
  }

  export type CityCreateInput = {
    id?: string
    name: string
    users?: UserCreateNestedManyWithoutCityInput
    advertisements?: AdvertisementCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: string
    name: string
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    advertisements?: AdvertisementUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutCityNestedInput
    advertisements?: AdvertisementUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    advertisements?: AdvertisementUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id?: string
    name: string
  }

  export type CityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CityUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AdvertisementCreateInput = {
    id?: string
    title: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate?: Date | string
    expiryDate: Date | string
    organization: OrganizationCreateNestedOneWithoutAdvertisementsInput
    city: CityCreateNestedOneWithoutAdvertisementsInput
    interactions?: AdInteractionCreateNestedManyWithoutAdvertisementInput
  }

  export type AdvertisementUncheckedCreateInput = {
    id?: string
    organizationId: string
    cityId: string
    title: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate?: Date | string
    expiryDate: Date | string
    interactions?: AdInteractionUncheckedCreateNestedManyWithoutAdvertisementInput
  }

  export type AdvertisementUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAdvertisementsNestedInput
    city?: CityUpdateOneRequiredWithoutAdvertisementsNestedInput
    interactions?: AdInteractionUpdateManyWithoutAdvertisementNestedInput
  }

  export type AdvertisementUncheckedUpdateInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: AdInteractionUncheckedUpdateManyWithoutAdvertisementNestedInput
  }

  export type AdvertisementCreateManyInput = {
    id?: string
    organizationId: string
    cityId: string
    title: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate?: Date | string
    expiryDate: Date | string
  }

  export type AdvertisementUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisementUncheckedUpdateManyInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdInteractionCreateInput = {
    id?: string
    clickedAt?: Date | string
    advertisement: AdvertisementCreateNestedOneWithoutInteractionsInput
  }

  export type AdInteractionUncheckedCreateInput = {
    id?: string
    advertisementId: string
    clickedAt?: Date | string
  }

  export type AdInteractionUpdateInput = {
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    advertisement?: AdvertisementUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type AdInteractionUncheckedUpdateInput = {
    advertisementId?: StringFieldUpdateOperationsInput | string
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdInteractionCreateManyInput = {
    id?: string
    advertisementId: string
    clickedAt?: Date | string
  }

  export type AdInteractionUpdateManyMutationInput = {
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdInteractionUncheckedUpdateManyInput = {
    advertisementId?: StringFieldUpdateOperationsInput | string
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KeyValueStoreCreateInput = {
    id?: string
    key: string
    value: string
  }

  export type KeyValueStoreUncheckedCreateInput = {
    id?: string
    key: string
    value: string
  }

  export type KeyValueStoreUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type KeyValueStoreUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type KeyValueStoreCreateManyInput = {
    id?: string
    key: string
    value: string
  }

  export type KeyValueStoreUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type KeyValueStoreUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
  }

  export type ListingCreateInput = {
    id?: string
    title: string
    price: number
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    photos?: PhotoCreateNestedManyWithoutListingInput
    category: CategoryCreateNestedOneWithoutListingsInput
    condition: ConditionCreateNestedOneWithoutListingsInput
    user: UserCreateNestedOneWithoutListingsInput
    sales?: SaleCreateNestedManyWithoutListingInput
    conversations?: ConversationCreateNestedManyWithoutListingInput
    savedByUsers?: SavedListingCreateNestedManyWithoutListingInput
    reports?: ReportCreateNestedManyWithoutListingInput
  }

  export type ListingUncheckedCreateInput = {
    id?: string
    title: string
    price: number
    categoryId: string
    conditionId: string
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    status?: string
    photos?: PhotoUncheckedCreateNestedManyWithoutListingInput
    sales?: SaleUncheckedCreateNestedManyWithoutListingInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutListingInput
    savedByUsers?: SavedListingUncheckedCreateNestedManyWithoutListingInput
    reports?: ReportUncheckedCreateNestedManyWithoutListingInput
  }

  export type ListingUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUpdateManyWithoutListingNestedInput
    category?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    condition?: ConditionUpdateOneRequiredWithoutListingsNestedInput
    user?: UserUpdateOneRequiredWithoutListingsNestedInput
    sales?: SaleUpdateManyWithoutListingNestedInput
    conversations?: ConversationUpdateManyWithoutListingNestedInput
    savedByUsers?: SavedListingUpdateManyWithoutListingNestedInput
    reports?: ReportUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    conditionId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUncheckedUpdateManyWithoutListingNestedInput
    sales?: SaleUncheckedUpdateManyWithoutListingNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutListingNestedInput
    savedByUsers?: SavedListingUncheckedUpdateManyWithoutListingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutListingNestedInput
  }

  export type ListingCreateManyInput = {
    id?: string
    title: string
    price: number
    categoryId: string
    conditionId: string
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    status?: string
  }

  export type ListingUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ListingUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    conditionId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type ReportCreateInput = {
    id?: string
    reason: string
    createdAt?: Date | string
    listing: ListingCreateNestedOneWithoutReportsInput
    reportedBy: UserCreateNestedOneWithoutReportsMadeInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    listingId: string
    reportedById: string
    reason: string
    createdAt?: Date | string
  }

  export type ReportUpdateInput = {
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: ListingUpdateOneRequiredWithoutReportsNestedInput
    reportedBy?: UserUpdateOneRequiredWithoutReportsMadeNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    listingId?: StringFieldUpdateOperationsInput | string
    reportedById?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyInput = {
    id?: string
    listingId: string
    reportedById: string
    reason: string
    createdAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    listingId?: StringFieldUpdateOperationsInput | string
    reportedById?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedListingCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSavedListingsInput
    listing: ListingCreateNestedOneWithoutSavedByUsersInput
  }

  export type SavedListingUncheckedCreateInput = {
    id?: string
    userId: string
    listingId: string
    createdAt?: Date | string
  }

  export type SavedListingUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSavedListingsNestedInput
    listing?: ListingUpdateOneRequiredWithoutSavedByUsersNestedInput
  }

  export type SavedListingUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedListingCreateManyInput = {
    id?: string
    userId: string
    listingId: string
    createdAt?: Date | string
  }

  export type SavedListingUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedListingUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateInput = {
    id?: string
    salePrice: number
    saleDate?: Date | string
    buyer: UserCreateNestedOneWithoutPurchasesInput
    listing: ListingCreateNestedOneWithoutSalesInput
    conversation?: ConversationCreateNestedOneWithoutSaleInput
    rating?: RatingCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateInput = {
    id?: string
    buyerId: string
    listingId: string
    conversationId?: string | null
    salePrice: number
    saleDate?: Date | string
    rating?: RatingUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleUpdateInput = {
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    buyer?: UserUpdateOneRequiredWithoutPurchasesNestedInput
    listing?: ListingUpdateOneRequiredWithoutSalesNestedInput
    conversation?: ConversationUpdateOneWithoutSaleNestedInput
    rating?: RatingUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: RatingUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleCreateManyInput = {
    id?: string
    buyerId: string
    listingId: string
    conversationId?: string | null
    salePrice: number
    saleDate?: Date | string
  }

  export type SaleUpdateManyMutationInput = {
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUncheckedUpdateManyInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingCreateInput = {
    id?: string
    value: number
    comment?: string | null
    createdAt?: Date | string
    type: string
    sale: SaleCreateNestedOneWithoutRatingInput
    rater: UserCreateNestedOneWithoutGivenRatingsInput
    ratee: UserCreateNestedOneWithoutReceivedRatingsInput
  }

  export type RatingUncheckedCreateInput = {
    id?: string
    value: number
    comment?: string | null
    saleId: string
    raterId: string
    rateeId: string
    createdAt?: Date | string
    type: string
  }

  export type RatingUpdateInput = {
    value?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    sale?: SaleUpdateOneRequiredWithoutRatingNestedInput
    rater?: UserUpdateOneRequiredWithoutGivenRatingsNestedInput
    ratee?: UserUpdateOneRequiredWithoutReceivedRatingsNestedInput
  }

  export type RatingUncheckedUpdateInput = {
    value?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    saleId?: StringFieldUpdateOperationsInput | string
    raterId?: StringFieldUpdateOperationsInput | string
    rateeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type RatingCreateManyInput = {
    id?: string
    value: number
    comment?: string | null
    saleId: string
    raterId: string
    rateeId: string
    createdAt?: Date | string
    type: string
  }

  export type RatingUpdateManyMutationInput = {
    value?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type RatingUncheckedUpdateManyInput = {
    value?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    saleId?: StringFieldUpdateOperationsInput | string
    raterId?: StringFieldUpdateOperationsInput | string
    rateeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type PhotoCreateInput = {
    id?: string
    imageUrl: Buffer
    listing: ListingCreateNestedOneWithoutPhotosInput
  }

  export type PhotoUncheckedCreateInput = {
    id?: string
    imageUrl: Buffer
    listingId: string
  }

  export type PhotoUpdateInput = {
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    listing?: ListingUpdateOneRequiredWithoutPhotosNestedInput
  }

  export type PhotoUncheckedUpdateInput = {
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    listingId?: StringFieldUpdateOperationsInput | string
  }

  export type PhotoCreateManyInput = {
    id?: string
    imageUrl: Buffer
    listingId: string
  }

  export type PhotoUpdateManyMutationInput = {
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type PhotoUncheckedUpdateManyInput = {
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    listingId?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryCreateInput = {
    id?: string
    name: string
    listings?: ListingCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: string
    name: string
    listings?: ListingUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    listings?: ListingUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    listings?: ListingUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: string
    name: string
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ConditionCreateInput = {
    id?: string
    name: string
    listings?: ListingCreateNestedManyWithoutConditionInput
  }

  export type ConditionUncheckedCreateInput = {
    id?: string
    name: string
    listings?: ListingUncheckedCreateNestedManyWithoutConditionInput
  }

  export type ConditionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    listings?: ListingUpdateManyWithoutConditionNestedInput
  }

  export type ConditionUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    listings?: ListingUncheckedUpdateManyWithoutConditionNestedInput
  }

  export type ConditionCreateManyInput = {
    id?: string
    name: string
  }

  export type ConditionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ConditionUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationCreateInput = {
    id?: string
    createdAt?: Date | string
    user1: UserCreateNestedOneWithoutConversationsInitiatedInput
    user2: UserCreateNestedOneWithoutConversationsReceivedInput
    listing: ListingCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    Sale?: SaleCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    user1Id: string
    user2Id: string
    listingId: string
    createdAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    Sale?: SaleUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user1?: UserUpdateOneRequiredWithoutConversationsInitiatedNestedInput
    user2?: UserUpdateOneRequiredWithoutConversationsReceivedNestedInput
    listing?: ListingUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    Sale?: SaleUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    Sale?: SaleUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    user1Id: string
    user2Id: string
    listingId: string
    createdAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content?: string | null
    imageFileId?: string | null
    read?: boolean
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    content?: string | null
    senderId: string
    conversationId: string
    imageFileId?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    content?: string | null
    senderId: string
    conversationId: string
    imageFileId?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: string[] | string
    notIn?: string[] | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type BytesNullableFilter = {
    equals?: Buffer | null
    in?: Buffer[] | Buffer | null
    notIn?: Buffer[] | Buffer | null
    not?: NestedBytesNullableFilter | Buffer | null
    isSet?: boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Date[] | string[] | Date | string
    notIn?: Date[] | string[] | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type IntFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type CityRelationFilter = {
    is?: CityWhereInput | null
    isNot?: CityWhereInput | null
  }

  export type ListingListRelationFilter = {
    every?: ListingWhereInput
    some?: ListingWhereInput
    none?: ListingWhereInput
  }

  export type SaleListRelationFilter = {
    every?: SaleWhereInput
    some?: SaleWhereInput
    none?: SaleWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type RatingListRelationFilter = {
    every?: RatingWhereInput
    some?: RatingWhereInput
    none?: RatingWhereInput
  }

  export type SavedListingListRelationFilter = {
    every?: SavedListingWhereInput
    some?: SavedListingWhereInput
    none?: SavedListingWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type ListingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SavedListingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    cityId?: SortOrder
    gender?: SortOrder
    contactNumber?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    reportedListingCount?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    reportedListingCount?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    cityId?: SortOrder
    gender?: SortOrder
    contactNumber?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    reportedListingCount?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    cityId?: SortOrder
    gender?: SortOrder
    contactNumber?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    reportedListingCount?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    reportedListingCount?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: string[] | string
    notIn?: string[] | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BytesNullableWithAggregatesFilter = {
    equals?: Buffer | null
    in?: Buffer[] | Buffer | null
    notIn?: Buffer[] | Buffer | null
    not?: NestedBytesNullableWithAggregatesFilter | Buffer | null
    _count?: NestedIntNullableFilter
    _min?: NestedBytesNullableFilter
    _max?: NestedBytesNullableFilter
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Date[] | string[] | Date | string
    notIn?: Date[] | string[] | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: string[] | string | null
    notIn?: string[] | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
    isSet?: boolean
  }

  export type FloatFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type DonationListRelationFilter = {
    every?: DonationWhereInput
    some?: DonationWhereInput
    none?: DonationWhereInput
  }

  export type AdvertisementListRelationFilter = {
    every?: AdvertisementWhereInput
    some?: AdvertisementWhereInput
    none?: AdvertisementWhereInput
  }

  export type FeedbackListRelationFilter = {
    every?: FeedbackWhereInput
    some?: FeedbackWhereInput
    none?: FeedbackWhereInput
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DonationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdvertisementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedbackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    organizationname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    contactNumber?: SortOrder
    secRegistrationNumber?: SortOrder
    verificationStatus?: SortOrder
    lifetimePoints?: SortOrder
    totalPoints?: SortOrder
    type?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
  }

  export type OrganizationAvgOrderByAggregateInput = {
    lifetimePoints?: SortOrder
    totalPoints?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    contactNumber?: SortOrder
    secRegistrationNumber?: SortOrder
    verificationStatus?: SortOrder
    lifetimePoints?: SortOrder
    totalPoints?: SortOrder
    type?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    organizationname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    contactNumber?: SortOrder
    secRegistrationNumber?: SortOrder
    verificationStatus?: SortOrder
    lifetimePoints?: SortOrder
    totalPoints?: SortOrder
    type?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
  }

  export type OrganizationSumOrderByAggregateInput = {
    lifetimePoints?: SortOrder
    totalPoints?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: string[] | string | null
    notIn?: string[] | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    isSet?: boolean
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type OrganizationRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
  }

  export type ManagerRelationFilter = {
    is?: ManagerWhereInput | null
    isNot?: ManagerWhereInput | null
  }

  export type DropPointCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    password?: SortOrder
  }

  export type DropPointMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    password?: SortOrder
  }

  export type DropPointMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    password?: SortOrder
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
  }

  export type DropPointListRelationFilter = {
    every?: DropPointWhereInput
    some?: DropPointWhereInput
    none?: DropPointWhereInput
  }

  export type DropPointOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ManagerCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ManagerMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | Date | string | null
    notIn?: Date[] | string[] | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
    isSet?: boolean
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: number[] | number | null
    notIn?: number[] | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
    isSet?: boolean
  }

  export type FeedbackRelationFilter = {
    is?: FeedbackWhereInput | null
    isNot?: FeedbackWhereInput | null
  }

  export type DropPointRelationFilter = {
    is?: DropPointWhereInput | null
    isNot?: DropPointWhereInput | null
  }

  export type PeripheralListRelationFilter = {
    every?: PeripheralWhereInput
    some?: PeripheralWhereInput
    none?: PeripheralWhereInput
  }

  export type PeripheralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DonationCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    dropPointId?: SortOrder
    createdAt?: SortOrder
    expectedDateOfArrival?: SortOrder
    confirmedByName?: SortOrder
    confirmedByEmail?: SortOrder
    status?: SortOrder
    isSubmitted?: SortOrder
    points?: SortOrder
  }

  export type DonationAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type DonationMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    dropPointId?: SortOrder
    createdAt?: SortOrder
    expectedDateOfArrival?: SortOrder
    confirmedByName?: SortOrder
    confirmedByEmail?: SortOrder
    status?: SortOrder
    isSubmitted?: SortOrder
    points?: SortOrder
  }

  export type DonationMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    dropPointId?: SortOrder
    createdAt?: SortOrder
    expectedDateOfArrival?: SortOrder
    confirmedByName?: SortOrder
    confirmedByEmail?: SortOrder
    status?: SortOrder
    isSubmitted?: SortOrder
    points?: SortOrder
  }

  export type DonationSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | Date | string | null
    notIn?: Date[] | string[] | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    isSet?: boolean
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: number[] | number | null
    notIn?: number[] | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
    isSet?: boolean
  }

  export type DonationRelationFilter = {
    is?: DonationWhereInput | null
    isNot?: DonationWhereInput | null
  }

  export type FeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    organizationId?: SortOrder
    dropPointId?: SortOrder
    donationId?: SortOrder
  }

  export type FeedbackAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type FeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    organizationId?: SortOrder
    dropPointId?: SortOrder
    donationId?: SortOrder
  }

  export type FeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    rating?: SortOrder
    createdAt?: SortOrder
    organizationId?: SortOrder
    dropPointId?: SortOrder
    donationId?: SortOrder
  }

  export type FeedbackSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type PeripheralCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    condition?: SortOrder
    quantity?: SortOrder
    donationId?: SortOrder
  }

  export type PeripheralAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type PeripheralMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    condition?: SortOrder
    quantity?: SortOrder
    donationId?: SortOrder
  }

  export type PeripheralMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    condition?: SortOrder
    quantity?: SortOrder
    donationId?: SortOrder
  }

  export type PeripheralSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type BytesFilter = {
    equals?: Buffer
    in?: Buffer[] | Buffer
    notIn?: Buffer[] | Buffer
    not?: NestedBytesFilter | Buffer
  }

  export type AdInteractionListRelationFilter = {
    every?: AdInteractionWhereInput
    some?: AdInteractionWhereInput
    none?: AdInteractionWhereInput
  }

  export type AdInteractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdvertisementCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    cityId?: SortOrder
    title?: SortOrder
    pointsSpent?: SortOrder
    link?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
  }

  export type AdvertisementAvgOrderByAggregateInput = {
    pointsSpent?: SortOrder
  }

  export type AdvertisementMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    cityId?: SortOrder
    title?: SortOrder
    pointsSpent?: SortOrder
    link?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
  }

  export type AdvertisementMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    cityId?: SortOrder
    title?: SortOrder
    pointsSpent?: SortOrder
    link?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
  }

  export type AdvertisementSumOrderByAggregateInput = {
    pointsSpent?: SortOrder
  }

  export type BytesWithAggregatesFilter = {
    equals?: Buffer
    in?: Buffer[] | Buffer
    notIn?: Buffer[] | Buffer
    not?: NestedBytesWithAggregatesFilter | Buffer
    _count?: NestedIntFilter
    _min?: NestedBytesFilter
    _max?: NestedBytesFilter
  }

  export type AdvertisementRelationFilter = {
    is?: AdvertisementWhereInput | null
    isNot?: AdvertisementWhereInput | null
  }

  export type AdInteractionCountOrderByAggregateInput = {
    id?: SortOrder
    advertisementId?: SortOrder
    clickedAt?: SortOrder
  }

  export type AdInteractionMaxOrderByAggregateInput = {
    id?: SortOrder
    advertisementId?: SortOrder
    clickedAt?: SortOrder
  }

  export type AdInteractionMinOrderByAggregateInput = {
    id?: SortOrder
    advertisementId?: SortOrder
    clickedAt?: SortOrder
  }

  export type KeyValueStoreCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type KeyValueStoreMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type KeyValueStoreMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
  }

  export type PhotoListRelationFilter = {
    every?: PhotoWhereInput
    some?: PhotoWhereInput
    none?: PhotoWhereInput
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type ConditionRelationFilter = {
    is?: ConditionWhereInput | null
    isNot?: ConditionWhereInput | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PhotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ListingCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    conditionId?: SortOrder
    description?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    status?: SortOrder
  }

  export type ListingAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ListingMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    conditionId?: SortOrder
    description?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    status?: SortOrder
  }

  export type ListingMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    price?: SortOrder
    categoryId?: SortOrder
    conditionId?: SortOrder
    description?: SortOrder
    location?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    userId?: SortOrder
    status?: SortOrder
  }

  export type ListingSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type ListingRelationFilter = {
    is?: ListingWhereInput | null
    isNot?: ListingWhereInput | null
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    reportedById?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    reportedById?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    listingId?: SortOrder
    reportedById?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type SavedListingUserIdListingIdCompoundUniqueInput = {
    userId: string
    listingId: string
  }

  export type SavedListingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    listingId?: SortOrder
    createdAt?: SortOrder
  }

  export type SavedListingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    listingId?: SortOrder
    createdAt?: SortOrder
  }

  export type SavedListingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    listingId?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationRelationFilter = {
    is?: ConversationWhereInput | null
    isNot?: ConversationWhereInput | null
  }

  export type SaleCountOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    listingId?: SortOrder
    conversationId?: SortOrder
    salePrice?: SortOrder
    saleDate?: SortOrder
  }

  export type SaleAvgOrderByAggregateInput = {
    salePrice?: SortOrder
  }

  export type SaleMaxOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    listingId?: SortOrder
    conversationId?: SortOrder
    salePrice?: SortOrder
    saleDate?: SortOrder
  }

  export type SaleMinOrderByAggregateInput = {
    id?: SortOrder
    buyerId?: SortOrder
    listingId?: SortOrder
    conversationId?: SortOrder
    salePrice?: SortOrder
    saleDate?: SortOrder
  }

  export type SaleSumOrderByAggregateInput = {
    salePrice?: SortOrder
  }

  export type SaleRelationFilter = {
    is?: SaleWhereInput | null
    isNot?: SaleWhereInput | null
  }

  export type RatingCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    comment?: SortOrder
    saleId?: SortOrder
    raterId?: SortOrder
    rateeId?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
  }

  export type RatingAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type RatingMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    comment?: SortOrder
    saleId?: SortOrder
    raterId?: SortOrder
    rateeId?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
  }

  export type RatingMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    comment?: SortOrder
    saleId?: SortOrder
    raterId?: SortOrder
    rateeId?: SortOrder
    createdAt?: SortOrder
    type?: SortOrder
  }

  export type RatingSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type PhotoCountOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    listingId?: SortOrder
  }

  export type PhotoMaxOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    listingId?: SortOrder
  }

  export type PhotoMinOrderByAggregateInput = {
    id?: SortOrder
    imageUrl?: SortOrder
    listingId?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ConditionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ConditionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ConditionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    listingId?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    listingId?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    user1Id?: SortOrder
    user2Id?: SortOrder
    listingId?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    conversationId?: SortOrder
    imageFileId?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    conversationId?: SortOrder
    imageFileId?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    conversationId?: SortOrder
    imageFileId?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type CityCreateNestedOneWithoutUsersInput = {
    create?: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CityCreateOrConnectWithoutUsersInput
    connect?: CityWhereUniqueInput
  }

  export type ListingCreateNestedManyWithoutUserInput = {
    create?: XOR<ListingCreateWithoutUserInput, ListingUncheckedCreateWithoutUserInput> | ListingCreateWithoutUserInput[] | ListingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutUserInput | ListingCreateOrConnectWithoutUserInput[]
    createMany?: ListingCreateManyUserInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type SaleCreateNestedManyWithoutBuyerInput = {
    create?: XOR<SaleCreateWithoutBuyerInput, SaleUncheckedCreateWithoutBuyerInput> | SaleCreateWithoutBuyerInput[] | SaleUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutBuyerInput | SaleCreateOrConnectWithoutBuyerInput[]
    createMany?: SaleCreateManyBuyerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutUser1Input = {
    create?: XOR<ConversationCreateWithoutUser1Input, ConversationUncheckedCreateWithoutUser1Input> | ConversationCreateWithoutUser1Input[] | ConversationUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUser1Input | ConversationCreateOrConnectWithoutUser1Input[]
    createMany?: ConversationCreateManyUser1InputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutUser2Input = {
    create?: XOR<ConversationCreateWithoutUser2Input, ConversationUncheckedCreateWithoutUser2Input> | ConversationCreateWithoutUser2Input[] | ConversationUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUser2Input | ConversationCreateOrConnectWithoutUser2Input[]
    createMany?: ConversationCreateManyUser2InputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type RatingCreateNestedManyWithoutRaterInput = {
    create?: XOR<RatingCreateWithoutRaterInput, RatingUncheckedCreateWithoutRaterInput> | RatingCreateWithoutRaterInput[] | RatingUncheckedCreateWithoutRaterInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutRaterInput | RatingCreateOrConnectWithoutRaterInput[]
    createMany?: RatingCreateManyRaterInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type RatingCreateNestedManyWithoutRateeInput = {
    create?: XOR<RatingCreateWithoutRateeInput, RatingUncheckedCreateWithoutRateeInput> | RatingCreateWithoutRateeInput[] | RatingUncheckedCreateWithoutRateeInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutRateeInput | RatingCreateOrConnectWithoutRateeInput[]
    createMany?: RatingCreateManyRateeInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type SavedListingCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedListingCreateWithoutUserInput, SavedListingUncheckedCreateWithoutUserInput> | SavedListingCreateWithoutUserInput[] | SavedListingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedListingCreateOrConnectWithoutUserInput | SavedListingCreateOrConnectWithoutUserInput[]
    createMany?: SavedListingCreateManyUserInputEnvelope
    connect?: SavedListingWhereUniqueInput | SavedListingWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutReportedByInput = {
    create?: XOR<ReportCreateWithoutReportedByInput, ReportUncheckedCreateWithoutReportedByInput> | ReportCreateWithoutReportedByInput[] | ReportUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedByInput | ReportCreateOrConnectWithoutReportedByInput[]
    createMany?: ReportCreateManyReportedByInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ListingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ListingCreateWithoutUserInput, ListingUncheckedCreateWithoutUserInput> | ListingCreateWithoutUserInput[] | ListingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutUserInput | ListingCreateOrConnectWithoutUserInput[]
    createMany?: ListingCreateManyUserInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutBuyerInput = {
    create?: XOR<SaleCreateWithoutBuyerInput, SaleUncheckedCreateWithoutBuyerInput> | SaleCreateWithoutBuyerInput[] | SaleUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutBuyerInput | SaleCreateOrConnectWithoutBuyerInput[]
    createMany?: SaleCreateManyBuyerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutUser1Input = {
    create?: XOR<ConversationCreateWithoutUser1Input, ConversationUncheckedCreateWithoutUser1Input> | ConversationCreateWithoutUser1Input[] | ConversationUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUser1Input | ConversationCreateOrConnectWithoutUser1Input[]
    createMany?: ConversationCreateManyUser1InputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutUser2Input = {
    create?: XOR<ConversationCreateWithoutUser2Input, ConversationUncheckedCreateWithoutUser2Input> | ConversationCreateWithoutUser2Input[] | ConversationUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUser2Input | ConversationCreateOrConnectWithoutUser2Input[]
    createMany?: ConversationCreateManyUser2InputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type RatingUncheckedCreateNestedManyWithoutRaterInput = {
    create?: XOR<RatingCreateWithoutRaterInput, RatingUncheckedCreateWithoutRaterInput> | RatingCreateWithoutRaterInput[] | RatingUncheckedCreateWithoutRaterInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutRaterInput | RatingCreateOrConnectWithoutRaterInput[]
    createMany?: RatingCreateManyRaterInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type RatingUncheckedCreateNestedManyWithoutRateeInput = {
    create?: XOR<RatingCreateWithoutRateeInput, RatingUncheckedCreateWithoutRateeInput> | RatingCreateWithoutRateeInput[] | RatingUncheckedCreateWithoutRateeInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutRateeInput | RatingCreateOrConnectWithoutRateeInput[]
    createMany?: RatingCreateManyRateeInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type SavedListingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedListingCreateWithoutUserInput, SavedListingUncheckedCreateWithoutUserInput> | SavedListingCreateWithoutUserInput[] | SavedListingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedListingCreateOrConnectWithoutUserInput | SavedListingCreateOrConnectWithoutUserInput[]
    createMany?: SavedListingCreateManyUserInputEnvelope
    connect?: SavedListingWhereUniqueInput | SavedListingWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutReportedByInput = {
    create?: XOR<ReportCreateWithoutReportedByInput, ReportUncheckedCreateWithoutReportedByInput> | ReportCreateWithoutReportedByInput[] | ReportUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedByInput | ReportCreateOrConnectWithoutReportedByInput[]
    createMany?: ReportCreateManyReportedByInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
    unset?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CityUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CityCreateOrConnectWithoutUsersInput
    upsert?: CityUpsertWithoutUsersInput
    connect?: CityWhereUniqueInput
    update?: XOR<CityUpdateWithoutUsersInput, CityUncheckedUpdateWithoutUsersInput>
  }

  export type ListingUpdateManyWithoutUserNestedInput = {
    create?: XOR<ListingCreateWithoutUserInput, ListingUncheckedCreateWithoutUserInput> | ListingCreateWithoutUserInput[] | ListingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutUserInput | ListingCreateOrConnectWithoutUserInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutUserInput | ListingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ListingCreateManyUserInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutUserInput | ListingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutUserInput | ListingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type SaleUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<SaleCreateWithoutBuyerInput, SaleUncheckedCreateWithoutBuyerInput> | SaleCreateWithoutBuyerInput[] | SaleUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutBuyerInput | SaleCreateOrConnectWithoutBuyerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutBuyerInput | SaleUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: SaleCreateManyBuyerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutBuyerInput | SaleUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutBuyerInput | SaleUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutUser1NestedInput = {
    create?: XOR<ConversationCreateWithoutUser1Input, ConversationUncheckedCreateWithoutUser1Input> | ConversationCreateWithoutUser1Input[] | ConversationUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUser1Input | ConversationCreateOrConnectWithoutUser1Input[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUser1Input | ConversationUpsertWithWhereUniqueWithoutUser1Input[]
    createMany?: ConversationCreateManyUser1InputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUser1Input | ConversationUpdateWithWhereUniqueWithoutUser1Input[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUser1Input | ConversationUpdateManyWithWhereWithoutUser1Input[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutUser2NestedInput = {
    create?: XOR<ConversationCreateWithoutUser2Input, ConversationUncheckedCreateWithoutUser2Input> | ConversationCreateWithoutUser2Input[] | ConversationUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUser2Input | ConversationCreateOrConnectWithoutUser2Input[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUser2Input | ConversationUpsertWithWhereUniqueWithoutUser2Input[]
    createMany?: ConversationCreateManyUser2InputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUser2Input | ConversationUpdateWithWhereUniqueWithoutUser2Input[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUser2Input | ConversationUpdateManyWithWhereWithoutUser2Input[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type RatingUpdateManyWithoutRaterNestedInput = {
    create?: XOR<RatingCreateWithoutRaterInput, RatingUncheckedCreateWithoutRaterInput> | RatingCreateWithoutRaterInput[] | RatingUncheckedCreateWithoutRaterInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutRaterInput | RatingCreateOrConnectWithoutRaterInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutRaterInput | RatingUpsertWithWhereUniqueWithoutRaterInput[]
    createMany?: RatingCreateManyRaterInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutRaterInput | RatingUpdateWithWhereUniqueWithoutRaterInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutRaterInput | RatingUpdateManyWithWhereWithoutRaterInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type RatingUpdateManyWithoutRateeNestedInput = {
    create?: XOR<RatingCreateWithoutRateeInput, RatingUncheckedCreateWithoutRateeInput> | RatingCreateWithoutRateeInput[] | RatingUncheckedCreateWithoutRateeInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutRateeInput | RatingCreateOrConnectWithoutRateeInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutRateeInput | RatingUpsertWithWhereUniqueWithoutRateeInput[]
    createMany?: RatingCreateManyRateeInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutRateeInput | RatingUpdateWithWhereUniqueWithoutRateeInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutRateeInput | RatingUpdateManyWithWhereWithoutRateeInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type SavedListingUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedListingCreateWithoutUserInput, SavedListingUncheckedCreateWithoutUserInput> | SavedListingCreateWithoutUserInput[] | SavedListingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedListingCreateOrConnectWithoutUserInput | SavedListingCreateOrConnectWithoutUserInput[]
    upsert?: SavedListingUpsertWithWhereUniqueWithoutUserInput | SavedListingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedListingCreateManyUserInputEnvelope
    set?: SavedListingWhereUniqueInput | SavedListingWhereUniqueInput[]
    disconnect?: SavedListingWhereUniqueInput | SavedListingWhereUniqueInput[]
    delete?: SavedListingWhereUniqueInput | SavedListingWhereUniqueInput[]
    connect?: SavedListingWhereUniqueInput | SavedListingWhereUniqueInput[]
    update?: SavedListingUpdateWithWhereUniqueWithoutUserInput | SavedListingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedListingUpdateManyWithWhereWithoutUserInput | SavedListingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedListingScalarWhereInput | SavedListingScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutReportedByNestedInput = {
    create?: XOR<ReportCreateWithoutReportedByInput, ReportUncheckedCreateWithoutReportedByInput> | ReportCreateWithoutReportedByInput[] | ReportUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedByInput | ReportCreateOrConnectWithoutReportedByInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedByInput | ReportUpsertWithWhereUniqueWithoutReportedByInput[]
    createMany?: ReportCreateManyReportedByInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedByInput | ReportUpdateWithWhereUniqueWithoutReportedByInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedByInput | ReportUpdateManyWithWhereWithoutReportedByInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ListingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ListingCreateWithoutUserInput, ListingUncheckedCreateWithoutUserInput> | ListingCreateWithoutUserInput[] | ListingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutUserInput | ListingCreateOrConnectWithoutUserInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutUserInput | ListingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ListingCreateManyUserInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutUserInput | ListingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutUserInput | ListingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutBuyerNestedInput = {
    create?: XOR<SaleCreateWithoutBuyerInput, SaleUncheckedCreateWithoutBuyerInput> | SaleCreateWithoutBuyerInput[] | SaleUncheckedCreateWithoutBuyerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutBuyerInput | SaleCreateOrConnectWithoutBuyerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutBuyerInput | SaleUpsertWithWhereUniqueWithoutBuyerInput[]
    createMany?: SaleCreateManyBuyerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutBuyerInput | SaleUpdateWithWhereUniqueWithoutBuyerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutBuyerInput | SaleUpdateManyWithWhereWithoutBuyerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutUser1NestedInput = {
    create?: XOR<ConversationCreateWithoutUser1Input, ConversationUncheckedCreateWithoutUser1Input> | ConversationCreateWithoutUser1Input[] | ConversationUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUser1Input | ConversationCreateOrConnectWithoutUser1Input[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUser1Input | ConversationUpsertWithWhereUniqueWithoutUser1Input[]
    createMany?: ConversationCreateManyUser1InputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUser1Input | ConversationUpdateWithWhereUniqueWithoutUser1Input[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUser1Input | ConversationUpdateManyWithWhereWithoutUser1Input[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutUser2NestedInput = {
    create?: XOR<ConversationCreateWithoutUser2Input, ConversationUncheckedCreateWithoutUser2Input> | ConversationCreateWithoutUser2Input[] | ConversationUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUser2Input | ConversationCreateOrConnectWithoutUser2Input[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUser2Input | ConversationUpsertWithWhereUniqueWithoutUser2Input[]
    createMany?: ConversationCreateManyUser2InputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUser2Input | ConversationUpdateWithWhereUniqueWithoutUser2Input[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUser2Input | ConversationUpdateManyWithWhereWithoutUser2Input[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type RatingUncheckedUpdateManyWithoutRaterNestedInput = {
    create?: XOR<RatingCreateWithoutRaterInput, RatingUncheckedCreateWithoutRaterInput> | RatingCreateWithoutRaterInput[] | RatingUncheckedCreateWithoutRaterInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutRaterInput | RatingCreateOrConnectWithoutRaterInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutRaterInput | RatingUpsertWithWhereUniqueWithoutRaterInput[]
    createMany?: RatingCreateManyRaterInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutRaterInput | RatingUpdateWithWhereUniqueWithoutRaterInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutRaterInput | RatingUpdateManyWithWhereWithoutRaterInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type RatingUncheckedUpdateManyWithoutRateeNestedInput = {
    create?: XOR<RatingCreateWithoutRateeInput, RatingUncheckedCreateWithoutRateeInput> | RatingCreateWithoutRateeInput[] | RatingUncheckedCreateWithoutRateeInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutRateeInput | RatingCreateOrConnectWithoutRateeInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutRateeInput | RatingUpsertWithWhereUniqueWithoutRateeInput[]
    createMany?: RatingCreateManyRateeInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutRateeInput | RatingUpdateWithWhereUniqueWithoutRateeInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutRateeInput | RatingUpdateManyWithWhereWithoutRateeInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type SavedListingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedListingCreateWithoutUserInput, SavedListingUncheckedCreateWithoutUserInput> | SavedListingCreateWithoutUserInput[] | SavedListingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedListingCreateOrConnectWithoutUserInput | SavedListingCreateOrConnectWithoutUserInput[]
    upsert?: SavedListingUpsertWithWhereUniqueWithoutUserInput | SavedListingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedListingCreateManyUserInputEnvelope
    set?: SavedListingWhereUniqueInput | SavedListingWhereUniqueInput[]
    disconnect?: SavedListingWhereUniqueInput | SavedListingWhereUniqueInput[]
    delete?: SavedListingWhereUniqueInput | SavedListingWhereUniqueInput[]
    connect?: SavedListingWhereUniqueInput | SavedListingWhereUniqueInput[]
    update?: SavedListingUpdateWithWhereUniqueWithoutUserInput | SavedListingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedListingUpdateManyWithWhereWithoutUserInput | SavedListingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedListingScalarWhereInput | SavedListingScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutReportedByNestedInput = {
    create?: XOR<ReportCreateWithoutReportedByInput, ReportUncheckedCreateWithoutReportedByInput> | ReportCreateWithoutReportedByInput[] | ReportUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutReportedByInput | ReportCreateOrConnectWithoutReportedByInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutReportedByInput | ReportUpsertWithWhereUniqueWithoutReportedByInput[]
    createMany?: ReportCreateManyReportedByInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutReportedByInput | ReportUpdateWithWhereUniqueWithoutReportedByInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutReportedByInput | ReportUpdateManyWithWhereWithoutReportedByInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type DocumentCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<DocumentCreateWithoutOrganizationInput, DocumentUncheckedCreateWithoutOrganizationInput> | DocumentCreateWithoutOrganizationInput[] | DocumentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOrganizationInput | DocumentCreateOrConnectWithoutOrganizationInput[]
    createMany?: DocumentCreateManyOrganizationInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DonationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<DonationCreateWithoutOrganizationInput, DonationUncheckedCreateWithoutOrganizationInput> | DonationCreateWithoutOrganizationInput[] | DonationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutOrganizationInput | DonationCreateOrConnectWithoutOrganizationInput[]
    createMany?: DonationCreateManyOrganizationInputEnvelope
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
  }

  export type AdvertisementCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<AdvertisementCreateWithoutOrganizationInput, AdvertisementUncheckedCreateWithoutOrganizationInput> | AdvertisementCreateWithoutOrganizationInput[] | AdvertisementUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AdvertisementCreateOrConnectWithoutOrganizationInput | AdvertisementCreateOrConnectWithoutOrganizationInput[]
    createMany?: AdvertisementCreateManyOrganizationInputEnvelope
    connect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<FeedbackCreateWithoutOrganizationInput, FeedbackUncheckedCreateWithoutOrganizationInput> | FeedbackCreateWithoutOrganizationInput[] | FeedbackUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutOrganizationInput | FeedbackCreateOrConnectWithoutOrganizationInput[]
    createMany?: FeedbackCreateManyOrganizationInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<DocumentCreateWithoutOrganizationInput, DocumentUncheckedCreateWithoutOrganizationInput> | DocumentCreateWithoutOrganizationInput[] | DocumentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOrganizationInput | DocumentCreateOrConnectWithoutOrganizationInput[]
    createMany?: DocumentCreateManyOrganizationInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DonationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<DonationCreateWithoutOrganizationInput, DonationUncheckedCreateWithoutOrganizationInput> | DonationCreateWithoutOrganizationInput[] | DonationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutOrganizationInput | DonationCreateOrConnectWithoutOrganizationInput[]
    createMany?: DonationCreateManyOrganizationInputEnvelope
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
  }

  export type AdvertisementUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<AdvertisementCreateWithoutOrganizationInput, AdvertisementUncheckedCreateWithoutOrganizationInput> | AdvertisementCreateWithoutOrganizationInput[] | AdvertisementUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AdvertisementCreateOrConnectWithoutOrganizationInput | AdvertisementCreateOrConnectWithoutOrganizationInput[]
    createMany?: AdvertisementCreateManyOrganizationInputEnvelope
    connect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<FeedbackCreateWithoutOrganizationInput, FeedbackUncheckedCreateWithoutOrganizationInput> | FeedbackCreateWithoutOrganizationInput[] | FeedbackUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutOrganizationInput | FeedbackCreateOrConnectWithoutOrganizationInput[]
    createMany?: FeedbackCreateManyOrganizationInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DocumentUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<DocumentCreateWithoutOrganizationInput, DocumentUncheckedCreateWithoutOrganizationInput> | DocumentCreateWithoutOrganizationInput[] | DocumentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOrganizationInput | DocumentCreateOrConnectWithoutOrganizationInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutOrganizationInput | DocumentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: DocumentCreateManyOrganizationInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutOrganizationInput | DocumentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutOrganizationInput | DocumentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DonationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<DonationCreateWithoutOrganizationInput, DonationUncheckedCreateWithoutOrganizationInput> | DonationCreateWithoutOrganizationInput[] | DonationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutOrganizationInput | DonationCreateOrConnectWithoutOrganizationInput[]
    upsert?: DonationUpsertWithWhereUniqueWithoutOrganizationInput | DonationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: DonationCreateManyOrganizationInputEnvelope
    set?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    disconnect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    delete?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    update?: DonationUpdateWithWhereUniqueWithoutOrganizationInput | DonationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: DonationUpdateManyWithWhereWithoutOrganizationInput | DonationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: DonationScalarWhereInput | DonationScalarWhereInput[]
  }

  export type AdvertisementUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<AdvertisementCreateWithoutOrganizationInput, AdvertisementUncheckedCreateWithoutOrganizationInput> | AdvertisementCreateWithoutOrganizationInput[] | AdvertisementUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AdvertisementCreateOrConnectWithoutOrganizationInput | AdvertisementCreateOrConnectWithoutOrganizationInput[]
    upsert?: AdvertisementUpsertWithWhereUniqueWithoutOrganizationInput | AdvertisementUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: AdvertisementCreateManyOrganizationInputEnvelope
    set?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    disconnect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    delete?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    connect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    update?: AdvertisementUpdateWithWhereUniqueWithoutOrganizationInput | AdvertisementUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: AdvertisementUpdateManyWithWhereWithoutOrganizationInput | AdvertisementUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: AdvertisementScalarWhereInput | AdvertisementScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<FeedbackCreateWithoutOrganizationInput, FeedbackUncheckedCreateWithoutOrganizationInput> | FeedbackCreateWithoutOrganizationInput[] | FeedbackUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutOrganizationInput | FeedbackCreateOrConnectWithoutOrganizationInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutOrganizationInput | FeedbackUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: FeedbackCreateManyOrganizationInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutOrganizationInput | FeedbackUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutOrganizationInput | FeedbackUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<DocumentCreateWithoutOrganizationInput, DocumentUncheckedCreateWithoutOrganizationInput> | DocumentCreateWithoutOrganizationInput[] | DocumentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOrganizationInput | DocumentCreateOrConnectWithoutOrganizationInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutOrganizationInput | DocumentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: DocumentCreateManyOrganizationInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutOrganizationInput | DocumentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutOrganizationInput | DocumentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DonationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<DonationCreateWithoutOrganizationInput, DonationUncheckedCreateWithoutOrganizationInput> | DonationCreateWithoutOrganizationInput[] | DonationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutOrganizationInput | DonationCreateOrConnectWithoutOrganizationInput[]
    upsert?: DonationUpsertWithWhereUniqueWithoutOrganizationInput | DonationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: DonationCreateManyOrganizationInputEnvelope
    set?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    disconnect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    delete?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    update?: DonationUpdateWithWhereUniqueWithoutOrganizationInput | DonationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: DonationUpdateManyWithWhereWithoutOrganizationInput | DonationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: DonationScalarWhereInput | DonationScalarWhereInput[]
  }

  export type AdvertisementUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<AdvertisementCreateWithoutOrganizationInput, AdvertisementUncheckedCreateWithoutOrganizationInput> | AdvertisementCreateWithoutOrganizationInput[] | AdvertisementUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AdvertisementCreateOrConnectWithoutOrganizationInput | AdvertisementCreateOrConnectWithoutOrganizationInput[]
    upsert?: AdvertisementUpsertWithWhereUniqueWithoutOrganizationInput | AdvertisementUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: AdvertisementCreateManyOrganizationInputEnvelope
    set?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    disconnect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    delete?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    connect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    update?: AdvertisementUpdateWithWhereUniqueWithoutOrganizationInput | AdvertisementUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: AdvertisementUpdateManyWithWhereWithoutOrganizationInput | AdvertisementUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: AdvertisementScalarWhereInput | AdvertisementScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<FeedbackCreateWithoutOrganizationInput, FeedbackUncheckedCreateWithoutOrganizationInput> | FeedbackCreateWithoutOrganizationInput[] | FeedbackUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutOrganizationInput | FeedbackCreateOrConnectWithoutOrganizationInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutOrganizationInput | FeedbackUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: FeedbackCreateManyOrganizationInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutOrganizationInput | FeedbackUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutOrganizationInput | FeedbackUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutSubmittedDocumentsInput = {
    create?: XOR<OrganizationCreateWithoutSubmittedDocumentsInput, OrganizationUncheckedCreateWithoutSubmittedDocumentsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubmittedDocumentsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneWithoutSubmittedDocumentsNestedInput = {
    create?: XOR<OrganizationCreateWithoutSubmittedDocumentsInput, OrganizationUncheckedCreateWithoutSubmittedDocumentsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubmittedDocumentsInput
    upsert?: OrganizationUpsertWithoutSubmittedDocumentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutSubmittedDocumentsInput, OrganizationUncheckedUpdateWithoutSubmittedDocumentsInput>
  }

  export type ManagerCreateNestedOneWithoutDropPointInput = {
    create?: XOR<ManagerCreateWithoutDropPointInput, ManagerUncheckedCreateWithoutDropPointInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutDropPointInput
    connect?: ManagerWhereUniqueInput
  }

  export type DonationCreateNestedManyWithoutDropPointInput = {
    create?: XOR<DonationCreateWithoutDropPointInput, DonationUncheckedCreateWithoutDropPointInput> | DonationCreateWithoutDropPointInput[] | DonationUncheckedCreateWithoutDropPointInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutDropPointInput | DonationCreateOrConnectWithoutDropPointInput[]
    createMany?: DonationCreateManyDropPointInputEnvelope
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
  }

  export type FeedbackCreateNestedManyWithoutDropPointInput = {
    create?: XOR<FeedbackCreateWithoutDropPointInput, FeedbackUncheckedCreateWithoutDropPointInput> | FeedbackCreateWithoutDropPointInput[] | FeedbackUncheckedCreateWithoutDropPointInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutDropPointInput | FeedbackCreateOrConnectWithoutDropPointInput[]
    createMany?: FeedbackCreateManyDropPointInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type DonationUncheckedCreateNestedManyWithoutDropPointInput = {
    create?: XOR<DonationCreateWithoutDropPointInput, DonationUncheckedCreateWithoutDropPointInput> | DonationCreateWithoutDropPointInput[] | DonationUncheckedCreateWithoutDropPointInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutDropPointInput | DonationCreateOrConnectWithoutDropPointInput[]
    createMany?: DonationCreateManyDropPointInputEnvelope
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedManyWithoutDropPointInput = {
    create?: XOR<FeedbackCreateWithoutDropPointInput, FeedbackUncheckedCreateWithoutDropPointInput> | FeedbackCreateWithoutDropPointInput[] | FeedbackUncheckedCreateWithoutDropPointInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutDropPointInput | FeedbackCreateOrConnectWithoutDropPointInput[]
    createMany?: FeedbackCreateManyDropPointInputEnvelope
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
  }

  export type ManagerUpdateOneWithoutDropPointNestedInput = {
    create?: XOR<ManagerCreateWithoutDropPointInput, ManagerUncheckedCreateWithoutDropPointInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutDropPointInput
    upsert?: ManagerUpsertWithoutDropPointInput
    disconnect?: boolean
    delete?: boolean
    connect?: ManagerWhereUniqueInput
    update?: XOR<ManagerUpdateWithoutDropPointInput, ManagerUncheckedUpdateWithoutDropPointInput>
  }

  export type DonationUpdateManyWithoutDropPointNestedInput = {
    create?: XOR<DonationCreateWithoutDropPointInput, DonationUncheckedCreateWithoutDropPointInput> | DonationCreateWithoutDropPointInput[] | DonationUncheckedCreateWithoutDropPointInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutDropPointInput | DonationCreateOrConnectWithoutDropPointInput[]
    upsert?: DonationUpsertWithWhereUniqueWithoutDropPointInput | DonationUpsertWithWhereUniqueWithoutDropPointInput[]
    createMany?: DonationCreateManyDropPointInputEnvelope
    set?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    disconnect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    delete?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    update?: DonationUpdateWithWhereUniqueWithoutDropPointInput | DonationUpdateWithWhereUniqueWithoutDropPointInput[]
    updateMany?: DonationUpdateManyWithWhereWithoutDropPointInput | DonationUpdateManyWithWhereWithoutDropPointInput[]
    deleteMany?: DonationScalarWhereInput | DonationScalarWhereInput[]
  }

  export type FeedbackUpdateManyWithoutDropPointNestedInput = {
    create?: XOR<FeedbackCreateWithoutDropPointInput, FeedbackUncheckedCreateWithoutDropPointInput> | FeedbackCreateWithoutDropPointInput[] | FeedbackUncheckedCreateWithoutDropPointInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutDropPointInput | FeedbackCreateOrConnectWithoutDropPointInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutDropPointInput | FeedbackUpsertWithWhereUniqueWithoutDropPointInput[]
    createMany?: FeedbackCreateManyDropPointInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutDropPointInput | FeedbackUpdateWithWhereUniqueWithoutDropPointInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutDropPointInput | FeedbackUpdateManyWithWhereWithoutDropPointInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type DonationUncheckedUpdateManyWithoutDropPointNestedInput = {
    create?: XOR<DonationCreateWithoutDropPointInput, DonationUncheckedCreateWithoutDropPointInput> | DonationCreateWithoutDropPointInput[] | DonationUncheckedCreateWithoutDropPointInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutDropPointInput | DonationCreateOrConnectWithoutDropPointInput[]
    upsert?: DonationUpsertWithWhereUniqueWithoutDropPointInput | DonationUpsertWithWhereUniqueWithoutDropPointInput[]
    createMany?: DonationCreateManyDropPointInputEnvelope
    set?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    disconnect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    delete?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    update?: DonationUpdateWithWhereUniqueWithoutDropPointInput | DonationUpdateWithWhereUniqueWithoutDropPointInput[]
    updateMany?: DonationUpdateManyWithWhereWithoutDropPointInput | DonationUpdateManyWithWhereWithoutDropPointInput[]
    deleteMany?: DonationScalarWhereInput | DonationScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateManyWithoutDropPointNestedInput = {
    create?: XOR<FeedbackCreateWithoutDropPointInput, FeedbackUncheckedCreateWithoutDropPointInput> | FeedbackCreateWithoutDropPointInput[] | FeedbackUncheckedCreateWithoutDropPointInput[]
    connectOrCreate?: FeedbackCreateOrConnectWithoutDropPointInput | FeedbackCreateOrConnectWithoutDropPointInput[]
    upsert?: FeedbackUpsertWithWhereUniqueWithoutDropPointInput | FeedbackUpsertWithWhereUniqueWithoutDropPointInput[]
    createMany?: FeedbackCreateManyDropPointInputEnvelope
    set?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    disconnect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    delete?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    connect?: FeedbackWhereUniqueInput | FeedbackWhereUniqueInput[]
    update?: FeedbackUpdateWithWhereUniqueWithoutDropPointInput | FeedbackUpdateWithWhereUniqueWithoutDropPointInput[]
    updateMany?: FeedbackUpdateManyWithWhereWithoutDropPointInput | FeedbackUpdateManyWithWhereWithoutDropPointInput[]
    deleteMany?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
  }

  export type DropPointCreateNestedManyWithoutManagerInput = {
    create?: XOR<DropPointCreateWithoutManagerInput, DropPointUncheckedCreateWithoutManagerInput> | DropPointCreateWithoutManagerInput[] | DropPointUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: DropPointCreateOrConnectWithoutManagerInput | DropPointCreateOrConnectWithoutManagerInput[]
    createMany?: DropPointCreateManyManagerInputEnvelope
    connect?: DropPointWhereUniqueInput | DropPointWhereUniqueInput[]
  }

  export type DropPointUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<DropPointCreateWithoutManagerInput, DropPointUncheckedCreateWithoutManagerInput> | DropPointCreateWithoutManagerInput[] | DropPointUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: DropPointCreateOrConnectWithoutManagerInput | DropPointCreateOrConnectWithoutManagerInput[]
    createMany?: DropPointCreateManyManagerInputEnvelope
    connect?: DropPointWhereUniqueInput | DropPointWhereUniqueInput[]
  }

  export type DropPointUpdateManyWithoutManagerNestedInput = {
    create?: XOR<DropPointCreateWithoutManagerInput, DropPointUncheckedCreateWithoutManagerInput> | DropPointCreateWithoutManagerInput[] | DropPointUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: DropPointCreateOrConnectWithoutManagerInput | DropPointCreateOrConnectWithoutManagerInput[]
    upsert?: DropPointUpsertWithWhereUniqueWithoutManagerInput | DropPointUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: DropPointCreateManyManagerInputEnvelope
    set?: DropPointWhereUniqueInput | DropPointWhereUniqueInput[]
    disconnect?: DropPointWhereUniqueInput | DropPointWhereUniqueInput[]
    delete?: DropPointWhereUniqueInput | DropPointWhereUniqueInput[]
    connect?: DropPointWhereUniqueInput | DropPointWhereUniqueInput[]
    update?: DropPointUpdateWithWhereUniqueWithoutManagerInput | DropPointUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: DropPointUpdateManyWithWhereWithoutManagerInput | DropPointUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: DropPointScalarWhereInput | DropPointScalarWhereInput[]
  }

  export type DropPointUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<DropPointCreateWithoutManagerInput, DropPointUncheckedCreateWithoutManagerInput> | DropPointCreateWithoutManagerInput[] | DropPointUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: DropPointCreateOrConnectWithoutManagerInput | DropPointCreateOrConnectWithoutManagerInput[]
    upsert?: DropPointUpsertWithWhereUniqueWithoutManagerInput | DropPointUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: DropPointCreateManyManagerInputEnvelope
    set?: DropPointWhereUniqueInput | DropPointWhereUniqueInput[]
    disconnect?: DropPointWhereUniqueInput | DropPointWhereUniqueInput[]
    delete?: DropPointWhereUniqueInput | DropPointWhereUniqueInput[]
    connect?: DropPointWhereUniqueInput | DropPointWhereUniqueInput[]
    update?: DropPointUpdateWithWhereUniqueWithoutManagerInput | DropPointUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: DropPointUpdateManyWithWhereWithoutManagerInput | DropPointUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: DropPointScalarWhereInput | DropPointScalarWhereInput[]
  }

  export type FeedbackCreateNestedOneWithoutDonationInput = {
    create?: XOR<FeedbackCreateWithoutDonationInput, FeedbackUncheckedCreateWithoutDonationInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutDonationInput
    connect?: FeedbackWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutDonationsInput = {
    create?: XOR<OrganizationCreateWithoutDonationsInput, OrganizationUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutDonationsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type DropPointCreateNestedOneWithoutDonationsInput = {
    create?: XOR<DropPointCreateWithoutDonationsInput, DropPointUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: DropPointCreateOrConnectWithoutDonationsInput
    connect?: DropPointWhereUniqueInput
  }

  export type PeripheralCreateNestedManyWithoutDonationInput = {
    create?: XOR<PeripheralCreateWithoutDonationInput, PeripheralUncheckedCreateWithoutDonationInput> | PeripheralCreateWithoutDonationInput[] | PeripheralUncheckedCreateWithoutDonationInput[]
    connectOrCreate?: PeripheralCreateOrConnectWithoutDonationInput | PeripheralCreateOrConnectWithoutDonationInput[]
    createMany?: PeripheralCreateManyDonationInputEnvelope
    connect?: PeripheralWhereUniqueInput | PeripheralWhereUniqueInput[]
  }

  export type FeedbackUncheckedCreateNestedOneWithoutDonationInput = {
    create?: XOR<FeedbackCreateWithoutDonationInput, FeedbackUncheckedCreateWithoutDonationInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutDonationInput
    connect?: FeedbackWhereUniqueInput
  }

  export type PeripheralUncheckedCreateNestedManyWithoutDonationInput = {
    create?: XOR<PeripheralCreateWithoutDonationInput, PeripheralUncheckedCreateWithoutDonationInput> | PeripheralCreateWithoutDonationInput[] | PeripheralUncheckedCreateWithoutDonationInput[]
    connectOrCreate?: PeripheralCreateOrConnectWithoutDonationInput | PeripheralCreateOrConnectWithoutDonationInput[]
    createMany?: PeripheralCreateManyDonationInputEnvelope
    connect?: PeripheralWhereUniqueInput | PeripheralWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type FeedbackUpdateOneWithoutDonationNestedInput = {
    create?: XOR<FeedbackCreateWithoutDonationInput, FeedbackUncheckedCreateWithoutDonationInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutDonationInput
    upsert?: FeedbackUpsertWithoutDonationInput
    disconnect?: boolean
    delete?: boolean
    connect?: FeedbackWhereUniqueInput
    update?: XOR<FeedbackUpdateWithoutDonationInput, FeedbackUncheckedUpdateWithoutDonationInput>
  }

  export type OrganizationUpdateOneRequiredWithoutDonationsNestedInput = {
    create?: XOR<OrganizationCreateWithoutDonationsInput, OrganizationUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutDonationsInput
    upsert?: OrganizationUpsertWithoutDonationsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutDonationsInput, OrganizationUncheckedUpdateWithoutDonationsInput>
  }

  export type DropPointUpdateOneRequiredWithoutDonationsNestedInput = {
    create?: XOR<DropPointCreateWithoutDonationsInput, DropPointUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: DropPointCreateOrConnectWithoutDonationsInput
    upsert?: DropPointUpsertWithoutDonationsInput
    connect?: DropPointWhereUniqueInput
    update?: XOR<DropPointUpdateWithoutDonationsInput, DropPointUncheckedUpdateWithoutDonationsInput>
  }

  export type PeripheralUpdateManyWithoutDonationNestedInput = {
    create?: XOR<PeripheralCreateWithoutDonationInput, PeripheralUncheckedCreateWithoutDonationInput> | PeripheralCreateWithoutDonationInput[] | PeripheralUncheckedCreateWithoutDonationInput[]
    connectOrCreate?: PeripheralCreateOrConnectWithoutDonationInput | PeripheralCreateOrConnectWithoutDonationInput[]
    upsert?: PeripheralUpsertWithWhereUniqueWithoutDonationInput | PeripheralUpsertWithWhereUniqueWithoutDonationInput[]
    createMany?: PeripheralCreateManyDonationInputEnvelope
    set?: PeripheralWhereUniqueInput | PeripheralWhereUniqueInput[]
    disconnect?: PeripheralWhereUniqueInput | PeripheralWhereUniqueInput[]
    delete?: PeripheralWhereUniqueInput | PeripheralWhereUniqueInput[]
    connect?: PeripheralWhereUniqueInput | PeripheralWhereUniqueInput[]
    update?: PeripheralUpdateWithWhereUniqueWithoutDonationInput | PeripheralUpdateWithWhereUniqueWithoutDonationInput[]
    updateMany?: PeripheralUpdateManyWithWhereWithoutDonationInput | PeripheralUpdateManyWithWhereWithoutDonationInput[]
    deleteMany?: PeripheralScalarWhereInput | PeripheralScalarWhereInput[]
  }

  export type FeedbackUncheckedUpdateOneWithoutDonationNestedInput = {
    create?: XOR<FeedbackCreateWithoutDonationInput, FeedbackUncheckedCreateWithoutDonationInput>
    connectOrCreate?: FeedbackCreateOrConnectWithoutDonationInput
    upsert?: FeedbackUpsertWithoutDonationInput
    disconnect?: boolean
    delete?: boolean
    connect?: FeedbackWhereUniqueInput
    update?: XOR<FeedbackUpdateWithoutDonationInput, FeedbackUncheckedUpdateWithoutDonationInput>
  }

  export type PeripheralUncheckedUpdateManyWithoutDonationNestedInput = {
    create?: XOR<PeripheralCreateWithoutDonationInput, PeripheralUncheckedCreateWithoutDonationInput> | PeripheralCreateWithoutDonationInput[] | PeripheralUncheckedCreateWithoutDonationInput[]
    connectOrCreate?: PeripheralCreateOrConnectWithoutDonationInput | PeripheralCreateOrConnectWithoutDonationInput[]
    upsert?: PeripheralUpsertWithWhereUniqueWithoutDonationInput | PeripheralUpsertWithWhereUniqueWithoutDonationInput[]
    createMany?: PeripheralCreateManyDonationInputEnvelope
    set?: PeripheralWhereUniqueInput | PeripheralWhereUniqueInput[]
    disconnect?: PeripheralWhereUniqueInput | PeripheralWhereUniqueInput[]
    delete?: PeripheralWhereUniqueInput | PeripheralWhereUniqueInput[]
    connect?: PeripheralWhereUniqueInput | PeripheralWhereUniqueInput[]
    update?: PeripheralUpdateWithWhereUniqueWithoutDonationInput | PeripheralUpdateWithWhereUniqueWithoutDonationInput[]
    updateMany?: PeripheralUpdateManyWithWhereWithoutDonationInput | PeripheralUpdateManyWithWhereWithoutDonationInput[]
    deleteMany?: PeripheralScalarWhereInput | PeripheralScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutFeedbacksGivenInput = {
    create?: XOR<OrganizationCreateWithoutFeedbacksGivenInput, OrganizationUncheckedCreateWithoutFeedbacksGivenInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutFeedbacksGivenInput
    connect?: OrganizationWhereUniqueInput
  }

  export type DropPointCreateNestedOneWithoutFeedbacksGivenInput = {
    create?: XOR<DropPointCreateWithoutFeedbacksGivenInput, DropPointUncheckedCreateWithoutFeedbacksGivenInput>
    connectOrCreate?: DropPointCreateOrConnectWithoutFeedbacksGivenInput
    connect?: DropPointWhereUniqueInput
  }

  export type DonationCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<DonationCreateWithoutFeedbackInput, DonationUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: DonationCreateOrConnectWithoutFeedbackInput
    connect?: DonationWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutFeedbacksGivenNestedInput = {
    create?: XOR<OrganizationCreateWithoutFeedbacksGivenInput, OrganizationUncheckedCreateWithoutFeedbacksGivenInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutFeedbacksGivenInput
    upsert?: OrganizationUpsertWithoutFeedbacksGivenInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutFeedbacksGivenInput, OrganizationUncheckedUpdateWithoutFeedbacksGivenInput>
  }

  export type DropPointUpdateOneRequiredWithoutFeedbacksGivenNestedInput = {
    create?: XOR<DropPointCreateWithoutFeedbacksGivenInput, DropPointUncheckedCreateWithoutFeedbacksGivenInput>
    connectOrCreate?: DropPointCreateOrConnectWithoutFeedbacksGivenInput
    upsert?: DropPointUpsertWithoutFeedbacksGivenInput
    connect?: DropPointWhereUniqueInput
    update?: XOR<DropPointUpdateWithoutFeedbacksGivenInput, DropPointUncheckedUpdateWithoutFeedbacksGivenInput>
  }

  export type DonationUpdateOneRequiredWithoutFeedbackNestedInput = {
    create?: XOR<DonationCreateWithoutFeedbackInput, DonationUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: DonationCreateOrConnectWithoutFeedbackInput
    upsert?: DonationUpsertWithoutFeedbackInput
    connect?: DonationWhereUniqueInput
    update?: XOR<DonationUpdateWithoutFeedbackInput, DonationUncheckedUpdateWithoutFeedbackInput>
  }

  export type DonationCreateNestedOneWithoutPeripheralsInput = {
    create?: XOR<DonationCreateWithoutPeripheralsInput, DonationUncheckedCreateWithoutPeripheralsInput>
    connectOrCreate?: DonationCreateOrConnectWithoutPeripheralsInput
    connect?: DonationWhereUniqueInput
  }

  export type DonationUpdateOneRequiredWithoutPeripheralsNestedInput = {
    create?: XOR<DonationCreateWithoutPeripheralsInput, DonationUncheckedCreateWithoutPeripheralsInput>
    connectOrCreate?: DonationCreateOrConnectWithoutPeripheralsInput
    upsert?: DonationUpsertWithoutPeripheralsInput
    connect?: DonationWhereUniqueInput
    update?: XOR<DonationUpdateWithoutPeripheralsInput, DonationUncheckedUpdateWithoutPeripheralsInput>
  }

  export type UserCreateNestedManyWithoutCityInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdvertisementCreateNestedManyWithoutCityInput = {
    create?: XOR<AdvertisementCreateWithoutCityInput, AdvertisementUncheckedCreateWithoutCityInput> | AdvertisementCreateWithoutCityInput[] | AdvertisementUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdvertisementCreateOrConnectWithoutCityInput | AdvertisementCreateOrConnectWithoutCityInput[]
    createMany?: AdvertisementCreateManyCityInputEnvelope
    connect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdvertisementUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<AdvertisementCreateWithoutCityInput, AdvertisementUncheckedCreateWithoutCityInput> | AdvertisementCreateWithoutCityInput[] | AdvertisementUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdvertisementCreateOrConnectWithoutCityInput | AdvertisementCreateOrConnectWithoutCityInput[]
    createMany?: AdvertisementCreateManyCityInputEnvelope
    connect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutCityNestedInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCityInput | UserUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCityInput | UserUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCityInput | UserUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdvertisementUpdateManyWithoutCityNestedInput = {
    create?: XOR<AdvertisementCreateWithoutCityInput, AdvertisementUncheckedCreateWithoutCityInput> | AdvertisementCreateWithoutCityInput[] | AdvertisementUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdvertisementCreateOrConnectWithoutCityInput | AdvertisementCreateOrConnectWithoutCityInput[]
    upsert?: AdvertisementUpsertWithWhereUniqueWithoutCityInput | AdvertisementUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: AdvertisementCreateManyCityInputEnvelope
    set?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    disconnect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    delete?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    connect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    update?: AdvertisementUpdateWithWhereUniqueWithoutCityInput | AdvertisementUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: AdvertisementUpdateManyWithWhereWithoutCityInput | AdvertisementUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: AdvertisementScalarWhereInput | AdvertisementScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCityInput | UserUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCityInput | UserUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCityInput | UserUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdvertisementUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<AdvertisementCreateWithoutCityInput, AdvertisementUncheckedCreateWithoutCityInput> | AdvertisementCreateWithoutCityInput[] | AdvertisementUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdvertisementCreateOrConnectWithoutCityInput | AdvertisementCreateOrConnectWithoutCityInput[]
    upsert?: AdvertisementUpsertWithWhereUniqueWithoutCityInput | AdvertisementUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: AdvertisementCreateManyCityInputEnvelope
    set?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    disconnect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    delete?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    connect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    update?: AdvertisementUpdateWithWhereUniqueWithoutCityInput | AdvertisementUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: AdvertisementUpdateManyWithWhereWithoutCityInput | AdvertisementUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: AdvertisementScalarWhereInput | AdvertisementScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutAdvertisementsInput = {
    create?: XOR<OrganizationCreateWithoutAdvertisementsInput, OrganizationUncheckedCreateWithoutAdvertisementsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAdvertisementsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutAdvertisementsInput = {
    create?: XOR<CityCreateWithoutAdvertisementsInput, CityUncheckedCreateWithoutAdvertisementsInput>
    connectOrCreate?: CityCreateOrConnectWithoutAdvertisementsInput
    connect?: CityWhereUniqueInput
  }

  export type AdInteractionCreateNestedManyWithoutAdvertisementInput = {
    create?: XOR<AdInteractionCreateWithoutAdvertisementInput, AdInteractionUncheckedCreateWithoutAdvertisementInput> | AdInteractionCreateWithoutAdvertisementInput[] | AdInteractionUncheckedCreateWithoutAdvertisementInput[]
    connectOrCreate?: AdInteractionCreateOrConnectWithoutAdvertisementInput | AdInteractionCreateOrConnectWithoutAdvertisementInput[]
    createMany?: AdInteractionCreateManyAdvertisementInputEnvelope
    connect?: AdInteractionWhereUniqueInput | AdInteractionWhereUniqueInput[]
  }

  export type AdInteractionUncheckedCreateNestedManyWithoutAdvertisementInput = {
    create?: XOR<AdInteractionCreateWithoutAdvertisementInput, AdInteractionUncheckedCreateWithoutAdvertisementInput> | AdInteractionCreateWithoutAdvertisementInput[] | AdInteractionUncheckedCreateWithoutAdvertisementInput[]
    connectOrCreate?: AdInteractionCreateOrConnectWithoutAdvertisementInput | AdInteractionCreateOrConnectWithoutAdvertisementInput[]
    createMany?: AdInteractionCreateManyAdvertisementInputEnvelope
    connect?: AdInteractionWhereUniqueInput | AdInteractionWhereUniqueInput[]
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type OrganizationUpdateOneRequiredWithoutAdvertisementsNestedInput = {
    create?: XOR<OrganizationCreateWithoutAdvertisementsInput, OrganizationUncheckedCreateWithoutAdvertisementsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAdvertisementsInput
    upsert?: OrganizationUpsertWithoutAdvertisementsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutAdvertisementsInput, OrganizationUncheckedUpdateWithoutAdvertisementsInput>
  }

  export type CityUpdateOneRequiredWithoutAdvertisementsNestedInput = {
    create?: XOR<CityCreateWithoutAdvertisementsInput, CityUncheckedCreateWithoutAdvertisementsInput>
    connectOrCreate?: CityCreateOrConnectWithoutAdvertisementsInput
    upsert?: CityUpsertWithoutAdvertisementsInput
    connect?: CityWhereUniqueInput
    update?: XOR<CityUpdateWithoutAdvertisementsInput, CityUncheckedUpdateWithoutAdvertisementsInput>
  }

  export type AdInteractionUpdateManyWithoutAdvertisementNestedInput = {
    create?: XOR<AdInteractionCreateWithoutAdvertisementInput, AdInteractionUncheckedCreateWithoutAdvertisementInput> | AdInteractionCreateWithoutAdvertisementInput[] | AdInteractionUncheckedCreateWithoutAdvertisementInput[]
    connectOrCreate?: AdInteractionCreateOrConnectWithoutAdvertisementInput | AdInteractionCreateOrConnectWithoutAdvertisementInput[]
    upsert?: AdInteractionUpsertWithWhereUniqueWithoutAdvertisementInput | AdInteractionUpsertWithWhereUniqueWithoutAdvertisementInput[]
    createMany?: AdInteractionCreateManyAdvertisementInputEnvelope
    set?: AdInteractionWhereUniqueInput | AdInteractionWhereUniqueInput[]
    disconnect?: AdInteractionWhereUniqueInput | AdInteractionWhereUniqueInput[]
    delete?: AdInteractionWhereUniqueInput | AdInteractionWhereUniqueInput[]
    connect?: AdInteractionWhereUniqueInput | AdInteractionWhereUniqueInput[]
    update?: AdInteractionUpdateWithWhereUniqueWithoutAdvertisementInput | AdInteractionUpdateWithWhereUniqueWithoutAdvertisementInput[]
    updateMany?: AdInteractionUpdateManyWithWhereWithoutAdvertisementInput | AdInteractionUpdateManyWithWhereWithoutAdvertisementInput[]
    deleteMany?: AdInteractionScalarWhereInput | AdInteractionScalarWhereInput[]
  }

  export type AdInteractionUncheckedUpdateManyWithoutAdvertisementNestedInput = {
    create?: XOR<AdInteractionCreateWithoutAdvertisementInput, AdInteractionUncheckedCreateWithoutAdvertisementInput> | AdInteractionCreateWithoutAdvertisementInput[] | AdInteractionUncheckedCreateWithoutAdvertisementInput[]
    connectOrCreate?: AdInteractionCreateOrConnectWithoutAdvertisementInput | AdInteractionCreateOrConnectWithoutAdvertisementInput[]
    upsert?: AdInteractionUpsertWithWhereUniqueWithoutAdvertisementInput | AdInteractionUpsertWithWhereUniqueWithoutAdvertisementInput[]
    createMany?: AdInteractionCreateManyAdvertisementInputEnvelope
    set?: AdInteractionWhereUniqueInput | AdInteractionWhereUniqueInput[]
    disconnect?: AdInteractionWhereUniqueInput | AdInteractionWhereUniqueInput[]
    delete?: AdInteractionWhereUniqueInput | AdInteractionWhereUniqueInput[]
    connect?: AdInteractionWhereUniqueInput | AdInteractionWhereUniqueInput[]
    update?: AdInteractionUpdateWithWhereUniqueWithoutAdvertisementInput | AdInteractionUpdateWithWhereUniqueWithoutAdvertisementInput[]
    updateMany?: AdInteractionUpdateManyWithWhereWithoutAdvertisementInput | AdInteractionUpdateManyWithWhereWithoutAdvertisementInput[]
    deleteMany?: AdInteractionScalarWhereInput | AdInteractionScalarWhereInput[]
  }

  export type AdvertisementCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<AdvertisementCreateWithoutInteractionsInput, AdvertisementUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: AdvertisementCreateOrConnectWithoutInteractionsInput
    connect?: AdvertisementWhereUniqueInput
  }

  export type AdvertisementUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<AdvertisementCreateWithoutInteractionsInput, AdvertisementUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: AdvertisementCreateOrConnectWithoutInteractionsInput
    upsert?: AdvertisementUpsertWithoutInteractionsInput
    connect?: AdvertisementWhereUniqueInput
    update?: XOR<AdvertisementUpdateWithoutInteractionsInput, AdvertisementUncheckedUpdateWithoutInteractionsInput>
  }

  export type PhotoCreateNestedManyWithoutListingInput = {
    create?: XOR<PhotoCreateWithoutListingInput, PhotoUncheckedCreateWithoutListingInput> | PhotoCreateWithoutListingInput[] | PhotoUncheckedCreateWithoutListingInput[]
    connectOrCreate?: PhotoCreateOrConnectWithoutListingInput | PhotoCreateOrConnectWithoutListingInput[]
    createMany?: PhotoCreateManyListingInputEnvelope
    connect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
  }

  export type CategoryCreateNestedOneWithoutListingsInput = {
    create?: XOR<CategoryCreateWithoutListingsInput, CategoryUncheckedCreateWithoutListingsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutListingsInput
    connect?: CategoryWhereUniqueInput
  }

  export type ConditionCreateNestedOneWithoutListingsInput = {
    create?: XOR<ConditionCreateWithoutListingsInput, ConditionUncheckedCreateWithoutListingsInput>
    connectOrCreate?: ConditionCreateOrConnectWithoutListingsInput
    connect?: ConditionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutListingsInput = {
    create?: XOR<UserCreateWithoutListingsInput, UserUncheckedCreateWithoutListingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutListingsInput
    connect?: UserWhereUniqueInput
  }

  export type SaleCreateNestedManyWithoutListingInput = {
    create?: XOR<SaleCreateWithoutListingInput, SaleUncheckedCreateWithoutListingInput> | SaleCreateWithoutListingInput[] | SaleUncheckedCreateWithoutListingInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutListingInput | SaleCreateOrConnectWithoutListingInput[]
    createMany?: SaleCreateManyListingInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutListingInput = {
    create?: XOR<ConversationCreateWithoutListingInput, ConversationUncheckedCreateWithoutListingInput> | ConversationCreateWithoutListingInput[] | ConversationUncheckedCreateWithoutListingInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutListingInput | ConversationCreateOrConnectWithoutListingInput[]
    createMany?: ConversationCreateManyListingInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type SavedListingCreateNestedManyWithoutListingInput = {
    create?: XOR<SavedListingCreateWithoutListingInput, SavedListingUncheckedCreateWithoutListingInput> | SavedListingCreateWithoutListingInput[] | SavedListingUncheckedCreateWithoutListingInput[]
    connectOrCreate?: SavedListingCreateOrConnectWithoutListingInput | SavedListingCreateOrConnectWithoutListingInput[]
    createMany?: SavedListingCreateManyListingInputEnvelope
    connect?: SavedListingWhereUniqueInput | SavedListingWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutListingInput = {
    create?: XOR<ReportCreateWithoutListingInput, ReportUncheckedCreateWithoutListingInput> | ReportCreateWithoutListingInput[] | ReportUncheckedCreateWithoutListingInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutListingInput | ReportCreateOrConnectWithoutListingInput[]
    createMany?: ReportCreateManyListingInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type PhotoUncheckedCreateNestedManyWithoutListingInput = {
    create?: XOR<PhotoCreateWithoutListingInput, PhotoUncheckedCreateWithoutListingInput> | PhotoCreateWithoutListingInput[] | PhotoUncheckedCreateWithoutListingInput[]
    connectOrCreate?: PhotoCreateOrConnectWithoutListingInput | PhotoCreateOrConnectWithoutListingInput[]
    createMany?: PhotoCreateManyListingInputEnvelope
    connect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutListingInput = {
    create?: XOR<SaleCreateWithoutListingInput, SaleUncheckedCreateWithoutListingInput> | SaleCreateWithoutListingInput[] | SaleUncheckedCreateWithoutListingInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutListingInput | SaleCreateOrConnectWithoutListingInput[]
    createMany?: SaleCreateManyListingInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutListingInput = {
    create?: XOR<ConversationCreateWithoutListingInput, ConversationUncheckedCreateWithoutListingInput> | ConversationCreateWithoutListingInput[] | ConversationUncheckedCreateWithoutListingInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutListingInput | ConversationCreateOrConnectWithoutListingInput[]
    createMany?: ConversationCreateManyListingInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type SavedListingUncheckedCreateNestedManyWithoutListingInput = {
    create?: XOR<SavedListingCreateWithoutListingInput, SavedListingUncheckedCreateWithoutListingInput> | SavedListingCreateWithoutListingInput[] | SavedListingUncheckedCreateWithoutListingInput[]
    connectOrCreate?: SavedListingCreateOrConnectWithoutListingInput | SavedListingCreateOrConnectWithoutListingInput[]
    createMany?: SavedListingCreateManyListingInputEnvelope
    connect?: SavedListingWhereUniqueInput | SavedListingWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutListingInput = {
    create?: XOR<ReportCreateWithoutListingInput, ReportUncheckedCreateWithoutListingInput> | ReportCreateWithoutListingInput[] | ReportUncheckedCreateWithoutListingInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutListingInput | ReportCreateOrConnectWithoutListingInput[]
    createMany?: ReportCreateManyListingInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type PhotoUpdateManyWithoutListingNestedInput = {
    create?: XOR<PhotoCreateWithoutListingInput, PhotoUncheckedCreateWithoutListingInput> | PhotoCreateWithoutListingInput[] | PhotoUncheckedCreateWithoutListingInput[]
    connectOrCreate?: PhotoCreateOrConnectWithoutListingInput | PhotoCreateOrConnectWithoutListingInput[]
    upsert?: PhotoUpsertWithWhereUniqueWithoutListingInput | PhotoUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: PhotoCreateManyListingInputEnvelope
    set?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    disconnect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    delete?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    connect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    update?: PhotoUpdateWithWhereUniqueWithoutListingInput | PhotoUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: PhotoUpdateManyWithWhereWithoutListingInput | PhotoUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: PhotoScalarWhereInput | PhotoScalarWhereInput[]
  }

  export type CategoryUpdateOneRequiredWithoutListingsNestedInput = {
    create?: XOR<CategoryCreateWithoutListingsInput, CategoryUncheckedCreateWithoutListingsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutListingsInput
    upsert?: CategoryUpsertWithoutListingsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<CategoryUpdateWithoutListingsInput, CategoryUncheckedUpdateWithoutListingsInput>
  }

  export type ConditionUpdateOneRequiredWithoutListingsNestedInput = {
    create?: XOR<ConditionCreateWithoutListingsInput, ConditionUncheckedCreateWithoutListingsInput>
    connectOrCreate?: ConditionCreateOrConnectWithoutListingsInput
    upsert?: ConditionUpsertWithoutListingsInput
    connect?: ConditionWhereUniqueInput
    update?: XOR<ConditionUpdateWithoutListingsInput, ConditionUncheckedUpdateWithoutListingsInput>
  }

  export type UserUpdateOneRequiredWithoutListingsNestedInput = {
    create?: XOR<UserCreateWithoutListingsInput, UserUncheckedCreateWithoutListingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutListingsInput
    upsert?: UserUpsertWithoutListingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutListingsInput, UserUncheckedUpdateWithoutListingsInput>
  }

  export type SaleUpdateManyWithoutListingNestedInput = {
    create?: XOR<SaleCreateWithoutListingInput, SaleUncheckedCreateWithoutListingInput> | SaleCreateWithoutListingInput[] | SaleUncheckedCreateWithoutListingInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutListingInput | SaleCreateOrConnectWithoutListingInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutListingInput | SaleUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: SaleCreateManyListingInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutListingInput | SaleUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutListingInput | SaleUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutListingNestedInput = {
    create?: XOR<ConversationCreateWithoutListingInput, ConversationUncheckedCreateWithoutListingInput> | ConversationCreateWithoutListingInput[] | ConversationUncheckedCreateWithoutListingInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutListingInput | ConversationCreateOrConnectWithoutListingInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutListingInput | ConversationUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: ConversationCreateManyListingInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutListingInput | ConversationUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutListingInput | ConversationUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type SavedListingUpdateManyWithoutListingNestedInput = {
    create?: XOR<SavedListingCreateWithoutListingInput, SavedListingUncheckedCreateWithoutListingInput> | SavedListingCreateWithoutListingInput[] | SavedListingUncheckedCreateWithoutListingInput[]
    connectOrCreate?: SavedListingCreateOrConnectWithoutListingInput | SavedListingCreateOrConnectWithoutListingInput[]
    upsert?: SavedListingUpsertWithWhereUniqueWithoutListingInput | SavedListingUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: SavedListingCreateManyListingInputEnvelope
    set?: SavedListingWhereUniqueInput | SavedListingWhereUniqueInput[]
    disconnect?: SavedListingWhereUniqueInput | SavedListingWhereUniqueInput[]
    delete?: SavedListingWhereUniqueInput | SavedListingWhereUniqueInput[]
    connect?: SavedListingWhereUniqueInput | SavedListingWhereUniqueInput[]
    update?: SavedListingUpdateWithWhereUniqueWithoutListingInput | SavedListingUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: SavedListingUpdateManyWithWhereWithoutListingInput | SavedListingUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: SavedListingScalarWhereInput | SavedListingScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutListingNestedInput = {
    create?: XOR<ReportCreateWithoutListingInput, ReportUncheckedCreateWithoutListingInput> | ReportCreateWithoutListingInput[] | ReportUncheckedCreateWithoutListingInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutListingInput | ReportCreateOrConnectWithoutListingInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutListingInput | ReportUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: ReportCreateManyListingInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutListingInput | ReportUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutListingInput | ReportUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type PhotoUncheckedUpdateManyWithoutListingNestedInput = {
    create?: XOR<PhotoCreateWithoutListingInput, PhotoUncheckedCreateWithoutListingInput> | PhotoCreateWithoutListingInput[] | PhotoUncheckedCreateWithoutListingInput[]
    connectOrCreate?: PhotoCreateOrConnectWithoutListingInput | PhotoCreateOrConnectWithoutListingInput[]
    upsert?: PhotoUpsertWithWhereUniqueWithoutListingInput | PhotoUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: PhotoCreateManyListingInputEnvelope
    set?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    disconnect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    delete?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    connect?: PhotoWhereUniqueInput | PhotoWhereUniqueInput[]
    update?: PhotoUpdateWithWhereUniqueWithoutListingInput | PhotoUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: PhotoUpdateManyWithWhereWithoutListingInput | PhotoUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: PhotoScalarWhereInput | PhotoScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutListingNestedInput = {
    create?: XOR<SaleCreateWithoutListingInput, SaleUncheckedCreateWithoutListingInput> | SaleCreateWithoutListingInput[] | SaleUncheckedCreateWithoutListingInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutListingInput | SaleCreateOrConnectWithoutListingInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutListingInput | SaleUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: SaleCreateManyListingInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutListingInput | SaleUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutListingInput | SaleUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutListingNestedInput = {
    create?: XOR<ConversationCreateWithoutListingInput, ConversationUncheckedCreateWithoutListingInput> | ConversationCreateWithoutListingInput[] | ConversationUncheckedCreateWithoutListingInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutListingInput | ConversationCreateOrConnectWithoutListingInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutListingInput | ConversationUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: ConversationCreateManyListingInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutListingInput | ConversationUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutListingInput | ConversationUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type SavedListingUncheckedUpdateManyWithoutListingNestedInput = {
    create?: XOR<SavedListingCreateWithoutListingInput, SavedListingUncheckedCreateWithoutListingInput> | SavedListingCreateWithoutListingInput[] | SavedListingUncheckedCreateWithoutListingInput[]
    connectOrCreate?: SavedListingCreateOrConnectWithoutListingInput | SavedListingCreateOrConnectWithoutListingInput[]
    upsert?: SavedListingUpsertWithWhereUniqueWithoutListingInput | SavedListingUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: SavedListingCreateManyListingInputEnvelope
    set?: SavedListingWhereUniqueInput | SavedListingWhereUniqueInput[]
    disconnect?: SavedListingWhereUniqueInput | SavedListingWhereUniqueInput[]
    delete?: SavedListingWhereUniqueInput | SavedListingWhereUniqueInput[]
    connect?: SavedListingWhereUniqueInput | SavedListingWhereUniqueInput[]
    update?: SavedListingUpdateWithWhereUniqueWithoutListingInput | SavedListingUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: SavedListingUpdateManyWithWhereWithoutListingInput | SavedListingUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: SavedListingScalarWhereInput | SavedListingScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutListingNestedInput = {
    create?: XOR<ReportCreateWithoutListingInput, ReportUncheckedCreateWithoutListingInput> | ReportCreateWithoutListingInput[] | ReportUncheckedCreateWithoutListingInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutListingInput | ReportCreateOrConnectWithoutListingInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutListingInput | ReportUpsertWithWhereUniqueWithoutListingInput[]
    createMany?: ReportCreateManyListingInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutListingInput | ReportUpdateWithWhereUniqueWithoutListingInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutListingInput | ReportUpdateManyWithWhereWithoutListingInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ListingCreateNestedOneWithoutReportsInput = {
    create?: XOR<ListingCreateWithoutReportsInput, ListingUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ListingCreateOrConnectWithoutReportsInput
    connect?: ListingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportsMadeInput = {
    create?: XOR<UserCreateWithoutReportsMadeInput, UserUncheckedCreateWithoutReportsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsMadeInput
    connect?: UserWhereUniqueInput
  }

  export type ListingUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<ListingCreateWithoutReportsInput, ListingUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ListingCreateOrConnectWithoutReportsInput
    upsert?: ListingUpsertWithoutReportsInput
    connect?: ListingWhereUniqueInput
    update?: XOR<ListingUpdateWithoutReportsInput, ListingUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateOneRequiredWithoutReportsMadeNestedInput = {
    create?: XOR<UserCreateWithoutReportsMadeInput, UserUncheckedCreateWithoutReportsMadeInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsMadeInput
    upsert?: UserUpsertWithoutReportsMadeInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutReportsMadeInput, UserUncheckedUpdateWithoutReportsMadeInput>
  }

  export type UserCreateNestedOneWithoutSavedListingsInput = {
    create?: XOR<UserCreateWithoutSavedListingsInput, UserUncheckedCreateWithoutSavedListingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedListingsInput
    connect?: UserWhereUniqueInput
  }

  export type ListingCreateNestedOneWithoutSavedByUsersInput = {
    create?: XOR<ListingCreateWithoutSavedByUsersInput, ListingUncheckedCreateWithoutSavedByUsersInput>
    connectOrCreate?: ListingCreateOrConnectWithoutSavedByUsersInput
    connect?: ListingWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSavedListingsNestedInput = {
    create?: XOR<UserCreateWithoutSavedListingsInput, UserUncheckedCreateWithoutSavedListingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedListingsInput
    upsert?: UserUpsertWithoutSavedListingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSavedListingsInput, UserUncheckedUpdateWithoutSavedListingsInput>
  }

  export type ListingUpdateOneRequiredWithoutSavedByUsersNestedInput = {
    create?: XOR<ListingCreateWithoutSavedByUsersInput, ListingUncheckedCreateWithoutSavedByUsersInput>
    connectOrCreate?: ListingCreateOrConnectWithoutSavedByUsersInput
    upsert?: ListingUpsertWithoutSavedByUsersInput
    connect?: ListingWhereUniqueInput
    update?: XOR<ListingUpdateWithoutSavedByUsersInput, ListingUncheckedUpdateWithoutSavedByUsersInput>
  }

  export type UserCreateNestedOneWithoutPurchasesInput = {
    create?: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasesInput
    connect?: UserWhereUniqueInput
  }

  export type ListingCreateNestedOneWithoutSalesInput = {
    create?: XOR<ListingCreateWithoutSalesInput, ListingUncheckedCreateWithoutSalesInput>
    connectOrCreate?: ListingCreateOrConnectWithoutSalesInput
    connect?: ListingWhereUniqueInput
  }

  export type ConversationCreateNestedOneWithoutSaleInput = {
    create?: XOR<ConversationCreateWithoutSaleInput, ConversationUncheckedCreateWithoutSaleInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutSaleInput
    connect?: ConversationWhereUniqueInput
  }

  export type RatingCreateNestedManyWithoutSaleInput = {
    create?: XOR<RatingCreateWithoutSaleInput, RatingUncheckedCreateWithoutSaleInput> | RatingCreateWithoutSaleInput[] | RatingUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutSaleInput | RatingCreateOrConnectWithoutSaleInput[]
    createMany?: RatingCreateManySaleInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type RatingUncheckedCreateNestedManyWithoutSaleInput = {
    create?: XOR<RatingCreateWithoutSaleInput, RatingUncheckedCreateWithoutSaleInput> | RatingCreateWithoutSaleInput[] | RatingUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutSaleInput | RatingCreateOrConnectWithoutSaleInput[]
    createMany?: RatingCreateManySaleInputEnvelope
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPurchasesNestedInput = {
    create?: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchasesInput
    upsert?: UserUpsertWithoutPurchasesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutPurchasesInput, UserUncheckedUpdateWithoutPurchasesInput>
  }

  export type ListingUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<ListingCreateWithoutSalesInput, ListingUncheckedCreateWithoutSalesInput>
    connectOrCreate?: ListingCreateOrConnectWithoutSalesInput
    upsert?: ListingUpsertWithoutSalesInput
    connect?: ListingWhereUniqueInput
    update?: XOR<ListingUpdateWithoutSalesInput, ListingUncheckedUpdateWithoutSalesInput>
  }

  export type ConversationUpdateOneWithoutSaleNestedInput = {
    create?: XOR<ConversationCreateWithoutSaleInput, ConversationUncheckedCreateWithoutSaleInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutSaleInput
    upsert?: ConversationUpsertWithoutSaleInput
    disconnect?: boolean
    delete?: boolean
    connect?: ConversationWhereUniqueInput
    update?: XOR<ConversationUpdateWithoutSaleInput, ConversationUncheckedUpdateWithoutSaleInput>
  }

  export type RatingUpdateManyWithoutSaleNestedInput = {
    create?: XOR<RatingCreateWithoutSaleInput, RatingUncheckedCreateWithoutSaleInput> | RatingCreateWithoutSaleInput[] | RatingUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutSaleInput | RatingCreateOrConnectWithoutSaleInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutSaleInput | RatingUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: RatingCreateManySaleInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutSaleInput | RatingUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutSaleInput | RatingUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type RatingUncheckedUpdateManyWithoutSaleNestedInput = {
    create?: XOR<RatingCreateWithoutSaleInput, RatingUncheckedCreateWithoutSaleInput> | RatingCreateWithoutSaleInput[] | RatingUncheckedCreateWithoutSaleInput[]
    connectOrCreate?: RatingCreateOrConnectWithoutSaleInput | RatingCreateOrConnectWithoutSaleInput[]
    upsert?: RatingUpsertWithWhereUniqueWithoutSaleInput | RatingUpsertWithWhereUniqueWithoutSaleInput[]
    createMany?: RatingCreateManySaleInputEnvelope
    set?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    disconnect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    delete?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    connect?: RatingWhereUniqueInput | RatingWhereUniqueInput[]
    update?: RatingUpdateWithWhereUniqueWithoutSaleInput | RatingUpdateWithWhereUniqueWithoutSaleInput[]
    updateMany?: RatingUpdateManyWithWhereWithoutSaleInput | RatingUpdateManyWithWhereWithoutSaleInput[]
    deleteMany?: RatingScalarWhereInput | RatingScalarWhereInput[]
  }

  export type SaleCreateNestedOneWithoutRatingInput = {
    create?: XOR<SaleCreateWithoutRatingInput, SaleUncheckedCreateWithoutRatingInput>
    connectOrCreate?: SaleCreateOrConnectWithoutRatingInput
    connect?: SaleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGivenRatingsInput = {
    create?: XOR<UserCreateWithoutGivenRatingsInput, UserUncheckedCreateWithoutGivenRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGivenRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedRatingsInput = {
    create?: XOR<UserCreateWithoutReceivedRatingsInput, UserUncheckedCreateWithoutReceivedRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedRatingsInput
    connect?: UserWhereUniqueInput
  }

  export type SaleUpdateOneRequiredWithoutRatingNestedInput = {
    create?: XOR<SaleCreateWithoutRatingInput, SaleUncheckedCreateWithoutRatingInput>
    connectOrCreate?: SaleCreateOrConnectWithoutRatingInput
    upsert?: SaleUpsertWithoutRatingInput
    connect?: SaleWhereUniqueInput
    update?: XOR<SaleUpdateWithoutRatingInput, SaleUncheckedUpdateWithoutRatingInput>
  }

  export type UserUpdateOneRequiredWithoutGivenRatingsNestedInput = {
    create?: XOR<UserCreateWithoutGivenRatingsInput, UserUncheckedCreateWithoutGivenRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGivenRatingsInput
    upsert?: UserUpsertWithoutGivenRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutGivenRatingsInput, UserUncheckedUpdateWithoutGivenRatingsInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedRatingsNestedInput = {
    create?: XOR<UserCreateWithoutReceivedRatingsInput, UserUncheckedCreateWithoutReceivedRatingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedRatingsInput
    upsert?: UserUpsertWithoutReceivedRatingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutReceivedRatingsInput, UserUncheckedUpdateWithoutReceivedRatingsInput>
  }

  export type ListingCreateNestedOneWithoutPhotosInput = {
    create?: XOR<ListingCreateWithoutPhotosInput, ListingUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ListingCreateOrConnectWithoutPhotosInput
    connect?: ListingWhereUniqueInput
  }

  export type ListingUpdateOneRequiredWithoutPhotosNestedInput = {
    create?: XOR<ListingCreateWithoutPhotosInput, ListingUncheckedCreateWithoutPhotosInput>
    connectOrCreate?: ListingCreateOrConnectWithoutPhotosInput
    upsert?: ListingUpsertWithoutPhotosInput
    connect?: ListingWhereUniqueInput
    update?: XOR<ListingUpdateWithoutPhotosInput, ListingUncheckedUpdateWithoutPhotosInput>
  }

  export type ListingCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ListingCreateWithoutCategoryInput, ListingUncheckedCreateWithoutCategoryInput> | ListingCreateWithoutCategoryInput[] | ListingUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutCategoryInput | ListingCreateOrConnectWithoutCategoryInput[]
    createMany?: ListingCreateManyCategoryInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type ListingUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ListingCreateWithoutCategoryInput, ListingUncheckedCreateWithoutCategoryInput> | ListingCreateWithoutCategoryInput[] | ListingUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutCategoryInput | ListingCreateOrConnectWithoutCategoryInput[]
    createMany?: ListingCreateManyCategoryInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type ListingUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ListingCreateWithoutCategoryInput, ListingUncheckedCreateWithoutCategoryInput> | ListingCreateWithoutCategoryInput[] | ListingUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutCategoryInput | ListingCreateOrConnectWithoutCategoryInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutCategoryInput | ListingUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ListingCreateManyCategoryInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutCategoryInput | ListingUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutCategoryInput | ListingUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type ListingUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ListingCreateWithoutCategoryInput, ListingUncheckedCreateWithoutCategoryInput> | ListingCreateWithoutCategoryInput[] | ListingUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutCategoryInput | ListingCreateOrConnectWithoutCategoryInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutCategoryInput | ListingUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ListingCreateManyCategoryInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutCategoryInput | ListingUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutCategoryInput | ListingUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type ListingCreateNestedManyWithoutConditionInput = {
    create?: XOR<ListingCreateWithoutConditionInput, ListingUncheckedCreateWithoutConditionInput> | ListingCreateWithoutConditionInput[] | ListingUncheckedCreateWithoutConditionInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutConditionInput | ListingCreateOrConnectWithoutConditionInput[]
    createMany?: ListingCreateManyConditionInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type ListingUncheckedCreateNestedManyWithoutConditionInput = {
    create?: XOR<ListingCreateWithoutConditionInput, ListingUncheckedCreateWithoutConditionInput> | ListingCreateWithoutConditionInput[] | ListingUncheckedCreateWithoutConditionInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutConditionInput | ListingCreateOrConnectWithoutConditionInput[]
    createMany?: ListingCreateManyConditionInputEnvelope
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
  }

  export type ListingUpdateManyWithoutConditionNestedInput = {
    create?: XOR<ListingCreateWithoutConditionInput, ListingUncheckedCreateWithoutConditionInput> | ListingCreateWithoutConditionInput[] | ListingUncheckedCreateWithoutConditionInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutConditionInput | ListingCreateOrConnectWithoutConditionInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutConditionInput | ListingUpsertWithWhereUniqueWithoutConditionInput[]
    createMany?: ListingCreateManyConditionInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutConditionInput | ListingUpdateWithWhereUniqueWithoutConditionInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutConditionInput | ListingUpdateManyWithWhereWithoutConditionInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type ListingUncheckedUpdateManyWithoutConditionNestedInput = {
    create?: XOR<ListingCreateWithoutConditionInput, ListingUncheckedCreateWithoutConditionInput> | ListingCreateWithoutConditionInput[] | ListingUncheckedCreateWithoutConditionInput[]
    connectOrCreate?: ListingCreateOrConnectWithoutConditionInput | ListingCreateOrConnectWithoutConditionInput[]
    upsert?: ListingUpsertWithWhereUniqueWithoutConditionInput | ListingUpsertWithWhereUniqueWithoutConditionInput[]
    createMany?: ListingCreateManyConditionInputEnvelope
    set?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    disconnect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    delete?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    connect?: ListingWhereUniqueInput | ListingWhereUniqueInput[]
    update?: ListingUpdateWithWhereUniqueWithoutConditionInput | ListingUpdateWithWhereUniqueWithoutConditionInput[]
    updateMany?: ListingUpdateManyWithWhereWithoutConditionInput | ListingUpdateManyWithWhereWithoutConditionInput[]
    deleteMany?: ListingScalarWhereInput | ListingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutConversationsInitiatedInput = {
    create?: XOR<UserCreateWithoutConversationsInitiatedInput, UserUncheckedCreateWithoutConversationsInitiatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInitiatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutConversationsReceivedInput = {
    create?: XOR<UserCreateWithoutConversationsReceivedInput, UserUncheckedCreateWithoutConversationsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type ListingCreateNestedOneWithoutConversationsInput = {
    create?: XOR<ListingCreateWithoutConversationsInput, ListingUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: ListingCreateOrConnectWithoutConversationsInput
    connect?: ListingWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type SaleCreateNestedManyWithoutConversationInput = {
    create?: XOR<SaleCreateWithoutConversationInput, SaleUncheckedCreateWithoutConversationInput> | SaleCreateWithoutConversationInput[] | SaleUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutConversationInput | SaleCreateOrConnectWithoutConversationInput[]
    createMany?: SaleCreateManyConversationInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<SaleCreateWithoutConversationInput, SaleUncheckedCreateWithoutConversationInput> | SaleCreateWithoutConversationInput[] | SaleUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutConversationInput | SaleCreateOrConnectWithoutConversationInput[]
    createMany?: SaleCreateManyConversationInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutConversationsInitiatedNestedInput = {
    create?: XOR<UserCreateWithoutConversationsInitiatedInput, UserUncheckedCreateWithoutConversationsInitiatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInitiatedInput
    upsert?: UserUpsertWithoutConversationsInitiatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutConversationsInitiatedInput, UserUncheckedUpdateWithoutConversationsInitiatedInput>
  }

  export type UserUpdateOneRequiredWithoutConversationsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutConversationsReceivedInput, UserUncheckedCreateWithoutConversationsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsReceivedInput
    upsert?: UserUpsertWithoutConversationsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutConversationsReceivedInput, UserUncheckedUpdateWithoutConversationsReceivedInput>
  }

  export type ListingUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<ListingCreateWithoutConversationsInput, ListingUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: ListingCreateOrConnectWithoutConversationsInput
    upsert?: ListingUpsertWithoutConversationsInput
    connect?: ListingWhereUniqueInput
    update?: XOR<ListingUpdateWithoutConversationsInput, ListingUncheckedUpdateWithoutConversationsInput>
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type SaleUpdateManyWithoutConversationNestedInput = {
    create?: XOR<SaleCreateWithoutConversationInput, SaleUncheckedCreateWithoutConversationInput> | SaleCreateWithoutConversationInput[] | SaleUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutConversationInput | SaleCreateOrConnectWithoutConversationInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutConversationInput | SaleUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: SaleCreateManyConversationInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutConversationInput | SaleUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutConversationInput | SaleUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<SaleCreateWithoutConversationInput, SaleUncheckedCreateWithoutConversationInput> | SaleCreateWithoutConversationInput[] | SaleUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutConversationInput | SaleCreateOrConnectWithoutConversationInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutConversationInput | SaleUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: SaleCreateManyConversationInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutConversationInput | SaleUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutConversationInput | SaleUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: string[] | string
    notIn?: string[] | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBytesNullableFilter = {
    equals?: Buffer | null
    in?: Buffer[] | Buffer | null
    notIn?: Buffer[] | Buffer | null
    not?: NestedBytesNullableFilter | Buffer | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Date[] | string[] | Date | string
    notIn?: Date[] | string[] | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: string[] | string
    notIn?: string[] | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedBytesNullableWithAggregatesFilter = {
    equals?: Buffer | null
    in?: Buffer[] | Buffer | null
    notIn?: Buffer[] | Buffer | null
    not?: NestedBytesNullableWithAggregatesFilter | Buffer | null
    _count?: NestedIntNullableFilter
    _min?: NestedBytesNullableFilter
    _max?: NestedBytesNullableFilter
    isSet?: boolean
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: number[] | number | null
    notIn?: number[] | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Date[] | string[] | Date | string
    notIn?: Date[] | string[] | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: string[] | string | null
    notIn?: string[] | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
    isSet?: boolean
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: string[] | string | null
    notIn?: string[] | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    isSet?: boolean
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | Date | string | null
    notIn?: Date[] | string[] | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
    isSet?: boolean
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: number[] | number | null
    notIn?: number[] | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | Date | string | null
    notIn?: Date[] | string[] | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    isSet?: boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: number[] | number | null
    notIn?: number[] | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
    isSet?: boolean
  }

  export type NestedBytesFilter = {
    equals?: Buffer
    in?: Buffer[] | Buffer
    notIn?: Buffer[] | Buffer
    not?: NestedBytesFilter | Buffer
  }

  export type NestedBytesWithAggregatesFilter = {
    equals?: Buffer
    in?: Buffer[] | Buffer
    notIn?: Buffer[] | Buffer
    not?: NestedBytesWithAggregatesFilter | Buffer
    _count?: NestedIntFilter
    _min?: NestedBytesFilter
    _max?: NestedBytesFilter
  }

  export type CityCreateWithoutUsersInput = {
    id?: string
    name: string
    advertisements?: AdvertisementCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    advertisements?: AdvertisementUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutUsersInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
  }

  export type ListingCreateWithoutUserInput = {
    id?: string
    title: string
    price: number
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    photos?: PhotoCreateNestedManyWithoutListingInput
    category: CategoryCreateNestedOneWithoutListingsInput
    condition: ConditionCreateNestedOneWithoutListingsInput
    sales?: SaleCreateNestedManyWithoutListingInput
    conversations?: ConversationCreateNestedManyWithoutListingInput
    savedByUsers?: SavedListingCreateNestedManyWithoutListingInput
    reports?: ReportCreateNestedManyWithoutListingInput
  }

  export type ListingUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    price: number
    categoryId: string
    conditionId: string
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    photos?: PhotoUncheckedCreateNestedManyWithoutListingInput
    sales?: SaleUncheckedCreateNestedManyWithoutListingInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutListingInput
    savedByUsers?: SavedListingUncheckedCreateNestedManyWithoutListingInput
    reports?: ReportUncheckedCreateNestedManyWithoutListingInput
  }

  export type ListingCreateOrConnectWithoutUserInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutUserInput, ListingUncheckedCreateWithoutUserInput>
  }

  export type ListingCreateManyUserInputEnvelope = {
    data: ListingCreateManyUserInput | ListingCreateManyUserInput[]
  }

  export type SaleCreateWithoutBuyerInput = {
    id?: string
    salePrice: number
    saleDate?: Date | string
    listing: ListingCreateNestedOneWithoutSalesInput
    conversation?: ConversationCreateNestedOneWithoutSaleInput
    rating?: RatingCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutBuyerInput = {
    id?: string
    listingId: string
    conversationId?: string | null
    salePrice: number
    saleDate?: Date | string
    rating?: RatingUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutBuyerInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutBuyerInput, SaleUncheckedCreateWithoutBuyerInput>
  }

  export type SaleCreateManyBuyerInputEnvelope = {
    data: SaleCreateManyBuyerInput | SaleCreateManyBuyerInput[]
  }

  export type ConversationCreateWithoutUser1Input = {
    id?: string
    createdAt?: Date | string
    user2: UserCreateNestedOneWithoutConversationsReceivedInput
    listing: ListingCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    Sale?: SaleCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutUser1Input = {
    id?: string
    user2Id: string
    listingId: string
    createdAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    Sale?: SaleUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutUser1Input = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutUser1Input, ConversationUncheckedCreateWithoutUser1Input>
  }

  export type ConversationCreateManyUser1InputEnvelope = {
    data: ConversationCreateManyUser1Input | ConversationCreateManyUser1Input[]
  }

  export type ConversationCreateWithoutUser2Input = {
    id?: string
    createdAt?: Date | string
    user1: UserCreateNestedOneWithoutConversationsInitiatedInput
    listing: ListingCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    Sale?: SaleCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutUser2Input = {
    id?: string
    user1Id: string
    listingId: string
    createdAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    Sale?: SaleUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutUser2Input = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutUser2Input, ConversationUncheckedCreateWithoutUser2Input>
  }

  export type ConversationCreateManyUser2InputEnvelope = {
    data: ConversationCreateManyUser2Input | ConversationCreateManyUser2Input[]
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content?: string | null
    imageFileId?: string | null
    read?: boolean
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    content?: string | null
    conversationId: string
    imageFileId?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
  }

  export type RatingCreateWithoutRaterInput = {
    id?: string
    value: number
    comment?: string | null
    createdAt?: Date | string
    type: string
    sale: SaleCreateNestedOneWithoutRatingInput
    ratee: UserCreateNestedOneWithoutReceivedRatingsInput
  }

  export type RatingUncheckedCreateWithoutRaterInput = {
    id?: string
    value: number
    comment?: string | null
    saleId: string
    rateeId: string
    createdAt?: Date | string
    type: string
  }

  export type RatingCreateOrConnectWithoutRaterInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutRaterInput, RatingUncheckedCreateWithoutRaterInput>
  }

  export type RatingCreateManyRaterInputEnvelope = {
    data: RatingCreateManyRaterInput | RatingCreateManyRaterInput[]
  }

  export type RatingCreateWithoutRateeInput = {
    id?: string
    value: number
    comment?: string | null
    createdAt?: Date | string
    type: string
    sale: SaleCreateNestedOneWithoutRatingInput
    rater: UserCreateNestedOneWithoutGivenRatingsInput
  }

  export type RatingUncheckedCreateWithoutRateeInput = {
    id?: string
    value: number
    comment?: string | null
    saleId: string
    raterId: string
    createdAt?: Date | string
    type: string
  }

  export type RatingCreateOrConnectWithoutRateeInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutRateeInput, RatingUncheckedCreateWithoutRateeInput>
  }

  export type RatingCreateManyRateeInputEnvelope = {
    data: RatingCreateManyRateeInput | RatingCreateManyRateeInput[]
  }

  export type SavedListingCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    listing: ListingCreateNestedOneWithoutSavedByUsersInput
  }

  export type SavedListingUncheckedCreateWithoutUserInput = {
    id?: string
    listingId: string
    createdAt?: Date | string
  }

  export type SavedListingCreateOrConnectWithoutUserInput = {
    where: SavedListingWhereUniqueInput
    create: XOR<SavedListingCreateWithoutUserInput, SavedListingUncheckedCreateWithoutUserInput>
  }

  export type SavedListingCreateManyUserInputEnvelope = {
    data: SavedListingCreateManyUserInput | SavedListingCreateManyUserInput[]
  }

  export type ReportCreateWithoutReportedByInput = {
    id?: string
    reason: string
    createdAt?: Date | string
    listing: ListingCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutReportedByInput = {
    id?: string
    listingId: string
    reason: string
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutReportedByInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutReportedByInput, ReportUncheckedCreateWithoutReportedByInput>
  }

  export type ReportCreateManyReportedByInputEnvelope = {
    data: ReportCreateManyReportedByInput | ReportCreateManyReportedByInput[]
  }

  export type CityUpsertWithoutUsersInput = {
    update: XOR<CityUpdateWithoutUsersInput, CityUncheckedUpdateWithoutUsersInput>
    create: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
  }

  export type CityUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    advertisements?: AdvertisementUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    advertisements?: AdvertisementUncheckedUpdateManyWithoutCityNestedInput
  }

  export type ListingUpsertWithWhereUniqueWithoutUserInput = {
    where: ListingWhereUniqueInput
    update: XOR<ListingUpdateWithoutUserInput, ListingUncheckedUpdateWithoutUserInput>
    create: XOR<ListingCreateWithoutUserInput, ListingUncheckedCreateWithoutUserInput>
  }

  export type ListingUpdateWithWhereUniqueWithoutUserInput = {
    where: ListingWhereUniqueInput
    data: XOR<ListingUpdateWithoutUserInput, ListingUncheckedUpdateWithoutUserInput>
  }

  export type ListingUpdateManyWithWhereWithoutUserInput = {
    where: ListingScalarWhereInput
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyWithoutListingsInput>
  }

  export type ListingScalarWhereInput = {
    AND?: ListingScalarWhereInput | ListingScalarWhereInput[]
    OR?: ListingScalarWhereInput[]
    NOT?: ListingScalarWhereInput | ListingScalarWhereInput[]
    id?: StringFilter | string
    title?: StringFilter | string
    price?: FloatFilter | number
    categoryId?: StringFilter | string
    conditionId?: StringFilter | string
    description?: StringFilter | string
    location?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    userId?: StringFilter | string
    status?: StringFilter | string
  }

  export type SaleUpsertWithWhereUniqueWithoutBuyerInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutBuyerInput, SaleUncheckedUpdateWithoutBuyerInput>
    create: XOR<SaleCreateWithoutBuyerInput, SaleUncheckedCreateWithoutBuyerInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutBuyerInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutBuyerInput, SaleUncheckedUpdateWithoutBuyerInput>
  }

  export type SaleUpdateManyWithWhereWithoutBuyerInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutPurchasesInput>
  }

  export type SaleScalarWhereInput = {
    AND?: SaleScalarWhereInput | SaleScalarWhereInput[]
    OR?: SaleScalarWhereInput[]
    NOT?: SaleScalarWhereInput | SaleScalarWhereInput[]
    id?: StringFilter | string
    buyerId?: StringFilter | string
    listingId?: StringFilter | string
    conversationId?: StringNullableFilter | string | null
    salePrice?: FloatFilter | number
    saleDate?: DateTimeFilter | Date | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutUser1Input = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutUser1Input, ConversationUncheckedUpdateWithoutUser1Input>
    create: XOR<ConversationCreateWithoutUser1Input, ConversationUncheckedCreateWithoutUser1Input>
  }

  export type ConversationUpdateWithWhereUniqueWithoutUser1Input = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutUser1Input, ConversationUncheckedUpdateWithoutUser1Input>
  }

  export type ConversationUpdateManyWithWhereWithoutUser1Input = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutConversationsInitiatedInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter | string
    user1Id?: StringFilter | string
    user2Id?: StringFilter | string
    listingId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutUser2Input = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutUser2Input, ConversationUncheckedUpdateWithoutUser2Input>
    create: XOR<ConversationCreateWithoutUser2Input, ConversationUncheckedCreateWithoutUser2Input>
  }

  export type ConversationUpdateWithWhereUniqueWithoutUser2Input = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutUser2Input, ConversationUncheckedUpdateWithoutUser2Input>
  }

  export type ConversationUpdateManyWithWhereWithoutUser2Input = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutConversationsReceivedInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSentMessagesInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter | string
    content?: StringNullableFilter | string | null
    senderId?: StringFilter | string
    conversationId?: StringFilter | string
    imageFileId?: StringNullableFilter | string | null
    read?: BoolFilter | boolean
    createdAt?: DateTimeFilter | Date | string
  }

  export type RatingUpsertWithWhereUniqueWithoutRaterInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutRaterInput, RatingUncheckedUpdateWithoutRaterInput>
    create: XOR<RatingCreateWithoutRaterInput, RatingUncheckedCreateWithoutRaterInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutRaterInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutRaterInput, RatingUncheckedUpdateWithoutRaterInput>
  }

  export type RatingUpdateManyWithWhereWithoutRaterInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutGivenRatingsInput>
  }

  export type RatingScalarWhereInput = {
    AND?: RatingScalarWhereInput | RatingScalarWhereInput[]
    OR?: RatingScalarWhereInput[]
    NOT?: RatingScalarWhereInput | RatingScalarWhereInput[]
    id?: StringFilter | string
    value?: IntFilter | number
    comment?: StringNullableFilter | string | null
    saleId?: StringFilter | string
    raterId?: StringFilter | string
    rateeId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    type?: StringFilter | string
  }

  export type RatingUpsertWithWhereUniqueWithoutRateeInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutRateeInput, RatingUncheckedUpdateWithoutRateeInput>
    create: XOR<RatingCreateWithoutRateeInput, RatingUncheckedCreateWithoutRateeInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutRateeInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutRateeInput, RatingUncheckedUpdateWithoutRateeInput>
  }

  export type RatingUpdateManyWithWhereWithoutRateeInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutReceivedRatingsInput>
  }

  export type SavedListingUpsertWithWhereUniqueWithoutUserInput = {
    where: SavedListingWhereUniqueInput
    update: XOR<SavedListingUpdateWithoutUserInput, SavedListingUncheckedUpdateWithoutUserInput>
    create: XOR<SavedListingCreateWithoutUserInput, SavedListingUncheckedCreateWithoutUserInput>
  }

  export type SavedListingUpdateWithWhereUniqueWithoutUserInput = {
    where: SavedListingWhereUniqueInput
    data: XOR<SavedListingUpdateWithoutUserInput, SavedListingUncheckedUpdateWithoutUserInput>
  }

  export type SavedListingUpdateManyWithWhereWithoutUserInput = {
    where: SavedListingScalarWhereInput
    data: XOR<SavedListingUpdateManyMutationInput, SavedListingUncheckedUpdateManyWithoutSavedListingsInput>
  }

  export type SavedListingScalarWhereInput = {
    AND?: SavedListingScalarWhereInput | SavedListingScalarWhereInput[]
    OR?: SavedListingScalarWhereInput[]
    NOT?: SavedListingScalarWhereInput | SavedListingScalarWhereInput[]
    id?: StringFilter | string
    userId?: StringFilter | string
    listingId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type ReportUpsertWithWhereUniqueWithoutReportedByInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutReportedByInput, ReportUncheckedUpdateWithoutReportedByInput>
    create: XOR<ReportCreateWithoutReportedByInput, ReportUncheckedCreateWithoutReportedByInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutReportedByInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutReportedByInput, ReportUncheckedUpdateWithoutReportedByInput>
  }

  export type ReportUpdateManyWithWhereWithoutReportedByInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReportsMadeInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter | string
    listingId?: StringFilter | string
    reportedById?: StringFilter | string
    reason?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
  }

  export type DocumentCreateWithoutOrganizationInput = {
    id?: string
    filename: string
    url: string
    uploadedBy: string
    createdAt?: Date | string
  }

  export type DocumentUncheckedCreateWithoutOrganizationInput = {
    id?: string
    filename: string
    url: string
    uploadedBy: string
    createdAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutOrganizationInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutOrganizationInput, DocumentUncheckedCreateWithoutOrganizationInput>
  }

  export type DocumentCreateManyOrganizationInputEnvelope = {
    data: DocumentCreateManyOrganizationInput | DocumentCreateManyOrganizationInput[]
  }

  export type DonationCreateWithoutOrganizationInput = {
    id?: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
    feedback?: FeedbackCreateNestedOneWithoutDonationInput
    dropPoint: DropPointCreateNestedOneWithoutDonationsInput
    peripherals?: PeripheralCreateNestedManyWithoutDonationInput
  }

  export type DonationUncheckedCreateWithoutOrganizationInput = {
    id?: string
    dropPointId: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
    feedback?: FeedbackUncheckedCreateNestedOneWithoutDonationInput
    peripherals?: PeripheralUncheckedCreateNestedManyWithoutDonationInput
  }

  export type DonationCreateOrConnectWithoutOrganizationInput = {
    where: DonationWhereUniqueInput
    create: XOR<DonationCreateWithoutOrganizationInput, DonationUncheckedCreateWithoutOrganizationInput>
  }

  export type DonationCreateManyOrganizationInputEnvelope = {
    data: DonationCreateManyOrganizationInput | DonationCreateManyOrganizationInput[]
  }

  export type AdvertisementCreateWithoutOrganizationInput = {
    id?: string
    title: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate?: Date | string
    expiryDate: Date | string
    city: CityCreateNestedOneWithoutAdvertisementsInput
    interactions?: AdInteractionCreateNestedManyWithoutAdvertisementInput
  }

  export type AdvertisementUncheckedCreateWithoutOrganizationInput = {
    id?: string
    cityId: string
    title: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate?: Date | string
    expiryDate: Date | string
    interactions?: AdInteractionUncheckedCreateNestedManyWithoutAdvertisementInput
  }

  export type AdvertisementCreateOrConnectWithoutOrganizationInput = {
    where: AdvertisementWhereUniqueInput
    create: XOR<AdvertisementCreateWithoutOrganizationInput, AdvertisementUncheckedCreateWithoutOrganizationInput>
  }

  export type AdvertisementCreateManyOrganizationInputEnvelope = {
    data: AdvertisementCreateManyOrganizationInput | AdvertisementCreateManyOrganizationInput[]
  }

  export type FeedbackCreateWithoutOrganizationInput = {
    id?: string
    content: string
    rating: number
    createdAt?: Date | string
    dropPoint: DropPointCreateNestedOneWithoutFeedbacksGivenInput
    donation: DonationCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateWithoutOrganizationInput = {
    id?: string
    content: string
    rating: number
    createdAt?: Date | string
    dropPointId: string
    donationId: string
  }

  export type FeedbackCreateOrConnectWithoutOrganizationInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutOrganizationInput, FeedbackUncheckedCreateWithoutOrganizationInput>
  }

  export type FeedbackCreateManyOrganizationInputEnvelope = {
    data: FeedbackCreateManyOrganizationInput | FeedbackCreateManyOrganizationInput[]
  }

  export type DocumentUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutOrganizationInput, DocumentUncheckedUpdateWithoutOrganizationInput>
    create: XOR<DocumentCreateWithoutOrganizationInput, DocumentUncheckedCreateWithoutOrganizationInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutOrganizationInput, DocumentUncheckedUpdateWithoutOrganizationInput>
  }

  export type DocumentUpdateManyWithWhereWithoutOrganizationInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutSubmittedDocumentsInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter | string
    filename?: StringFilter | string
    url?: StringFilter | string
    uploadedBy?: StringFilter | string
    organizationId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type DonationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: DonationWhereUniqueInput
    update: XOR<DonationUpdateWithoutOrganizationInput, DonationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<DonationCreateWithoutOrganizationInput, DonationUncheckedCreateWithoutOrganizationInput>
  }

  export type DonationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: DonationWhereUniqueInput
    data: XOR<DonationUpdateWithoutOrganizationInput, DonationUncheckedUpdateWithoutOrganizationInput>
  }

  export type DonationUpdateManyWithWhereWithoutOrganizationInput = {
    where: DonationScalarWhereInput
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyWithoutDonationsInput>
  }

  export type DonationScalarWhereInput = {
    AND?: DonationScalarWhereInput | DonationScalarWhereInput[]
    OR?: DonationScalarWhereInput[]
    NOT?: DonationScalarWhereInput | DonationScalarWhereInput[]
    id?: StringFilter | string
    organizationId?: StringFilter | string
    dropPointId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    expectedDateOfArrival?: DateTimeNullableFilter | Date | string | null
    confirmedByName?: StringNullableFilter | string | null
    confirmedByEmail?: StringNullableFilter | string | null
    status?: StringNullableFilter | string | null
    isSubmitted?: BoolFilter | boolean
    points?: FloatNullableFilter | number | null
  }

  export type AdvertisementUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: AdvertisementWhereUniqueInput
    update: XOR<AdvertisementUpdateWithoutOrganizationInput, AdvertisementUncheckedUpdateWithoutOrganizationInput>
    create: XOR<AdvertisementCreateWithoutOrganizationInput, AdvertisementUncheckedCreateWithoutOrganizationInput>
  }

  export type AdvertisementUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: AdvertisementWhereUniqueInput
    data: XOR<AdvertisementUpdateWithoutOrganizationInput, AdvertisementUncheckedUpdateWithoutOrganizationInput>
  }

  export type AdvertisementUpdateManyWithWhereWithoutOrganizationInput = {
    where: AdvertisementScalarWhereInput
    data: XOR<AdvertisementUpdateManyMutationInput, AdvertisementUncheckedUpdateManyWithoutAdvertisementsInput>
  }

  export type AdvertisementScalarWhereInput = {
    AND?: AdvertisementScalarWhereInput | AdvertisementScalarWhereInput[]
    OR?: AdvertisementScalarWhereInput[]
    NOT?: AdvertisementScalarWhereInput | AdvertisementScalarWhereInput[]
    id?: StringFilter | string
    organizationId?: StringFilter | string
    cityId?: StringFilter | string
    title?: StringFilter | string
    pointsSpent?: FloatFilter | number
    link?: StringFilter | string
    imageUrl?: BytesFilter | Buffer
    isActive?: BoolFilter | boolean
    startDate?: DateTimeFilter | Date | string
    expiryDate?: DateTimeFilter | Date | string
  }

  export type FeedbackUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutOrganizationInput, FeedbackUncheckedUpdateWithoutOrganizationInput>
    create: XOR<FeedbackCreateWithoutOrganizationInput, FeedbackUncheckedCreateWithoutOrganizationInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutOrganizationInput, FeedbackUncheckedUpdateWithoutOrganizationInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutOrganizationInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutFeedbacksGivenInput>
  }

  export type FeedbackScalarWhereInput = {
    AND?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    OR?: FeedbackScalarWhereInput[]
    NOT?: FeedbackScalarWhereInput | FeedbackScalarWhereInput[]
    id?: StringFilter | string
    content?: StringFilter | string
    rating?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    organizationId?: StringFilter | string
    dropPointId?: StringFilter | string
    donationId?: StringFilter | string
  }

  export type OrganizationCreateWithoutSubmittedDocumentsInput = {
    id?: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber?: string | null
    verificationStatus?: string
    lifetimePoints?: number
    totalPoints?: number
    type: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    donations?: DonationCreateNestedManyWithoutOrganizationInput
    advertisements?: AdvertisementCreateNestedManyWithoutOrganizationInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutSubmittedDocumentsInput = {
    id?: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber?: string | null
    verificationStatus?: string
    lifetimePoints?: number
    totalPoints?: number
    type: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    donations?: DonationUncheckedCreateNestedManyWithoutOrganizationInput
    advertisements?: AdvertisementUncheckedCreateNestedManyWithoutOrganizationInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutSubmittedDocumentsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSubmittedDocumentsInput, OrganizationUncheckedCreateWithoutSubmittedDocumentsInput>
  }

  export type OrganizationUpsertWithoutSubmittedDocumentsInput = {
    update: XOR<OrganizationUpdateWithoutSubmittedDocumentsInput, OrganizationUncheckedUpdateWithoutSubmittedDocumentsInput>
    create: XOR<OrganizationCreateWithoutSubmittedDocumentsInput, OrganizationUncheckedCreateWithoutSubmittedDocumentsInput>
  }

  export type OrganizationUpdateWithoutSubmittedDocumentsInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    lifetimePoints?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    donations?: DonationUpdateManyWithoutOrganizationNestedInput
    advertisements?: AdvertisementUpdateManyWithoutOrganizationNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutSubmittedDocumentsInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    lifetimePoints?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    donations?: DonationUncheckedUpdateManyWithoutOrganizationNestedInput
    advertisements?: AdvertisementUncheckedUpdateManyWithoutOrganizationNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ManagerCreateWithoutDropPointInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phoneNumber?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManagerUncheckedCreateWithoutDropPointInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phoneNumber?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManagerCreateOrConnectWithoutDropPointInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutDropPointInput, ManagerUncheckedCreateWithoutDropPointInput>
  }

  export type DonationCreateWithoutDropPointInput = {
    id?: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
    feedback?: FeedbackCreateNestedOneWithoutDonationInput
    organization: OrganizationCreateNestedOneWithoutDonationsInput
    peripherals?: PeripheralCreateNestedManyWithoutDonationInput
  }

  export type DonationUncheckedCreateWithoutDropPointInput = {
    id?: string
    organizationId: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
    feedback?: FeedbackUncheckedCreateNestedOneWithoutDonationInput
    peripherals?: PeripheralUncheckedCreateNestedManyWithoutDonationInput
  }

  export type DonationCreateOrConnectWithoutDropPointInput = {
    where: DonationWhereUniqueInput
    create: XOR<DonationCreateWithoutDropPointInput, DonationUncheckedCreateWithoutDropPointInput>
  }

  export type DonationCreateManyDropPointInputEnvelope = {
    data: DonationCreateManyDropPointInput | DonationCreateManyDropPointInput[]
  }

  export type FeedbackCreateWithoutDropPointInput = {
    id?: string
    content: string
    rating: number
    createdAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutFeedbacksGivenInput
    donation: DonationCreateNestedOneWithoutFeedbackInput
  }

  export type FeedbackUncheckedCreateWithoutDropPointInput = {
    id?: string
    content: string
    rating: number
    createdAt?: Date | string
    organizationId: string
    donationId: string
  }

  export type FeedbackCreateOrConnectWithoutDropPointInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutDropPointInput, FeedbackUncheckedCreateWithoutDropPointInput>
  }

  export type FeedbackCreateManyDropPointInputEnvelope = {
    data: FeedbackCreateManyDropPointInput | FeedbackCreateManyDropPointInput[]
  }

  export type ManagerUpsertWithoutDropPointInput = {
    update: XOR<ManagerUpdateWithoutDropPointInput, ManagerUncheckedUpdateWithoutDropPointInput>
    create: XOR<ManagerCreateWithoutDropPointInput, ManagerUncheckedCreateWithoutDropPointInput>
  }

  export type ManagerUpdateWithoutDropPointInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerUncheckedUpdateWithoutDropPointInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUpsertWithWhereUniqueWithoutDropPointInput = {
    where: DonationWhereUniqueInput
    update: XOR<DonationUpdateWithoutDropPointInput, DonationUncheckedUpdateWithoutDropPointInput>
    create: XOR<DonationCreateWithoutDropPointInput, DonationUncheckedCreateWithoutDropPointInput>
  }

  export type DonationUpdateWithWhereUniqueWithoutDropPointInput = {
    where: DonationWhereUniqueInput
    data: XOR<DonationUpdateWithoutDropPointInput, DonationUncheckedUpdateWithoutDropPointInput>
  }

  export type DonationUpdateManyWithWhereWithoutDropPointInput = {
    where: DonationScalarWhereInput
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyWithoutDonationsInput>
  }

  export type FeedbackUpsertWithWhereUniqueWithoutDropPointInput = {
    where: FeedbackWhereUniqueInput
    update: XOR<FeedbackUpdateWithoutDropPointInput, FeedbackUncheckedUpdateWithoutDropPointInput>
    create: XOR<FeedbackCreateWithoutDropPointInput, FeedbackUncheckedCreateWithoutDropPointInput>
  }

  export type FeedbackUpdateWithWhereUniqueWithoutDropPointInput = {
    where: FeedbackWhereUniqueInput
    data: XOR<FeedbackUpdateWithoutDropPointInput, FeedbackUncheckedUpdateWithoutDropPointInput>
  }

  export type FeedbackUpdateManyWithWhereWithoutDropPointInput = {
    where: FeedbackScalarWhereInput
    data: XOR<FeedbackUpdateManyMutationInput, FeedbackUncheckedUpdateManyWithoutFeedbacksGivenInput>
  }

  export type DropPointCreateWithoutManagerInput = {
    id?: string
    name: string
    location: string
    openingTime: string
    closingTime: string
    description: string
    password?: string | null
    donations?: DonationCreateNestedManyWithoutDropPointInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutDropPointInput
  }

  export type DropPointUncheckedCreateWithoutManagerInput = {
    id?: string
    name: string
    location: string
    openingTime: string
    closingTime: string
    description: string
    password?: string | null
    donations?: DonationUncheckedCreateNestedManyWithoutDropPointInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutDropPointInput
  }

  export type DropPointCreateOrConnectWithoutManagerInput = {
    where: DropPointWhereUniqueInput
    create: XOR<DropPointCreateWithoutManagerInput, DropPointUncheckedCreateWithoutManagerInput>
  }

  export type DropPointCreateManyManagerInputEnvelope = {
    data: DropPointCreateManyManagerInput | DropPointCreateManyManagerInput[]
  }

  export type DropPointUpsertWithWhereUniqueWithoutManagerInput = {
    where: DropPointWhereUniqueInput
    update: XOR<DropPointUpdateWithoutManagerInput, DropPointUncheckedUpdateWithoutManagerInput>
    create: XOR<DropPointCreateWithoutManagerInput, DropPointUncheckedCreateWithoutManagerInput>
  }

  export type DropPointUpdateWithWhereUniqueWithoutManagerInput = {
    where: DropPointWhereUniqueInput
    data: XOR<DropPointUpdateWithoutManagerInput, DropPointUncheckedUpdateWithoutManagerInput>
  }

  export type DropPointUpdateManyWithWhereWithoutManagerInput = {
    where: DropPointScalarWhereInput
    data: XOR<DropPointUpdateManyMutationInput, DropPointUncheckedUpdateManyWithoutDropPointInput>
  }

  export type DropPointScalarWhereInput = {
    AND?: DropPointScalarWhereInput | DropPointScalarWhereInput[]
    OR?: DropPointScalarWhereInput[]
    NOT?: DropPointScalarWhereInput | DropPointScalarWhereInput[]
    id?: StringFilter | string
    name?: StringFilter | string
    location?: StringFilter | string
    openingTime?: StringFilter | string
    closingTime?: StringFilter | string
    description?: StringFilter | string
    managerId?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
  }

  export type FeedbackCreateWithoutDonationInput = {
    id?: string
    content: string
    rating: number
    createdAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutFeedbacksGivenInput
    dropPoint: DropPointCreateNestedOneWithoutFeedbacksGivenInput
  }

  export type FeedbackUncheckedCreateWithoutDonationInput = {
    id?: string
    content: string
    rating: number
    createdAt?: Date | string
    organizationId: string
    dropPointId: string
  }

  export type FeedbackCreateOrConnectWithoutDonationInput = {
    where: FeedbackWhereUniqueInput
    create: XOR<FeedbackCreateWithoutDonationInput, FeedbackUncheckedCreateWithoutDonationInput>
  }

  export type OrganizationCreateWithoutDonationsInput = {
    id?: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber?: string | null
    verificationStatus?: string
    lifetimePoints?: number
    totalPoints?: number
    type: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    submittedDocuments?: DocumentCreateNestedManyWithoutOrganizationInput
    advertisements?: AdvertisementCreateNestedManyWithoutOrganizationInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutDonationsInput = {
    id?: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber?: string | null
    verificationStatus?: string
    lifetimePoints?: number
    totalPoints?: number
    type: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    submittedDocuments?: DocumentUncheckedCreateNestedManyWithoutOrganizationInput
    advertisements?: AdvertisementUncheckedCreateNestedManyWithoutOrganizationInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutDonationsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutDonationsInput, OrganizationUncheckedCreateWithoutDonationsInput>
  }

  export type DropPointCreateWithoutDonationsInput = {
    id?: string
    name: string
    location: string
    openingTime: string
    closingTime: string
    description: string
    password?: string | null
    manager?: ManagerCreateNestedOneWithoutDropPointInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutDropPointInput
  }

  export type DropPointUncheckedCreateWithoutDonationsInput = {
    id?: string
    name: string
    location: string
    openingTime: string
    closingTime: string
    description: string
    managerId?: string | null
    password?: string | null
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutDropPointInput
  }

  export type DropPointCreateOrConnectWithoutDonationsInput = {
    where: DropPointWhereUniqueInput
    create: XOR<DropPointCreateWithoutDonationsInput, DropPointUncheckedCreateWithoutDonationsInput>
  }

  export type PeripheralCreateWithoutDonationInput = {
    id?: string
    type: string
    brand: string
    model: string
    condition: string
    quantity?: number
  }

  export type PeripheralUncheckedCreateWithoutDonationInput = {
    id?: string
    type: string
    brand: string
    model: string
    condition: string
    quantity?: number
  }

  export type PeripheralCreateOrConnectWithoutDonationInput = {
    where: PeripheralWhereUniqueInput
    create: XOR<PeripheralCreateWithoutDonationInput, PeripheralUncheckedCreateWithoutDonationInput>
  }

  export type PeripheralCreateManyDonationInputEnvelope = {
    data: PeripheralCreateManyDonationInput | PeripheralCreateManyDonationInput[]
  }

  export type FeedbackUpsertWithoutDonationInput = {
    update: XOR<FeedbackUpdateWithoutDonationInput, FeedbackUncheckedUpdateWithoutDonationInput>
    create: XOR<FeedbackCreateWithoutDonationInput, FeedbackUncheckedCreateWithoutDonationInput>
  }

  export type FeedbackUpdateWithoutDonationInput = {
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutFeedbacksGivenNestedInput
    dropPoint?: DropPointUpdateOneRequiredWithoutFeedbacksGivenNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutDonationInput = {
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    dropPointId?: StringFieldUpdateOperationsInput | string
  }

  export type OrganizationUpsertWithoutDonationsInput = {
    update: XOR<OrganizationUpdateWithoutDonationsInput, OrganizationUncheckedUpdateWithoutDonationsInput>
    create: XOR<OrganizationCreateWithoutDonationsInput, OrganizationUncheckedCreateWithoutDonationsInput>
  }

  export type OrganizationUpdateWithoutDonationsInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    lifetimePoints?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedDocuments?: DocumentUpdateManyWithoutOrganizationNestedInput
    advertisements?: AdvertisementUpdateManyWithoutOrganizationNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutDonationsInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    lifetimePoints?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedDocuments?: DocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    advertisements?: AdvertisementUncheckedUpdateManyWithoutOrganizationNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type DropPointUpsertWithoutDonationsInput = {
    update: XOR<DropPointUpdateWithoutDonationsInput, DropPointUncheckedUpdateWithoutDonationsInput>
    create: XOR<DropPointCreateWithoutDonationsInput, DropPointUncheckedCreateWithoutDonationsInput>
  }

  export type DropPointUpdateWithoutDonationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    openingTime?: StringFieldUpdateOperationsInput | string
    closingTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: ManagerUpdateOneWithoutDropPointNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutDropPointNestedInput
  }

  export type DropPointUncheckedUpdateWithoutDonationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    openingTime?: StringFieldUpdateOperationsInput | string
    closingTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutDropPointNestedInput
  }

  export type PeripheralUpsertWithWhereUniqueWithoutDonationInput = {
    where: PeripheralWhereUniqueInput
    update: XOR<PeripheralUpdateWithoutDonationInput, PeripheralUncheckedUpdateWithoutDonationInput>
    create: XOR<PeripheralCreateWithoutDonationInput, PeripheralUncheckedCreateWithoutDonationInput>
  }

  export type PeripheralUpdateWithWhereUniqueWithoutDonationInput = {
    where: PeripheralWhereUniqueInput
    data: XOR<PeripheralUpdateWithoutDonationInput, PeripheralUncheckedUpdateWithoutDonationInput>
  }

  export type PeripheralUpdateManyWithWhereWithoutDonationInput = {
    where: PeripheralScalarWhereInput
    data: XOR<PeripheralUpdateManyMutationInput, PeripheralUncheckedUpdateManyWithoutPeripheralsInput>
  }

  export type PeripheralScalarWhereInput = {
    AND?: PeripheralScalarWhereInput | PeripheralScalarWhereInput[]
    OR?: PeripheralScalarWhereInput[]
    NOT?: PeripheralScalarWhereInput | PeripheralScalarWhereInput[]
    id?: StringFilter | string
    type?: StringFilter | string
    brand?: StringFilter | string
    model?: StringFilter | string
    condition?: StringFilter | string
    quantity?: IntFilter | number
    donationId?: StringFilter | string
  }

  export type OrganizationCreateWithoutFeedbacksGivenInput = {
    id?: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber?: string | null
    verificationStatus?: string
    lifetimePoints?: number
    totalPoints?: number
    type: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    submittedDocuments?: DocumentCreateNestedManyWithoutOrganizationInput
    donations?: DonationCreateNestedManyWithoutOrganizationInput
    advertisements?: AdvertisementCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutFeedbacksGivenInput = {
    id?: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber?: string | null
    verificationStatus?: string
    lifetimePoints?: number
    totalPoints?: number
    type: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    submittedDocuments?: DocumentUncheckedCreateNestedManyWithoutOrganizationInput
    donations?: DonationUncheckedCreateNestedManyWithoutOrganizationInput
    advertisements?: AdvertisementUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutFeedbacksGivenInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutFeedbacksGivenInput, OrganizationUncheckedCreateWithoutFeedbacksGivenInput>
  }

  export type DropPointCreateWithoutFeedbacksGivenInput = {
    id?: string
    name: string
    location: string
    openingTime: string
    closingTime: string
    description: string
    password?: string | null
    manager?: ManagerCreateNestedOneWithoutDropPointInput
    donations?: DonationCreateNestedManyWithoutDropPointInput
  }

  export type DropPointUncheckedCreateWithoutFeedbacksGivenInput = {
    id?: string
    name: string
    location: string
    openingTime: string
    closingTime: string
    description: string
    managerId?: string | null
    password?: string | null
    donations?: DonationUncheckedCreateNestedManyWithoutDropPointInput
  }

  export type DropPointCreateOrConnectWithoutFeedbacksGivenInput = {
    where: DropPointWhereUniqueInput
    create: XOR<DropPointCreateWithoutFeedbacksGivenInput, DropPointUncheckedCreateWithoutFeedbacksGivenInput>
  }

  export type DonationCreateWithoutFeedbackInput = {
    id?: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
    organization: OrganizationCreateNestedOneWithoutDonationsInput
    dropPoint: DropPointCreateNestedOneWithoutDonationsInput
    peripherals?: PeripheralCreateNestedManyWithoutDonationInput
  }

  export type DonationUncheckedCreateWithoutFeedbackInput = {
    id?: string
    organizationId: string
    dropPointId: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
    peripherals?: PeripheralUncheckedCreateNestedManyWithoutDonationInput
  }

  export type DonationCreateOrConnectWithoutFeedbackInput = {
    where: DonationWhereUniqueInput
    create: XOR<DonationCreateWithoutFeedbackInput, DonationUncheckedCreateWithoutFeedbackInput>
  }

  export type OrganizationUpsertWithoutFeedbacksGivenInput = {
    update: XOR<OrganizationUpdateWithoutFeedbacksGivenInput, OrganizationUncheckedUpdateWithoutFeedbacksGivenInput>
    create: XOR<OrganizationCreateWithoutFeedbacksGivenInput, OrganizationUncheckedCreateWithoutFeedbacksGivenInput>
  }

  export type OrganizationUpdateWithoutFeedbacksGivenInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    lifetimePoints?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedDocuments?: DocumentUpdateManyWithoutOrganizationNestedInput
    donations?: DonationUpdateManyWithoutOrganizationNestedInput
    advertisements?: AdvertisementUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutFeedbacksGivenInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    lifetimePoints?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedDocuments?: DocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    donations?: DonationUncheckedUpdateManyWithoutOrganizationNestedInput
    advertisements?: AdvertisementUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type DropPointUpsertWithoutFeedbacksGivenInput = {
    update: XOR<DropPointUpdateWithoutFeedbacksGivenInput, DropPointUncheckedUpdateWithoutFeedbacksGivenInput>
    create: XOR<DropPointCreateWithoutFeedbacksGivenInput, DropPointUncheckedCreateWithoutFeedbacksGivenInput>
  }

  export type DropPointUpdateWithoutFeedbacksGivenInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    openingTime?: StringFieldUpdateOperationsInput | string
    closingTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: ManagerUpdateOneWithoutDropPointNestedInput
    donations?: DonationUpdateManyWithoutDropPointNestedInput
  }

  export type DropPointUncheckedUpdateWithoutFeedbacksGivenInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    openingTime?: StringFieldUpdateOperationsInput | string
    closingTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    donations?: DonationUncheckedUpdateManyWithoutDropPointNestedInput
  }

  export type DonationUpsertWithoutFeedbackInput = {
    update: XOR<DonationUpdateWithoutFeedbackInput, DonationUncheckedUpdateWithoutFeedbackInput>
    create: XOR<DonationCreateWithoutFeedbackInput, DonationUncheckedCreateWithoutFeedbackInput>
  }

  export type DonationUpdateWithoutFeedbackInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneRequiredWithoutDonationsNestedInput
    dropPoint?: DropPointUpdateOneRequiredWithoutDonationsNestedInput
    peripherals?: PeripheralUpdateManyWithoutDonationNestedInput
  }

  export type DonationUncheckedUpdateWithoutFeedbackInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    dropPointId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
    peripherals?: PeripheralUncheckedUpdateManyWithoutDonationNestedInput
  }

  export type DonationCreateWithoutPeripheralsInput = {
    id?: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
    feedback?: FeedbackCreateNestedOneWithoutDonationInput
    organization: OrganizationCreateNestedOneWithoutDonationsInput
    dropPoint: DropPointCreateNestedOneWithoutDonationsInput
  }

  export type DonationUncheckedCreateWithoutPeripheralsInput = {
    id?: string
    organizationId: string
    dropPointId: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
    feedback?: FeedbackUncheckedCreateNestedOneWithoutDonationInput
  }

  export type DonationCreateOrConnectWithoutPeripheralsInput = {
    where: DonationWhereUniqueInput
    create: XOR<DonationCreateWithoutPeripheralsInput, DonationUncheckedCreateWithoutPeripheralsInput>
  }

  export type DonationUpsertWithoutPeripheralsInput = {
    update: XOR<DonationUpdateWithoutPeripheralsInput, DonationUncheckedUpdateWithoutPeripheralsInput>
    create: XOR<DonationCreateWithoutPeripheralsInput, DonationUncheckedCreateWithoutPeripheralsInput>
  }

  export type DonationUpdateWithoutPeripheralsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: FeedbackUpdateOneWithoutDonationNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutDonationsNestedInput
    dropPoint?: DropPointUpdateOneRequiredWithoutDonationsNestedInput
  }

  export type DonationUncheckedUpdateWithoutPeripheralsInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    dropPointId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: FeedbackUncheckedUpdateOneWithoutDonationNestedInput
  }

  export type UserCreateWithoutCityInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    listings?: ListingCreateNestedManyWithoutUserInput
    purchases?: SaleCreateNestedManyWithoutBuyerInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutUser1Input
    conversationsReceived?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    givenRatings?: RatingCreateNestedManyWithoutRaterInput
    receivedRatings?: RatingCreateNestedManyWithoutRateeInput
    savedListings?: SavedListingCreateNestedManyWithoutUserInput
    reportsMade?: ReportCreateNestedManyWithoutReportedByInput
  }

  export type UserUncheckedCreateWithoutCityInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    listings?: ListingUncheckedCreateNestedManyWithoutUserInput
    purchases?: SaleUncheckedCreateNestedManyWithoutBuyerInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    givenRatings?: RatingUncheckedCreateNestedManyWithoutRaterInput
    receivedRatings?: RatingUncheckedCreateNestedManyWithoutRateeInput
    savedListings?: SavedListingUncheckedCreateNestedManyWithoutUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReportedByInput
  }

  export type UserCreateOrConnectWithoutCityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput>
  }

  export type UserCreateManyCityInputEnvelope = {
    data: UserCreateManyCityInput | UserCreateManyCityInput[]
  }

  export type AdvertisementCreateWithoutCityInput = {
    id?: string
    title: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate?: Date | string
    expiryDate: Date | string
    organization: OrganizationCreateNestedOneWithoutAdvertisementsInput
    interactions?: AdInteractionCreateNestedManyWithoutAdvertisementInput
  }

  export type AdvertisementUncheckedCreateWithoutCityInput = {
    id?: string
    organizationId: string
    title: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate?: Date | string
    expiryDate: Date | string
    interactions?: AdInteractionUncheckedCreateNestedManyWithoutAdvertisementInput
  }

  export type AdvertisementCreateOrConnectWithoutCityInput = {
    where: AdvertisementWhereUniqueInput
    create: XOR<AdvertisementCreateWithoutCityInput, AdvertisementUncheckedCreateWithoutCityInput>
  }

  export type AdvertisementCreateManyCityInputEnvelope = {
    data: AdvertisementCreateManyCityInput | AdvertisementCreateManyCityInput[]
  }

  export type UserUpsertWithWhereUniqueWithoutCityInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCityInput, UserUncheckedUpdateWithoutCityInput>
    create: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCityInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCityInput, UserUncheckedUpdateWithoutCityInput>
  }

  export type UserUpdateManyWithWhereWithoutCityInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter | string
    email?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    password?: StringFilter | string
    cityId?: StringFilter | string
    gender?: StringFilter | string
    contactNumber?: StringFilter | string
    profilePicture?: BytesNullableFilter | Buffer | null
    createdAt?: DateTimeFilter | Date | string
    reportedListingCount?: IntFilter | number
  }

  export type AdvertisementUpsertWithWhereUniqueWithoutCityInput = {
    where: AdvertisementWhereUniqueInput
    update: XOR<AdvertisementUpdateWithoutCityInput, AdvertisementUncheckedUpdateWithoutCityInput>
    create: XOR<AdvertisementCreateWithoutCityInput, AdvertisementUncheckedCreateWithoutCityInput>
  }

  export type AdvertisementUpdateWithWhereUniqueWithoutCityInput = {
    where: AdvertisementWhereUniqueInput
    data: XOR<AdvertisementUpdateWithoutCityInput, AdvertisementUncheckedUpdateWithoutCityInput>
  }

  export type AdvertisementUpdateManyWithWhereWithoutCityInput = {
    where: AdvertisementScalarWhereInput
    data: XOR<AdvertisementUpdateManyMutationInput, AdvertisementUncheckedUpdateManyWithoutAdvertisementsInput>
  }

  export type OrganizationCreateWithoutAdvertisementsInput = {
    id?: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber?: string | null
    verificationStatus?: string
    lifetimePoints?: number
    totalPoints?: number
    type: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    submittedDocuments?: DocumentCreateNestedManyWithoutOrganizationInput
    donations?: DonationCreateNestedManyWithoutOrganizationInput
    feedbacksGiven?: FeedbackCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutAdvertisementsInput = {
    id?: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber?: string | null
    verificationStatus?: string
    lifetimePoints?: number
    totalPoints?: number
    type: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    submittedDocuments?: DocumentUncheckedCreateNestedManyWithoutOrganizationInput
    donations?: DonationUncheckedCreateNestedManyWithoutOrganizationInput
    feedbacksGiven?: FeedbackUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutAdvertisementsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutAdvertisementsInput, OrganizationUncheckedCreateWithoutAdvertisementsInput>
  }

  export type CityCreateWithoutAdvertisementsInput = {
    id?: string
    name: string
    users?: UserCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutAdvertisementsInput = {
    id?: string
    name: string
    users?: UserUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutAdvertisementsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutAdvertisementsInput, CityUncheckedCreateWithoutAdvertisementsInput>
  }

  export type AdInteractionCreateWithoutAdvertisementInput = {
    id?: string
    clickedAt?: Date | string
  }

  export type AdInteractionUncheckedCreateWithoutAdvertisementInput = {
    id?: string
    clickedAt?: Date | string
  }

  export type AdInteractionCreateOrConnectWithoutAdvertisementInput = {
    where: AdInteractionWhereUniqueInput
    create: XOR<AdInteractionCreateWithoutAdvertisementInput, AdInteractionUncheckedCreateWithoutAdvertisementInput>
  }

  export type AdInteractionCreateManyAdvertisementInputEnvelope = {
    data: AdInteractionCreateManyAdvertisementInput | AdInteractionCreateManyAdvertisementInput[]
  }

  export type OrganizationUpsertWithoutAdvertisementsInput = {
    update: XOR<OrganizationUpdateWithoutAdvertisementsInput, OrganizationUncheckedUpdateWithoutAdvertisementsInput>
    create: XOR<OrganizationCreateWithoutAdvertisementsInput, OrganizationUncheckedCreateWithoutAdvertisementsInput>
  }

  export type OrganizationUpdateWithoutAdvertisementsInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    lifetimePoints?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedDocuments?: DocumentUpdateManyWithoutOrganizationNestedInput
    donations?: DonationUpdateManyWithoutOrganizationNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutAdvertisementsInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    lifetimePoints?: FloatFieldUpdateOperationsInput | number
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedDocuments?: DocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    donations?: DonationUncheckedUpdateManyWithoutOrganizationNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type CityUpsertWithoutAdvertisementsInput = {
    update: XOR<CityUpdateWithoutAdvertisementsInput, CityUncheckedUpdateWithoutAdvertisementsInput>
    create: XOR<CityCreateWithoutAdvertisementsInput, CityUncheckedCreateWithoutAdvertisementsInput>
  }

  export type CityUpdateWithoutAdvertisementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutAdvertisementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
  }

  export type AdInteractionUpsertWithWhereUniqueWithoutAdvertisementInput = {
    where: AdInteractionWhereUniqueInput
    update: XOR<AdInteractionUpdateWithoutAdvertisementInput, AdInteractionUncheckedUpdateWithoutAdvertisementInput>
    create: XOR<AdInteractionCreateWithoutAdvertisementInput, AdInteractionUncheckedCreateWithoutAdvertisementInput>
  }

  export type AdInteractionUpdateWithWhereUniqueWithoutAdvertisementInput = {
    where: AdInteractionWhereUniqueInput
    data: XOR<AdInteractionUpdateWithoutAdvertisementInput, AdInteractionUncheckedUpdateWithoutAdvertisementInput>
  }

  export type AdInteractionUpdateManyWithWhereWithoutAdvertisementInput = {
    where: AdInteractionScalarWhereInput
    data: XOR<AdInteractionUpdateManyMutationInput, AdInteractionUncheckedUpdateManyWithoutInteractionsInput>
  }

  export type AdInteractionScalarWhereInput = {
    AND?: AdInteractionScalarWhereInput | AdInteractionScalarWhereInput[]
    OR?: AdInteractionScalarWhereInput[]
    NOT?: AdInteractionScalarWhereInput | AdInteractionScalarWhereInput[]
    id?: StringFilter | string
    advertisementId?: StringFilter | string
    clickedAt?: DateTimeFilter | Date | string
  }

  export type AdvertisementCreateWithoutInteractionsInput = {
    id?: string
    title: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate?: Date | string
    expiryDate: Date | string
    organization: OrganizationCreateNestedOneWithoutAdvertisementsInput
    city: CityCreateNestedOneWithoutAdvertisementsInput
  }

  export type AdvertisementUncheckedCreateWithoutInteractionsInput = {
    id?: string
    organizationId: string
    cityId: string
    title: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate?: Date | string
    expiryDate: Date | string
  }

  export type AdvertisementCreateOrConnectWithoutInteractionsInput = {
    where: AdvertisementWhereUniqueInput
    create: XOR<AdvertisementCreateWithoutInteractionsInput, AdvertisementUncheckedCreateWithoutInteractionsInput>
  }

  export type AdvertisementUpsertWithoutInteractionsInput = {
    update: XOR<AdvertisementUpdateWithoutInteractionsInput, AdvertisementUncheckedUpdateWithoutInteractionsInput>
    create: XOR<AdvertisementCreateWithoutInteractionsInput, AdvertisementUncheckedCreateWithoutInteractionsInput>
  }

  export type AdvertisementUpdateWithoutInteractionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAdvertisementsNestedInput
    city?: CityUpdateOneRequiredWithoutAdvertisementsNestedInput
  }

  export type AdvertisementUncheckedUpdateWithoutInteractionsInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoCreateWithoutListingInput = {
    id?: string
    imageUrl: Buffer
  }

  export type PhotoUncheckedCreateWithoutListingInput = {
    id?: string
    imageUrl: Buffer
  }

  export type PhotoCreateOrConnectWithoutListingInput = {
    where: PhotoWhereUniqueInput
    create: XOR<PhotoCreateWithoutListingInput, PhotoUncheckedCreateWithoutListingInput>
  }

  export type PhotoCreateManyListingInputEnvelope = {
    data: PhotoCreateManyListingInput | PhotoCreateManyListingInput[]
  }

  export type CategoryCreateWithoutListingsInput = {
    id?: string
    name: string
  }

  export type CategoryUncheckedCreateWithoutListingsInput = {
    id?: string
    name: string
  }

  export type CategoryCreateOrConnectWithoutListingsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutListingsInput, CategoryUncheckedCreateWithoutListingsInput>
  }

  export type ConditionCreateWithoutListingsInput = {
    id?: string
    name: string
  }

  export type ConditionUncheckedCreateWithoutListingsInput = {
    id?: string
    name: string
  }

  export type ConditionCreateOrConnectWithoutListingsInput = {
    where: ConditionWhereUniqueInput
    create: XOR<ConditionCreateWithoutListingsInput, ConditionUncheckedCreateWithoutListingsInput>
  }

  export type UserCreateWithoutListingsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    city: CityCreateNestedOneWithoutUsersInput
    purchases?: SaleCreateNestedManyWithoutBuyerInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutUser1Input
    conversationsReceived?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    givenRatings?: RatingCreateNestedManyWithoutRaterInput
    receivedRatings?: RatingCreateNestedManyWithoutRateeInput
    savedListings?: SavedListingCreateNestedManyWithoutUserInput
    reportsMade?: ReportCreateNestedManyWithoutReportedByInput
  }

  export type UserUncheckedCreateWithoutListingsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    cityId: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    purchases?: SaleUncheckedCreateNestedManyWithoutBuyerInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    givenRatings?: RatingUncheckedCreateNestedManyWithoutRaterInput
    receivedRatings?: RatingUncheckedCreateNestedManyWithoutRateeInput
    savedListings?: SavedListingUncheckedCreateNestedManyWithoutUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReportedByInput
  }

  export type UserCreateOrConnectWithoutListingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutListingsInput, UserUncheckedCreateWithoutListingsInput>
  }

  export type SaleCreateWithoutListingInput = {
    id?: string
    salePrice: number
    saleDate?: Date | string
    buyer: UserCreateNestedOneWithoutPurchasesInput
    conversation?: ConversationCreateNestedOneWithoutSaleInput
    rating?: RatingCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutListingInput = {
    id?: string
    buyerId: string
    conversationId?: string | null
    salePrice: number
    saleDate?: Date | string
    rating?: RatingUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutListingInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutListingInput, SaleUncheckedCreateWithoutListingInput>
  }

  export type SaleCreateManyListingInputEnvelope = {
    data: SaleCreateManyListingInput | SaleCreateManyListingInput[]
  }

  export type ConversationCreateWithoutListingInput = {
    id?: string
    createdAt?: Date | string
    user1: UserCreateNestedOneWithoutConversationsInitiatedInput
    user2: UserCreateNestedOneWithoutConversationsReceivedInput
    messages?: MessageCreateNestedManyWithoutConversationInput
    Sale?: SaleCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutListingInput = {
    id?: string
    user1Id: string
    user2Id: string
    createdAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
    Sale?: SaleUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutListingInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutListingInput, ConversationUncheckedCreateWithoutListingInput>
  }

  export type ConversationCreateManyListingInputEnvelope = {
    data: ConversationCreateManyListingInput | ConversationCreateManyListingInput[]
  }

  export type SavedListingCreateWithoutListingInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSavedListingsInput
  }

  export type SavedListingUncheckedCreateWithoutListingInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type SavedListingCreateOrConnectWithoutListingInput = {
    where: SavedListingWhereUniqueInput
    create: XOR<SavedListingCreateWithoutListingInput, SavedListingUncheckedCreateWithoutListingInput>
  }

  export type SavedListingCreateManyListingInputEnvelope = {
    data: SavedListingCreateManyListingInput | SavedListingCreateManyListingInput[]
  }

  export type ReportCreateWithoutListingInput = {
    id?: string
    reason: string
    createdAt?: Date | string
    reportedBy: UserCreateNestedOneWithoutReportsMadeInput
  }

  export type ReportUncheckedCreateWithoutListingInput = {
    id?: string
    reportedById: string
    reason: string
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutListingInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutListingInput, ReportUncheckedCreateWithoutListingInput>
  }

  export type ReportCreateManyListingInputEnvelope = {
    data: ReportCreateManyListingInput | ReportCreateManyListingInput[]
  }

  export type PhotoUpsertWithWhereUniqueWithoutListingInput = {
    where: PhotoWhereUniqueInput
    update: XOR<PhotoUpdateWithoutListingInput, PhotoUncheckedUpdateWithoutListingInput>
    create: XOR<PhotoCreateWithoutListingInput, PhotoUncheckedCreateWithoutListingInput>
  }

  export type PhotoUpdateWithWhereUniqueWithoutListingInput = {
    where: PhotoWhereUniqueInput
    data: XOR<PhotoUpdateWithoutListingInput, PhotoUncheckedUpdateWithoutListingInput>
  }

  export type PhotoUpdateManyWithWhereWithoutListingInput = {
    where: PhotoScalarWhereInput
    data: XOR<PhotoUpdateManyMutationInput, PhotoUncheckedUpdateManyWithoutPhotosInput>
  }

  export type PhotoScalarWhereInput = {
    AND?: PhotoScalarWhereInput | PhotoScalarWhereInput[]
    OR?: PhotoScalarWhereInput[]
    NOT?: PhotoScalarWhereInput | PhotoScalarWhereInput[]
    id?: StringFilter | string
    imageUrl?: BytesFilter | Buffer
    listingId?: StringFilter | string
  }

  export type CategoryUpsertWithoutListingsInput = {
    update: XOR<CategoryUpdateWithoutListingsInput, CategoryUncheckedUpdateWithoutListingsInput>
    create: XOR<CategoryCreateWithoutListingsInput, CategoryUncheckedCreateWithoutListingsInput>
  }

  export type CategoryUpdateWithoutListingsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateWithoutListingsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ConditionUpsertWithoutListingsInput = {
    update: XOR<ConditionUpdateWithoutListingsInput, ConditionUncheckedUpdateWithoutListingsInput>
    create: XOR<ConditionCreateWithoutListingsInput, ConditionUncheckedCreateWithoutListingsInput>
  }

  export type ConditionUpdateWithoutListingsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ConditionUncheckedUpdateWithoutListingsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutListingsInput = {
    update: XOR<UserUpdateWithoutListingsInput, UserUncheckedUpdateWithoutListingsInput>
    create: XOR<UserCreateWithoutListingsInput, UserUncheckedCreateWithoutListingsInput>
  }

  export type UserUpdateWithoutListingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    city?: CityUpdateOneRequiredWithoutUsersNestedInput
    purchases?: SaleUpdateManyWithoutBuyerNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsReceived?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    givenRatings?: RatingUpdateManyWithoutRaterNestedInput
    receivedRatings?: RatingUpdateManyWithoutRateeNestedInput
    savedListings?: SavedListingUpdateManyWithoutUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReportedByNestedInput
  }

  export type UserUncheckedUpdateWithoutListingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    purchases?: SaleUncheckedUpdateManyWithoutBuyerNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    givenRatings?: RatingUncheckedUpdateManyWithoutRaterNestedInput
    receivedRatings?: RatingUncheckedUpdateManyWithoutRateeNestedInput
    savedListings?: SavedListingUncheckedUpdateManyWithoutUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReportedByNestedInput
  }

  export type SaleUpsertWithWhereUniqueWithoutListingInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutListingInput, SaleUncheckedUpdateWithoutListingInput>
    create: XOR<SaleCreateWithoutListingInput, SaleUncheckedCreateWithoutListingInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutListingInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutListingInput, SaleUncheckedUpdateWithoutListingInput>
  }

  export type SaleUpdateManyWithWhereWithoutListingInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutSalesInput>
  }

  export type ConversationUpsertWithWhereUniqueWithoutListingInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutListingInput, ConversationUncheckedUpdateWithoutListingInput>
    create: XOR<ConversationCreateWithoutListingInput, ConversationUncheckedCreateWithoutListingInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutListingInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutListingInput, ConversationUncheckedUpdateWithoutListingInput>
  }

  export type ConversationUpdateManyWithWhereWithoutListingInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutConversationsInput>
  }

  export type SavedListingUpsertWithWhereUniqueWithoutListingInput = {
    where: SavedListingWhereUniqueInput
    update: XOR<SavedListingUpdateWithoutListingInput, SavedListingUncheckedUpdateWithoutListingInput>
    create: XOR<SavedListingCreateWithoutListingInput, SavedListingUncheckedCreateWithoutListingInput>
  }

  export type SavedListingUpdateWithWhereUniqueWithoutListingInput = {
    where: SavedListingWhereUniqueInput
    data: XOR<SavedListingUpdateWithoutListingInput, SavedListingUncheckedUpdateWithoutListingInput>
  }

  export type SavedListingUpdateManyWithWhereWithoutListingInput = {
    where: SavedListingScalarWhereInput
    data: XOR<SavedListingUpdateManyMutationInput, SavedListingUncheckedUpdateManyWithoutSavedByUsersInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutListingInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutListingInput, ReportUncheckedUpdateWithoutListingInput>
    create: XOR<ReportCreateWithoutListingInput, ReportUncheckedCreateWithoutListingInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutListingInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutListingInput, ReportUncheckedUpdateWithoutListingInput>
  }

  export type ReportUpdateManyWithWhereWithoutListingInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutReportsInput>
  }

  export type ListingCreateWithoutReportsInput = {
    id?: string
    title: string
    price: number
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    photos?: PhotoCreateNestedManyWithoutListingInput
    category: CategoryCreateNestedOneWithoutListingsInput
    condition: ConditionCreateNestedOneWithoutListingsInput
    user: UserCreateNestedOneWithoutListingsInput
    sales?: SaleCreateNestedManyWithoutListingInput
    conversations?: ConversationCreateNestedManyWithoutListingInput
    savedByUsers?: SavedListingCreateNestedManyWithoutListingInput
  }

  export type ListingUncheckedCreateWithoutReportsInput = {
    id?: string
    title: string
    price: number
    categoryId: string
    conditionId: string
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    status?: string
    photos?: PhotoUncheckedCreateNestedManyWithoutListingInput
    sales?: SaleUncheckedCreateNestedManyWithoutListingInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutListingInput
    savedByUsers?: SavedListingUncheckedCreateNestedManyWithoutListingInput
  }

  export type ListingCreateOrConnectWithoutReportsInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutReportsInput, ListingUncheckedCreateWithoutReportsInput>
  }

  export type UserCreateWithoutReportsMadeInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    city: CityCreateNestedOneWithoutUsersInput
    listings?: ListingCreateNestedManyWithoutUserInput
    purchases?: SaleCreateNestedManyWithoutBuyerInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutUser1Input
    conversationsReceived?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    givenRatings?: RatingCreateNestedManyWithoutRaterInput
    receivedRatings?: RatingCreateNestedManyWithoutRateeInput
    savedListings?: SavedListingCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReportsMadeInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    cityId: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    listings?: ListingUncheckedCreateNestedManyWithoutUserInput
    purchases?: SaleUncheckedCreateNestedManyWithoutBuyerInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    givenRatings?: RatingUncheckedCreateNestedManyWithoutRaterInput
    receivedRatings?: RatingUncheckedCreateNestedManyWithoutRateeInput
    savedListings?: SavedListingUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReportsMadeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsMadeInput, UserUncheckedCreateWithoutReportsMadeInput>
  }

  export type ListingUpsertWithoutReportsInput = {
    update: XOR<ListingUpdateWithoutReportsInput, ListingUncheckedUpdateWithoutReportsInput>
    create: XOR<ListingCreateWithoutReportsInput, ListingUncheckedCreateWithoutReportsInput>
  }

  export type ListingUpdateWithoutReportsInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUpdateManyWithoutListingNestedInput
    category?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    condition?: ConditionUpdateOneRequiredWithoutListingsNestedInput
    user?: UserUpdateOneRequiredWithoutListingsNestedInput
    sales?: SaleUpdateManyWithoutListingNestedInput
    conversations?: ConversationUpdateManyWithoutListingNestedInput
    savedByUsers?: SavedListingUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateWithoutReportsInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    conditionId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUncheckedUpdateManyWithoutListingNestedInput
    sales?: SaleUncheckedUpdateManyWithoutListingNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutListingNestedInput
    savedByUsers?: SavedListingUncheckedUpdateManyWithoutListingNestedInput
  }

  export type UserUpsertWithoutReportsMadeInput = {
    update: XOR<UserUpdateWithoutReportsMadeInput, UserUncheckedUpdateWithoutReportsMadeInput>
    create: XOR<UserCreateWithoutReportsMadeInput, UserUncheckedCreateWithoutReportsMadeInput>
  }

  export type UserUpdateWithoutReportsMadeInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    city?: CityUpdateOneRequiredWithoutUsersNestedInput
    listings?: ListingUpdateManyWithoutUserNestedInput
    purchases?: SaleUpdateManyWithoutBuyerNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsReceived?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    givenRatings?: RatingUpdateManyWithoutRaterNestedInput
    receivedRatings?: RatingUpdateManyWithoutRateeNestedInput
    savedListings?: SavedListingUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsMadeInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    listings?: ListingUncheckedUpdateManyWithoutUserNestedInput
    purchases?: SaleUncheckedUpdateManyWithoutBuyerNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    givenRatings?: RatingUncheckedUpdateManyWithoutRaterNestedInput
    receivedRatings?: RatingUncheckedUpdateManyWithoutRateeNestedInput
    savedListings?: SavedListingUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSavedListingsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    city: CityCreateNestedOneWithoutUsersInput
    listings?: ListingCreateNestedManyWithoutUserInput
    purchases?: SaleCreateNestedManyWithoutBuyerInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutUser1Input
    conversationsReceived?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    givenRatings?: RatingCreateNestedManyWithoutRaterInput
    receivedRatings?: RatingCreateNestedManyWithoutRateeInput
    reportsMade?: ReportCreateNestedManyWithoutReportedByInput
  }

  export type UserUncheckedCreateWithoutSavedListingsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    cityId: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    listings?: ListingUncheckedCreateNestedManyWithoutUserInput
    purchases?: SaleUncheckedCreateNestedManyWithoutBuyerInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    givenRatings?: RatingUncheckedCreateNestedManyWithoutRaterInput
    receivedRatings?: RatingUncheckedCreateNestedManyWithoutRateeInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReportedByInput
  }

  export type UserCreateOrConnectWithoutSavedListingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSavedListingsInput, UserUncheckedCreateWithoutSavedListingsInput>
  }

  export type ListingCreateWithoutSavedByUsersInput = {
    id?: string
    title: string
    price: number
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    photos?: PhotoCreateNestedManyWithoutListingInput
    category: CategoryCreateNestedOneWithoutListingsInput
    condition: ConditionCreateNestedOneWithoutListingsInput
    user: UserCreateNestedOneWithoutListingsInput
    sales?: SaleCreateNestedManyWithoutListingInput
    conversations?: ConversationCreateNestedManyWithoutListingInput
    reports?: ReportCreateNestedManyWithoutListingInput
  }

  export type ListingUncheckedCreateWithoutSavedByUsersInput = {
    id?: string
    title: string
    price: number
    categoryId: string
    conditionId: string
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    status?: string
    photos?: PhotoUncheckedCreateNestedManyWithoutListingInput
    sales?: SaleUncheckedCreateNestedManyWithoutListingInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutListingInput
    reports?: ReportUncheckedCreateNestedManyWithoutListingInput
  }

  export type ListingCreateOrConnectWithoutSavedByUsersInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutSavedByUsersInput, ListingUncheckedCreateWithoutSavedByUsersInput>
  }

  export type UserUpsertWithoutSavedListingsInput = {
    update: XOR<UserUpdateWithoutSavedListingsInput, UserUncheckedUpdateWithoutSavedListingsInput>
    create: XOR<UserCreateWithoutSavedListingsInput, UserUncheckedCreateWithoutSavedListingsInput>
  }

  export type UserUpdateWithoutSavedListingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    city?: CityUpdateOneRequiredWithoutUsersNestedInput
    listings?: ListingUpdateManyWithoutUserNestedInput
    purchases?: SaleUpdateManyWithoutBuyerNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsReceived?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    givenRatings?: RatingUpdateManyWithoutRaterNestedInput
    receivedRatings?: RatingUpdateManyWithoutRateeNestedInput
    reportsMade?: ReportUpdateManyWithoutReportedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSavedListingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    listings?: ListingUncheckedUpdateManyWithoutUserNestedInput
    purchases?: SaleUncheckedUpdateManyWithoutBuyerNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    givenRatings?: RatingUncheckedUpdateManyWithoutRaterNestedInput
    receivedRatings?: RatingUncheckedUpdateManyWithoutRateeNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReportedByNestedInput
  }

  export type ListingUpsertWithoutSavedByUsersInput = {
    update: XOR<ListingUpdateWithoutSavedByUsersInput, ListingUncheckedUpdateWithoutSavedByUsersInput>
    create: XOR<ListingCreateWithoutSavedByUsersInput, ListingUncheckedCreateWithoutSavedByUsersInput>
  }

  export type ListingUpdateWithoutSavedByUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUpdateManyWithoutListingNestedInput
    category?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    condition?: ConditionUpdateOneRequiredWithoutListingsNestedInput
    user?: UserUpdateOneRequiredWithoutListingsNestedInput
    sales?: SaleUpdateManyWithoutListingNestedInput
    conversations?: ConversationUpdateManyWithoutListingNestedInput
    reports?: ReportUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateWithoutSavedByUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    conditionId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUncheckedUpdateManyWithoutListingNestedInput
    sales?: SaleUncheckedUpdateManyWithoutListingNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutListingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutListingNestedInput
  }

  export type UserCreateWithoutPurchasesInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    city: CityCreateNestedOneWithoutUsersInput
    listings?: ListingCreateNestedManyWithoutUserInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutUser1Input
    conversationsReceived?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    givenRatings?: RatingCreateNestedManyWithoutRaterInput
    receivedRatings?: RatingCreateNestedManyWithoutRateeInput
    savedListings?: SavedListingCreateNestedManyWithoutUserInput
    reportsMade?: ReportCreateNestedManyWithoutReportedByInput
  }

  export type UserUncheckedCreateWithoutPurchasesInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    cityId: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    listings?: ListingUncheckedCreateNestedManyWithoutUserInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    givenRatings?: RatingUncheckedCreateNestedManyWithoutRaterInput
    receivedRatings?: RatingUncheckedCreateNestedManyWithoutRateeInput
    savedListings?: SavedListingUncheckedCreateNestedManyWithoutUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReportedByInput
  }

  export type UserCreateOrConnectWithoutPurchasesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
  }

  export type ListingCreateWithoutSalesInput = {
    id?: string
    title: string
    price: number
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    photos?: PhotoCreateNestedManyWithoutListingInput
    category: CategoryCreateNestedOneWithoutListingsInput
    condition: ConditionCreateNestedOneWithoutListingsInput
    user: UserCreateNestedOneWithoutListingsInput
    conversations?: ConversationCreateNestedManyWithoutListingInput
    savedByUsers?: SavedListingCreateNestedManyWithoutListingInput
    reports?: ReportCreateNestedManyWithoutListingInput
  }

  export type ListingUncheckedCreateWithoutSalesInput = {
    id?: string
    title: string
    price: number
    categoryId: string
    conditionId: string
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    status?: string
    photos?: PhotoUncheckedCreateNestedManyWithoutListingInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutListingInput
    savedByUsers?: SavedListingUncheckedCreateNestedManyWithoutListingInput
    reports?: ReportUncheckedCreateNestedManyWithoutListingInput
  }

  export type ListingCreateOrConnectWithoutSalesInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutSalesInput, ListingUncheckedCreateWithoutSalesInput>
  }

  export type ConversationCreateWithoutSaleInput = {
    id?: string
    createdAt?: Date | string
    user1: UserCreateNestedOneWithoutConversationsInitiatedInput
    user2: UserCreateNestedOneWithoutConversationsReceivedInput
    listing: ListingCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutSaleInput = {
    id?: string
    user1Id: string
    user2Id: string
    listingId: string
    createdAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutSaleInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutSaleInput, ConversationUncheckedCreateWithoutSaleInput>
  }

  export type RatingCreateWithoutSaleInput = {
    id?: string
    value: number
    comment?: string | null
    createdAt?: Date | string
    type: string
    rater: UserCreateNestedOneWithoutGivenRatingsInput
    ratee: UserCreateNestedOneWithoutReceivedRatingsInput
  }

  export type RatingUncheckedCreateWithoutSaleInput = {
    id?: string
    value: number
    comment?: string | null
    raterId: string
    rateeId: string
    createdAt?: Date | string
    type: string
  }

  export type RatingCreateOrConnectWithoutSaleInput = {
    where: RatingWhereUniqueInput
    create: XOR<RatingCreateWithoutSaleInput, RatingUncheckedCreateWithoutSaleInput>
  }

  export type RatingCreateManySaleInputEnvelope = {
    data: RatingCreateManySaleInput | RatingCreateManySaleInput[]
  }

  export type UserUpsertWithoutPurchasesInput = {
    update: XOR<UserUpdateWithoutPurchasesInput, UserUncheckedUpdateWithoutPurchasesInput>
    create: XOR<UserCreateWithoutPurchasesInput, UserUncheckedCreateWithoutPurchasesInput>
  }

  export type UserUpdateWithoutPurchasesInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    city?: CityUpdateOneRequiredWithoutUsersNestedInput
    listings?: ListingUpdateManyWithoutUserNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsReceived?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    givenRatings?: RatingUpdateManyWithoutRaterNestedInput
    receivedRatings?: RatingUpdateManyWithoutRateeNestedInput
    savedListings?: SavedListingUpdateManyWithoutUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReportedByNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchasesInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    listings?: ListingUncheckedUpdateManyWithoutUserNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    givenRatings?: RatingUncheckedUpdateManyWithoutRaterNestedInput
    receivedRatings?: RatingUncheckedUpdateManyWithoutRateeNestedInput
    savedListings?: SavedListingUncheckedUpdateManyWithoutUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReportedByNestedInput
  }

  export type ListingUpsertWithoutSalesInput = {
    update: XOR<ListingUpdateWithoutSalesInput, ListingUncheckedUpdateWithoutSalesInput>
    create: XOR<ListingCreateWithoutSalesInput, ListingUncheckedCreateWithoutSalesInput>
  }

  export type ListingUpdateWithoutSalesInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUpdateManyWithoutListingNestedInput
    category?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    condition?: ConditionUpdateOneRequiredWithoutListingsNestedInput
    user?: UserUpdateOneRequiredWithoutListingsNestedInput
    conversations?: ConversationUpdateManyWithoutListingNestedInput
    savedByUsers?: SavedListingUpdateManyWithoutListingNestedInput
    reports?: ReportUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateWithoutSalesInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    conditionId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUncheckedUpdateManyWithoutListingNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutListingNestedInput
    savedByUsers?: SavedListingUncheckedUpdateManyWithoutListingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutListingNestedInput
  }

  export type ConversationUpsertWithoutSaleInput = {
    update: XOR<ConversationUpdateWithoutSaleInput, ConversationUncheckedUpdateWithoutSaleInput>
    create: XOR<ConversationCreateWithoutSaleInput, ConversationUncheckedCreateWithoutSaleInput>
  }

  export type ConversationUpdateWithoutSaleInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user1?: UserUpdateOneRequiredWithoutConversationsInitiatedNestedInput
    user2?: UserUpdateOneRequiredWithoutConversationsReceivedNestedInput
    listing?: ListingUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutSaleInput = {
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type RatingUpsertWithWhereUniqueWithoutSaleInput = {
    where: RatingWhereUniqueInput
    update: XOR<RatingUpdateWithoutSaleInput, RatingUncheckedUpdateWithoutSaleInput>
    create: XOR<RatingCreateWithoutSaleInput, RatingUncheckedCreateWithoutSaleInput>
  }

  export type RatingUpdateWithWhereUniqueWithoutSaleInput = {
    where: RatingWhereUniqueInput
    data: XOR<RatingUpdateWithoutSaleInput, RatingUncheckedUpdateWithoutSaleInput>
  }

  export type RatingUpdateManyWithWhereWithoutSaleInput = {
    where: RatingScalarWhereInput
    data: XOR<RatingUpdateManyMutationInput, RatingUncheckedUpdateManyWithoutRatingInput>
  }

  export type SaleCreateWithoutRatingInput = {
    id?: string
    salePrice: number
    saleDate?: Date | string
    buyer: UserCreateNestedOneWithoutPurchasesInput
    listing: ListingCreateNestedOneWithoutSalesInput
    conversation?: ConversationCreateNestedOneWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutRatingInput = {
    id?: string
    buyerId: string
    listingId: string
    conversationId?: string | null
    salePrice: number
    saleDate?: Date | string
  }

  export type SaleCreateOrConnectWithoutRatingInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutRatingInput, SaleUncheckedCreateWithoutRatingInput>
  }

  export type UserCreateWithoutGivenRatingsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    city: CityCreateNestedOneWithoutUsersInput
    listings?: ListingCreateNestedManyWithoutUserInput
    purchases?: SaleCreateNestedManyWithoutBuyerInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutUser1Input
    conversationsReceived?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedRatings?: RatingCreateNestedManyWithoutRateeInput
    savedListings?: SavedListingCreateNestedManyWithoutUserInput
    reportsMade?: ReportCreateNestedManyWithoutReportedByInput
  }

  export type UserUncheckedCreateWithoutGivenRatingsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    cityId: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    listings?: ListingUncheckedCreateNestedManyWithoutUserInput
    purchases?: SaleUncheckedCreateNestedManyWithoutBuyerInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedRatings?: RatingUncheckedCreateNestedManyWithoutRateeInput
    savedListings?: SavedListingUncheckedCreateNestedManyWithoutUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReportedByInput
  }

  export type UserCreateOrConnectWithoutGivenRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGivenRatingsInput, UserUncheckedCreateWithoutGivenRatingsInput>
  }

  export type UserCreateWithoutReceivedRatingsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    city: CityCreateNestedOneWithoutUsersInput
    listings?: ListingCreateNestedManyWithoutUserInput
    purchases?: SaleCreateNestedManyWithoutBuyerInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutUser1Input
    conversationsReceived?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    givenRatings?: RatingCreateNestedManyWithoutRaterInput
    savedListings?: SavedListingCreateNestedManyWithoutUserInput
    reportsMade?: ReportCreateNestedManyWithoutReportedByInput
  }

  export type UserUncheckedCreateWithoutReceivedRatingsInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    cityId: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    listings?: ListingUncheckedCreateNestedManyWithoutUserInput
    purchases?: SaleUncheckedCreateNestedManyWithoutBuyerInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    givenRatings?: RatingUncheckedCreateNestedManyWithoutRaterInput
    savedListings?: SavedListingUncheckedCreateNestedManyWithoutUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReportedByInput
  }

  export type UserCreateOrConnectWithoutReceivedRatingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedRatingsInput, UserUncheckedCreateWithoutReceivedRatingsInput>
  }

  export type SaleUpsertWithoutRatingInput = {
    update: XOR<SaleUpdateWithoutRatingInput, SaleUncheckedUpdateWithoutRatingInput>
    create: XOR<SaleCreateWithoutRatingInput, SaleUncheckedCreateWithoutRatingInput>
  }

  export type SaleUpdateWithoutRatingInput = {
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    buyer?: UserUpdateOneRequiredWithoutPurchasesNestedInput
    listing?: ListingUpdateOneRequiredWithoutSalesNestedInput
    conversation?: ConversationUpdateOneWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutRatingInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutGivenRatingsInput = {
    update: XOR<UserUpdateWithoutGivenRatingsInput, UserUncheckedUpdateWithoutGivenRatingsInput>
    create: XOR<UserCreateWithoutGivenRatingsInput, UserUncheckedCreateWithoutGivenRatingsInput>
  }

  export type UserUpdateWithoutGivenRatingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    city?: CityUpdateOneRequiredWithoutUsersNestedInput
    listings?: ListingUpdateManyWithoutUserNestedInput
    purchases?: SaleUpdateManyWithoutBuyerNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsReceived?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedRatings?: RatingUpdateManyWithoutRateeNestedInput
    savedListings?: SavedListingUpdateManyWithoutUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReportedByNestedInput
  }

  export type UserUncheckedUpdateWithoutGivenRatingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    listings?: ListingUncheckedUpdateManyWithoutUserNestedInput
    purchases?: SaleUncheckedUpdateManyWithoutBuyerNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedRatings?: RatingUncheckedUpdateManyWithoutRateeNestedInput
    savedListings?: SavedListingUncheckedUpdateManyWithoutUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReportedByNestedInput
  }

  export type UserUpsertWithoutReceivedRatingsInput = {
    update: XOR<UserUpdateWithoutReceivedRatingsInput, UserUncheckedUpdateWithoutReceivedRatingsInput>
    create: XOR<UserCreateWithoutReceivedRatingsInput, UserUncheckedCreateWithoutReceivedRatingsInput>
  }

  export type UserUpdateWithoutReceivedRatingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    city?: CityUpdateOneRequiredWithoutUsersNestedInput
    listings?: ListingUpdateManyWithoutUserNestedInput
    purchases?: SaleUpdateManyWithoutBuyerNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsReceived?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    givenRatings?: RatingUpdateManyWithoutRaterNestedInput
    savedListings?: SavedListingUpdateManyWithoutUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReportedByNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedRatingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    listings?: ListingUncheckedUpdateManyWithoutUserNestedInput
    purchases?: SaleUncheckedUpdateManyWithoutBuyerNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    givenRatings?: RatingUncheckedUpdateManyWithoutRaterNestedInput
    savedListings?: SavedListingUncheckedUpdateManyWithoutUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReportedByNestedInput
  }

  export type ListingCreateWithoutPhotosInput = {
    id?: string
    title: string
    price: number
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    category: CategoryCreateNestedOneWithoutListingsInput
    condition: ConditionCreateNestedOneWithoutListingsInput
    user: UserCreateNestedOneWithoutListingsInput
    sales?: SaleCreateNestedManyWithoutListingInput
    conversations?: ConversationCreateNestedManyWithoutListingInput
    savedByUsers?: SavedListingCreateNestedManyWithoutListingInput
    reports?: ReportCreateNestedManyWithoutListingInput
  }

  export type ListingUncheckedCreateWithoutPhotosInput = {
    id?: string
    title: string
    price: number
    categoryId: string
    conditionId: string
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    status?: string
    sales?: SaleUncheckedCreateNestedManyWithoutListingInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutListingInput
    savedByUsers?: SavedListingUncheckedCreateNestedManyWithoutListingInput
    reports?: ReportUncheckedCreateNestedManyWithoutListingInput
  }

  export type ListingCreateOrConnectWithoutPhotosInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutPhotosInput, ListingUncheckedCreateWithoutPhotosInput>
  }

  export type ListingUpsertWithoutPhotosInput = {
    update: XOR<ListingUpdateWithoutPhotosInput, ListingUncheckedUpdateWithoutPhotosInput>
    create: XOR<ListingCreateWithoutPhotosInput, ListingUncheckedCreateWithoutPhotosInput>
  }

  export type ListingUpdateWithoutPhotosInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    category?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    condition?: ConditionUpdateOneRequiredWithoutListingsNestedInput
    user?: UserUpdateOneRequiredWithoutListingsNestedInput
    sales?: SaleUpdateManyWithoutListingNestedInput
    conversations?: ConversationUpdateManyWithoutListingNestedInput
    savedByUsers?: SavedListingUpdateManyWithoutListingNestedInput
    reports?: ReportUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateWithoutPhotosInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    conditionId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    sales?: SaleUncheckedUpdateManyWithoutListingNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutListingNestedInput
    savedByUsers?: SavedListingUncheckedUpdateManyWithoutListingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutListingNestedInput
  }

  export type ListingCreateWithoutCategoryInput = {
    id?: string
    title: string
    price: number
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    photos?: PhotoCreateNestedManyWithoutListingInput
    condition: ConditionCreateNestedOneWithoutListingsInput
    user: UserCreateNestedOneWithoutListingsInput
    sales?: SaleCreateNestedManyWithoutListingInput
    conversations?: ConversationCreateNestedManyWithoutListingInput
    savedByUsers?: SavedListingCreateNestedManyWithoutListingInput
    reports?: ReportCreateNestedManyWithoutListingInput
  }

  export type ListingUncheckedCreateWithoutCategoryInput = {
    id?: string
    title: string
    price: number
    conditionId: string
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    status?: string
    photos?: PhotoUncheckedCreateNestedManyWithoutListingInput
    sales?: SaleUncheckedCreateNestedManyWithoutListingInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutListingInput
    savedByUsers?: SavedListingUncheckedCreateNestedManyWithoutListingInput
    reports?: ReportUncheckedCreateNestedManyWithoutListingInput
  }

  export type ListingCreateOrConnectWithoutCategoryInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutCategoryInput, ListingUncheckedCreateWithoutCategoryInput>
  }

  export type ListingCreateManyCategoryInputEnvelope = {
    data: ListingCreateManyCategoryInput | ListingCreateManyCategoryInput[]
  }

  export type ListingUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ListingWhereUniqueInput
    update: XOR<ListingUpdateWithoutCategoryInput, ListingUncheckedUpdateWithoutCategoryInput>
    create: XOR<ListingCreateWithoutCategoryInput, ListingUncheckedCreateWithoutCategoryInput>
  }

  export type ListingUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ListingWhereUniqueInput
    data: XOR<ListingUpdateWithoutCategoryInput, ListingUncheckedUpdateWithoutCategoryInput>
  }

  export type ListingUpdateManyWithWhereWithoutCategoryInput = {
    where: ListingScalarWhereInput
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyWithoutListingsInput>
  }

  export type ListingCreateWithoutConditionInput = {
    id?: string
    title: string
    price: number
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    photos?: PhotoCreateNestedManyWithoutListingInput
    category: CategoryCreateNestedOneWithoutListingsInput
    user: UserCreateNestedOneWithoutListingsInput
    sales?: SaleCreateNestedManyWithoutListingInput
    conversations?: ConversationCreateNestedManyWithoutListingInput
    savedByUsers?: SavedListingCreateNestedManyWithoutListingInput
    reports?: ReportCreateNestedManyWithoutListingInput
  }

  export type ListingUncheckedCreateWithoutConditionInput = {
    id?: string
    title: string
    price: number
    categoryId: string
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    status?: string
    photos?: PhotoUncheckedCreateNestedManyWithoutListingInput
    sales?: SaleUncheckedCreateNestedManyWithoutListingInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutListingInput
    savedByUsers?: SavedListingUncheckedCreateNestedManyWithoutListingInput
    reports?: ReportUncheckedCreateNestedManyWithoutListingInput
  }

  export type ListingCreateOrConnectWithoutConditionInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutConditionInput, ListingUncheckedCreateWithoutConditionInput>
  }

  export type ListingCreateManyConditionInputEnvelope = {
    data: ListingCreateManyConditionInput | ListingCreateManyConditionInput[]
  }

  export type ListingUpsertWithWhereUniqueWithoutConditionInput = {
    where: ListingWhereUniqueInput
    update: XOR<ListingUpdateWithoutConditionInput, ListingUncheckedUpdateWithoutConditionInput>
    create: XOR<ListingCreateWithoutConditionInput, ListingUncheckedCreateWithoutConditionInput>
  }

  export type ListingUpdateWithWhereUniqueWithoutConditionInput = {
    where: ListingWhereUniqueInput
    data: XOR<ListingUpdateWithoutConditionInput, ListingUncheckedUpdateWithoutConditionInput>
  }

  export type ListingUpdateManyWithWhereWithoutConditionInput = {
    where: ListingScalarWhereInput
    data: XOR<ListingUpdateManyMutationInput, ListingUncheckedUpdateManyWithoutListingsInput>
  }

  export type UserCreateWithoutConversationsInitiatedInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    city: CityCreateNestedOneWithoutUsersInput
    listings?: ListingCreateNestedManyWithoutUserInput
    purchases?: SaleCreateNestedManyWithoutBuyerInput
    conversationsReceived?: ConversationCreateNestedManyWithoutUser2Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    givenRatings?: RatingCreateNestedManyWithoutRaterInput
    receivedRatings?: RatingCreateNestedManyWithoutRateeInput
    savedListings?: SavedListingCreateNestedManyWithoutUserInput
    reportsMade?: ReportCreateNestedManyWithoutReportedByInput
  }

  export type UserUncheckedCreateWithoutConversationsInitiatedInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    cityId: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    listings?: ListingUncheckedCreateNestedManyWithoutUserInput
    purchases?: SaleUncheckedCreateNestedManyWithoutBuyerInput
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    givenRatings?: RatingUncheckedCreateNestedManyWithoutRaterInput
    receivedRatings?: RatingUncheckedCreateNestedManyWithoutRateeInput
    savedListings?: SavedListingUncheckedCreateNestedManyWithoutUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReportedByInput
  }

  export type UserCreateOrConnectWithoutConversationsInitiatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsInitiatedInput, UserUncheckedCreateWithoutConversationsInitiatedInput>
  }

  export type UserCreateWithoutConversationsReceivedInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    city: CityCreateNestedOneWithoutUsersInput
    listings?: ListingCreateNestedManyWithoutUserInput
    purchases?: SaleCreateNestedManyWithoutBuyerInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutUser1Input
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    givenRatings?: RatingCreateNestedManyWithoutRaterInput
    receivedRatings?: RatingCreateNestedManyWithoutRateeInput
    savedListings?: SavedListingCreateNestedManyWithoutUserInput
    reportsMade?: ReportCreateNestedManyWithoutReportedByInput
  }

  export type UserUncheckedCreateWithoutConversationsReceivedInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    cityId: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    listings?: ListingUncheckedCreateNestedManyWithoutUserInput
    purchases?: SaleUncheckedCreateNestedManyWithoutBuyerInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    givenRatings?: RatingUncheckedCreateNestedManyWithoutRaterInput
    receivedRatings?: RatingUncheckedCreateNestedManyWithoutRateeInput
    savedListings?: SavedListingUncheckedCreateNestedManyWithoutUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReportedByInput
  }

  export type UserCreateOrConnectWithoutConversationsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsReceivedInput, UserUncheckedCreateWithoutConversationsReceivedInput>
  }

  export type ListingCreateWithoutConversationsInput = {
    id?: string
    title: string
    price: number
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
    photos?: PhotoCreateNestedManyWithoutListingInput
    category: CategoryCreateNestedOneWithoutListingsInput
    condition: ConditionCreateNestedOneWithoutListingsInput
    user: UserCreateNestedOneWithoutListingsInput
    sales?: SaleCreateNestedManyWithoutListingInput
    savedByUsers?: SavedListingCreateNestedManyWithoutListingInput
    reports?: ReportCreateNestedManyWithoutListingInput
  }

  export type ListingUncheckedCreateWithoutConversationsInput = {
    id?: string
    title: string
    price: number
    categoryId: string
    conditionId: string
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    status?: string
    photos?: PhotoUncheckedCreateNestedManyWithoutListingInput
    sales?: SaleUncheckedCreateNestedManyWithoutListingInput
    savedByUsers?: SavedListingUncheckedCreateNestedManyWithoutListingInput
    reports?: ReportUncheckedCreateNestedManyWithoutListingInput
  }

  export type ListingCreateOrConnectWithoutConversationsInput = {
    where: ListingWhereUniqueInput
    create: XOR<ListingCreateWithoutConversationsInput, ListingUncheckedCreateWithoutConversationsInput>
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    content?: string | null
    imageFileId?: string | null
    read?: boolean
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    content?: string | null
    senderId: string
    imageFileId?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
  }

  export type SaleCreateWithoutConversationInput = {
    id?: string
    salePrice: number
    saleDate?: Date | string
    buyer: UserCreateNestedOneWithoutPurchasesInput
    listing: ListingCreateNestedOneWithoutSalesInput
    rating?: RatingCreateNestedManyWithoutSaleInput
  }

  export type SaleUncheckedCreateWithoutConversationInput = {
    id?: string
    buyerId: string
    listingId: string
    salePrice: number
    saleDate?: Date | string
    rating?: RatingUncheckedCreateNestedManyWithoutSaleInput
  }

  export type SaleCreateOrConnectWithoutConversationInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutConversationInput, SaleUncheckedCreateWithoutConversationInput>
  }

  export type SaleCreateManyConversationInputEnvelope = {
    data: SaleCreateManyConversationInput | SaleCreateManyConversationInput[]
  }

  export type UserUpsertWithoutConversationsInitiatedInput = {
    update: XOR<UserUpdateWithoutConversationsInitiatedInput, UserUncheckedUpdateWithoutConversationsInitiatedInput>
    create: XOR<UserCreateWithoutConversationsInitiatedInput, UserUncheckedCreateWithoutConversationsInitiatedInput>
  }

  export type UserUpdateWithoutConversationsInitiatedInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    city?: CityUpdateOneRequiredWithoutUsersNestedInput
    listings?: ListingUpdateManyWithoutUserNestedInput
    purchases?: SaleUpdateManyWithoutBuyerNestedInput
    conversationsReceived?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    givenRatings?: RatingUpdateManyWithoutRaterNestedInput
    receivedRatings?: RatingUpdateManyWithoutRateeNestedInput
    savedListings?: SavedListingUpdateManyWithoutUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReportedByNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsInitiatedInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    listings?: ListingUncheckedUpdateManyWithoutUserNestedInput
    purchases?: SaleUncheckedUpdateManyWithoutBuyerNestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    givenRatings?: RatingUncheckedUpdateManyWithoutRaterNestedInput
    receivedRatings?: RatingUncheckedUpdateManyWithoutRateeNestedInput
    savedListings?: SavedListingUncheckedUpdateManyWithoutUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReportedByNestedInput
  }

  export type UserUpsertWithoutConversationsReceivedInput = {
    update: XOR<UserUpdateWithoutConversationsReceivedInput, UserUncheckedUpdateWithoutConversationsReceivedInput>
    create: XOR<UserCreateWithoutConversationsReceivedInput, UserUncheckedCreateWithoutConversationsReceivedInput>
  }

  export type UserUpdateWithoutConversationsReceivedInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    city?: CityUpdateOneRequiredWithoutUsersNestedInput
    listings?: ListingUpdateManyWithoutUserNestedInput
    purchases?: SaleUpdateManyWithoutBuyerNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutUser1NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    givenRatings?: RatingUpdateManyWithoutRaterNestedInput
    receivedRatings?: RatingUpdateManyWithoutRateeNestedInput
    savedListings?: SavedListingUpdateManyWithoutUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReportedByNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsReceivedInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    listings?: ListingUncheckedUpdateManyWithoutUserNestedInput
    purchases?: SaleUncheckedUpdateManyWithoutBuyerNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    givenRatings?: RatingUncheckedUpdateManyWithoutRaterNestedInput
    receivedRatings?: RatingUncheckedUpdateManyWithoutRateeNestedInput
    savedListings?: SavedListingUncheckedUpdateManyWithoutUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReportedByNestedInput
  }

  export type ListingUpsertWithoutConversationsInput = {
    update: XOR<ListingUpdateWithoutConversationsInput, ListingUncheckedUpdateWithoutConversationsInput>
    create: XOR<ListingCreateWithoutConversationsInput, ListingUncheckedCreateWithoutConversationsInput>
  }

  export type ListingUpdateWithoutConversationsInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUpdateManyWithoutListingNestedInput
    category?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    condition?: ConditionUpdateOneRequiredWithoutListingsNestedInput
    user?: UserUpdateOneRequiredWithoutListingsNestedInput
    sales?: SaleUpdateManyWithoutListingNestedInput
    savedByUsers?: SavedListingUpdateManyWithoutListingNestedInput
    reports?: ReportUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateWithoutConversationsInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    conditionId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUncheckedUpdateManyWithoutListingNestedInput
    sales?: SaleUncheckedUpdateManyWithoutListingNestedInput
    savedByUsers?: SavedListingUncheckedUpdateManyWithoutListingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutListingNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutMessagesInput>
  }

  export type SaleUpsertWithWhereUniqueWithoutConversationInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutConversationInput, SaleUncheckedUpdateWithoutConversationInput>
    create: XOR<SaleCreateWithoutConversationInput, SaleUncheckedCreateWithoutConversationInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutConversationInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutConversationInput, SaleUncheckedUpdateWithoutConversationInput>
  }

  export type SaleUpdateManyWithWhereWithoutConversationInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutSaleInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    city: CityCreateNestedOneWithoutUsersInput
    listings?: ListingCreateNestedManyWithoutUserInput
    purchases?: SaleCreateNestedManyWithoutBuyerInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutUser1Input
    conversationsReceived?: ConversationCreateNestedManyWithoutUser2Input
    givenRatings?: RatingCreateNestedManyWithoutRaterInput
    receivedRatings?: RatingCreateNestedManyWithoutRateeInput
    savedListings?: SavedListingCreateNestedManyWithoutUserInput
    reportsMade?: ReportCreateNestedManyWithoutReportedByInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    cityId: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
    listings?: ListingUncheckedCreateNestedManyWithoutUserInput
    purchases?: SaleUncheckedCreateNestedManyWithoutBuyerInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutUser1Input
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutUser2Input
    givenRatings?: RatingUncheckedCreateNestedManyWithoutRaterInput
    receivedRatings?: RatingUncheckedCreateNestedManyWithoutRateeInput
    savedListings?: SavedListingUncheckedCreateNestedManyWithoutUserInput
    reportsMade?: ReportUncheckedCreateNestedManyWithoutReportedByInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    user1: UserCreateNestedOneWithoutConversationsInitiatedInput
    user2: UserCreateNestedOneWithoutConversationsReceivedInput
    listing: ListingCreateNestedOneWithoutConversationsInput
    Sale?: SaleCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    user1Id: string
    user2Id: string
    listingId: string
    createdAt?: Date | string
    Sale?: SaleUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    city?: CityUpdateOneRequiredWithoutUsersNestedInput
    listings?: ListingUpdateManyWithoutUserNestedInput
    purchases?: SaleUpdateManyWithoutBuyerNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsReceived?: ConversationUpdateManyWithoutUser2NestedInput
    givenRatings?: RatingUpdateManyWithoutRaterNestedInput
    receivedRatings?: RatingUpdateManyWithoutRateeNestedInput
    savedListings?: SavedListingUpdateManyWithoutUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReportedByNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    listings?: ListingUncheckedUpdateManyWithoutUserNestedInput
    purchases?: SaleUncheckedUpdateManyWithoutBuyerNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    givenRatings?: RatingUncheckedUpdateManyWithoutRaterNestedInput
    receivedRatings?: RatingUncheckedUpdateManyWithoutRateeNestedInput
    savedListings?: SavedListingUncheckedUpdateManyWithoutUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReportedByNestedInput
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user1?: UserUpdateOneRequiredWithoutConversationsInitiatedNestedInput
    user2?: UserUpdateOneRequiredWithoutConversationsReceivedNestedInput
    listing?: ListingUpdateOneRequiredWithoutConversationsNestedInput
    Sale?: SaleUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Sale?: SaleUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ListingCreateManyUserInput = {
    id?: string
    title: string
    price: number
    categoryId: string
    conditionId: string
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: string
  }

  export type SaleCreateManyBuyerInput = {
    id?: string
    listingId: string
    conversationId?: string | null
    salePrice: number
    saleDate?: Date | string
  }

  export type ConversationCreateManyUser1Input = {
    id?: string
    user2Id: string
    listingId: string
    createdAt?: Date | string
  }

  export type ConversationCreateManyUser2Input = {
    id?: string
    user1Id: string
    listingId: string
    createdAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    content?: string | null
    conversationId: string
    imageFileId?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type RatingCreateManyRaterInput = {
    id?: string
    value: number
    comment?: string | null
    saleId: string
    rateeId: string
    createdAt?: Date | string
    type: string
  }

  export type RatingCreateManyRateeInput = {
    id?: string
    value: number
    comment?: string | null
    saleId: string
    raterId: string
    createdAt?: Date | string
    type: string
  }

  export type SavedListingCreateManyUserInput = {
    id?: string
    listingId: string
    createdAt?: Date | string
  }

  export type ReportCreateManyReportedByInput = {
    id?: string
    listingId: string
    reason: string
    createdAt?: Date | string
  }

  export type ListingUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUpdateManyWithoutListingNestedInput
    category?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    condition?: ConditionUpdateOneRequiredWithoutListingsNestedInput
    sales?: SaleUpdateManyWithoutListingNestedInput
    conversations?: ConversationUpdateManyWithoutListingNestedInput
    savedByUsers?: SavedListingUpdateManyWithoutListingNestedInput
    reports?: ReportUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    conditionId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUncheckedUpdateManyWithoutListingNestedInput
    sales?: SaleUncheckedUpdateManyWithoutListingNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutListingNestedInput
    savedByUsers?: SavedListingUncheckedUpdateManyWithoutListingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateManyWithoutListingsInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    conditionId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type SaleUpdateWithoutBuyerInput = {
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: ListingUpdateOneRequiredWithoutSalesNestedInput
    conversation?: ConversationUpdateOneWithoutSaleNestedInput
    rating?: RatingUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutBuyerInput = {
    listingId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: RatingUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutPurchasesInput = {
    listingId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutUser1Input = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user2?: UserUpdateOneRequiredWithoutConversationsReceivedNestedInput
    listing?: ListingUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    Sale?: SaleUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutUser1Input = {
    user2Id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    Sale?: SaleUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutConversationsInitiatedInput = {
    user2Id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutUser2Input = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user1?: UserUpdateOneRequiredWithoutConversationsInitiatedNestedInput
    listing?: ListingUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    Sale?: SaleUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutUser2Input = {
    user1Id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    Sale?: SaleUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutConversationsReceivedInput = {
    user1Id?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSentMessagesInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    conversationId?: StringFieldUpdateOperationsInput | string
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingUpdateWithoutRaterInput = {
    value?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    sale?: SaleUpdateOneRequiredWithoutRatingNestedInput
    ratee?: UserUpdateOneRequiredWithoutReceivedRatingsNestedInput
  }

  export type RatingUncheckedUpdateWithoutRaterInput = {
    value?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    saleId?: StringFieldUpdateOperationsInput | string
    rateeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type RatingUncheckedUpdateManyWithoutGivenRatingsInput = {
    value?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    saleId?: StringFieldUpdateOperationsInput | string
    rateeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type RatingUpdateWithoutRateeInput = {
    value?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    sale?: SaleUpdateOneRequiredWithoutRatingNestedInput
    rater?: UserUpdateOneRequiredWithoutGivenRatingsNestedInput
  }

  export type RatingUncheckedUpdateWithoutRateeInput = {
    value?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    saleId?: StringFieldUpdateOperationsInput | string
    raterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type RatingUncheckedUpdateManyWithoutReceivedRatingsInput = {
    value?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    saleId?: StringFieldUpdateOperationsInput | string
    raterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type SavedListingUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: ListingUpdateOneRequiredWithoutSavedByUsersNestedInput
  }

  export type SavedListingUncheckedUpdateWithoutUserInput = {
    listingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedListingUncheckedUpdateManyWithoutSavedListingsInput = {
    listingId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutReportedByInput = {
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    listing?: ListingUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutReportedByInput = {
    listingId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutReportsMadeInput = {
    listingId?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyOrganizationInput = {
    id?: string
    filename: string
    url: string
    uploadedBy: string
    createdAt?: Date | string
  }

  export type DonationCreateManyOrganizationInput = {
    id?: string
    dropPointId: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
  }

  export type AdvertisementCreateManyOrganizationInput = {
    id?: string
    cityId: string
    title: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate?: Date | string
    expiryDate: Date | string
  }

  export type FeedbackCreateManyOrganizationInput = {
    id?: string
    content: string
    rating: number
    createdAt?: Date | string
    dropPointId: string
    donationId: string
  }

  export type DocumentUpdateWithoutOrganizationInput = {
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateWithoutOrganizationInput = {
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutSubmittedDocumentsInput = {
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUpdateWithoutOrganizationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: FeedbackUpdateOneWithoutDonationNestedInput
    dropPoint?: DropPointUpdateOneRequiredWithoutDonationsNestedInput
    peripherals?: PeripheralUpdateManyWithoutDonationNestedInput
  }

  export type DonationUncheckedUpdateWithoutOrganizationInput = {
    dropPointId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: FeedbackUncheckedUpdateOneWithoutDonationNestedInput
    peripherals?: PeripheralUncheckedUpdateManyWithoutDonationNestedInput
  }

  export type DonationUncheckedUpdateManyWithoutDonationsInput = {
    dropPointId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AdvertisementUpdateWithoutOrganizationInput = {
    title?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutAdvertisementsNestedInput
    interactions?: AdInteractionUpdateManyWithoutAdvertisementNestedInput
  }

  export type AdvertisementUncheckedUpdateWithoutOrganizationInput = {
    cityId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: AdInteractionUncheckedUpdateManyWithoutAdvertisementNestedInput
  }

  export type AdvertisementUncheckedUpdateManyWithoutAdvertisementsInput = {
    cityId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackUpdateWithoutOrganizationInput = {
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropPoint?: DropPointUpdateOneRequiredWithoutFeedbacksGivenNestedInput
    donation?: DonationUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutOrganizationInput = {
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropPointId?: StringFieldUpdateOperationsInput | string
    donationId?: StringFieldUpdateOperationsInput | string
  }

  export type FeedbackUncheckedUpdateManyWithoutFeedbacksGivenInput = {
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropPointId?: StringFieldUpdateOperationsInput | string
    donationId?: StringFieldUpdateOperationsInput | string
  }

  export type DonationCreateManyDropPointInput = {
    id?: string
    organizationId: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
  }

  export type FeedbackCreateManyDropPointInput = {
    id?: string
    content: string
    rating: number
    createdAt?: Date | string
    organizationId: string
    donationId: string
  }

  export type DonationUpdateWithoutDropPointInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: FeedbackUpdateOneWithoutDonationNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutDonationsNestedInput
    peripherals?: PeripheralUpdateManyWithoutDonationNestedInput
  }

  export type DonationUncheckedUpdateWithoutDropPointInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
    feedback?: FeedbackUncheckedUpdateOneWithoutDonationNestedInput
    peripherals?: PeripheralUncheckedUpdateManyWithoutDonationNestedInput
  }

  export type FeedbackUpdateWithoutDropPointInput = {
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutFeedbacksGivenNestedInput
    donation?: DonationUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type FeedbackUncheckedUpdateWithoutDropPointInput = {
    content?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organizationId?: StringFieldUpdateOperationsInput | string
    donationId?: StringFieldUpdateOperationsInput | string
  }

  export type DropPointCreateManyManagerInput = {
    id?: string
    name: string
    location: string
    openingTime: string
    closingTime: string
    description: string
    password?: string | null
  }

  export type DropPointUpdateWithoutManagerInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    openingTime?: StringFieldUpdateOperationsInput | string
    closingTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    donations?: DonationUpdateManyWithoutDropPointNestedInput
    feedbacksGiven?: FeedbackUpdateManyWithoutDropPointNestedInput
  }

  export type DropPointUncheckedUpdateWithoutManagerInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    openingTime?: StringFieldUpdateOperationsInput | string
    closingTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    donations?: DonationUncheckedUpdateManyWithoutDropPointNestedInput
    feedbacksGiven?: FeedbackUncheckedUpdateManyWithoutDropPointNestedInput
  }

  export type DropPointUncheckedUpdateManyWithoutDropPointInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    openingTime?: StringFieldUpdateOperationsInput | string
    closingTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PeripheralCreateManyDonationInput = {
    id?: string
    type: string
    brand: string
    model: string
    condition: string
    quantity?: number
  }

  export type PeripheralUpdateWithoutDonationInput = {
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type PeripheralUncheckedUpdateWithoutDonationInput = {
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type PeripheralUncheckedUpdateManyWithoutPeripheralsInput = {
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateManyCityInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    reportedListingCount?: number
  }

  export type AdvertisementCreateManyCityInput = {
    id?: string
    organizationId: string
    title: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate?: Date | string
    expiryDate: Date | string
  }

  export type UserUpdateWithoutCityInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    listings?: ListingUpdateManyWithoutUserNestedInput
    purchases?: SaleUpdateManyWithoutBuyerNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutUser1NestedInput
    conversationsReceived?: ConversationUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    givenRatings?: RatingUpdateManyWithoutRaterNestedInput
    receivedRatings?: RatingUpdateManyWithoutRateeNestedInput
    savedListings?: SavedListingUpdateManyWithoutUserNestedInput
    reportsMade?: ReportUpdateManyWithoutReportedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCityInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
    listings?: ListingUncheckedUpdateManyWithoutUserNestedInput
    purchases?: SaleUncheckedUpdateManyWithoutBuyerNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutUser1NestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutUser2NestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    givenRatings?: RatingUncheckedUpdateManyWithoutRaterNestedInput
    receivedRatings?: RatingUncheckedUpdateManyWithoutRateeNestedInput
    savedListings?: SavedListingUncheckedUpdateManyWithoutUserNestedInput
    reportsMade?: ReportUncheckedUpdateManyWithoutReportedByNestedInput
  }

  export type UserUncheckedUpdateManyWithoutUsersInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedListingCount?: IntFieldUpdateOperationsInput | number
  }

  export type AdvertisementUpdateWithoutCityInput = {
    title?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAdvertisementsNestedInput
    interactions?: AdInteractionUpdateManyWithoutAdvertisementNestedInput
  }

  export type AdvertisementUncheckedUpdateWithoutCityInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: AdInteractionUncheckedUpdateManyWithoutAdvertisementNestedInput
  }

  export type AdInteractionCreateManyAdvertisementInput = {
    id?: string
    clickedAt?: Date | string
  }

  export type AdInteractionUpdateWithoutAdvertisementInput = {
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdInteractionUncheckedUpdateWithoutAdvertisementInput = {
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdInteractionUncheckedUpdateManyWithoutInteractionsInput = {
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhotoCreateManyListingInput = {
    id?: string
    imageUrl: Buffer
  }

  export type SaleCreateManyListingInput = {
    id?: string
    buyerId: string
    conversationId?: string | null
    salePrice: number
    saleDate?: Date | string
  }

  export type ConversationCreateManyListingInput = {
    id?: string
    user1Id: string
    user2Id: string
    createdAt?: Date | string
  }

  export type SavedListingCreateManyListingInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type ReportCreateManyListingInput = {
    id?: string
    reportedById: string
    reason: string
    createdAt?: Date | string
  }

  export type PhotoUpdateWithoutListingInput = {
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type PhotoUncheckedUpdateWithoutListingInput = {
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type PhotoUncheckedUpdateManyWithoutPhotosInput = {
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
  }

  export type SaleUpdateWithoutListingInput = {
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    buyer?: UserUpdateOneRequiredWithoutPurchasesNestedInput
    conversation?: ConversationUpdateOneWithoutSaleNestedInput
    rating?: RatingUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutListingInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: RatingUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutSalesInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    conversationId?: NullableStringFieldUpdateOperationsInput | string | null
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutListingInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user1?: UserUpdateOneRequiredWithoutConversationsInitiatedNestedInput
    user2?: UserUpdateOneRequiredWithoutConversationsReceivedNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
    Sale?: SaleUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutListingInput = {
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
    Sale?: SaleUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutConversationsInput = {
    user1Id?: StringFieldUpdateOperationsInput | string
    user2Id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedListingUpdateWithoutListingInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSavedListingsNestedInput
  }

  export type SavedListingUncheckedUpdateWithoutListingInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedListingUncheckedUpdateManyWithoutSavedByUsersInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUpdateWithoutListingInput = {
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: UserUpdateOneRequiredWithoutReportsMadeNestedInput
  }

  export type ReportUncheckedUpdateWithoutListingInput = {
    reportedById?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutReportsInput = {
    reportedById?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RatingCreateManySaleInput = {
    id?: string
    value: number
    comment?: string | null
    raterId: string
    rateeId: string
    createdAt?: Date | string
    type: string
  }

  export type RatingUpdateWithoutSaleInput = {
    value?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    rater?: UserUpdateOneRequiredWithoutGivenRatingsNestedInput
    ratee?: UserUpdateOneRequiredWithoutReceivedRatingsNestedInput
  }

  export type RatingUncheckedUpdateWithoutSaleInput = {
    value?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    raterId?: StringFieldUpdateOperationsInput | string
    rateeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type RatingUncheckedUpdateManyWithoutRatingInput = {
    value?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    raterId?: StringFieldUpdateOperationsInput | string
    rateeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type ListingCreateManyCategoryInput = {
    id?: string
    title: string
    price: number
    conditionId: string
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    status?: string
  }

  export type ListingUpdateWithoutCategoryInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUpdateManyWithoutListingNestedInput
    condition?: ConditionUpdateOneRequiredWithoutListingsNestedInput
    user?: UserUpdateOneRequiredWithoutListingsNestedInput
    sales?: SaleUpdateManyWithoutListingNestedInput
    conversations?: ConversationUpdateManyWithoutListingNestedInput
    savedByUsers?: SavedListingUpdateManyWithoutListingNestedInput
    reports?: ReportUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateWithoutCategoryInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    conditionId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUncheckedUpdateManyWithoutListingNestedInput
    sales?: SaleUncheckedUpdateManyWithoutListingNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutListingNestedInput
    savedByUsers?: SavedListingUncheckedUpdateManyWithoutListingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutListingNestedInput
  }

  export type ListingCreateManyConditionInput = {
    id?: string
    title: string
    price: number
    categoryId: string
    description: string
    location: string
    createdAt?: Date | string
    updatedAt?: Date | string
    userId: string
    status?: string
  }

  export type ListingUpdateWithoutConditionInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUpdateManyWithoutListingNestedInput
    category?: CategoryUpdateOneRequiredWithoutListingsNestedInput
    user?: UserUpdateOneRequiredWithoutListingsNestedInput
    sales?: SaleUpdateManyWithoutListingNestedInput
    conversations?: ConversationUpdateManyWithoutListingNestedInput
    savedByUsers?: SavedListingUpdateManyWithoutListingNestedInput
    reports?: ReportUpdateManyWithoutListingNestedInput
  }

  export type ListingUncheckedUpdateWithoutConditionInput = {
    title?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    categoryId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    photos?: PhotoUncheckedUpdateManyWithoutListingNestedInput
    sales?: SaleUncheckedUpdateManyWithoutListingNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutListingNestedInput
    savedByUsers?: SavedListingUncheckedUpdateManyWithoutListingNestedInput
    reports?: ReportUncheckedUpdateManyWithoutListingNestedInput
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    content?: string | null
    senderId: string
    imageFileId?: string | null
    read?: boolean
    createdAt?: Date | string
  }

  export type SaleCreateManyConversationInput = {
    id?: string
    buyerId: string
    listingId: string
    salePrice: number
    saleDate?: Date | string
  }

  export type MessageUpdateWithoutConversationInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: StringFieldUpdateOperationsInput | string
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutMessagesInput = {
    content?: NullableStringFieldUpdateOperationsInput | string | null
    senderId?: StringFieldUpdateOperationsInput | string
    imageFileId?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUpdateWithoutConversationInput = {
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    buyer?: UserUpdateOneRequiredWithoutPurchasesNestedInput
    listing?: ListingUpdateOneRequiredWithoutSalesNestedInput
    rating?: RatingUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateWithoutConversationInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
    rating?: RatingUncheckedUpdateManyWithoutSaleNestedInput
  }

  export type SaleUncheckedUpdateManyWithoutSaleInput = {
    buyerId?: StringFieldUpdateOperationsInput | string
    listingId?: StringFieldUpdateOperationsInput | string
    salePrice?: FloatFieldUpdateOperationsInput | number
    saleDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationCountOutputTypeDefaultArgs instead
     */
    export type OrganizationCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = OrganizationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DropPointCountOutputTypeDefaultArgs instead
     */
    export type DropPointCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DropPointCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ManagerCountOutputTypeDefaultArgs instead
     */
    export type ManagerCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ManagerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DonationCountOutputTypeDefaultArgs instead
     */
    export type DonationCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DonationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityCountOutputTypeDefaultArgs instead
     */
    export type CityCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvertisementCountOutputTypeDefaultArgs instead
     */
    export type AdvertisementCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = AdvertisementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ListingCountOutputTypeDefaultArgs instead
     */
    export type ListingCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ListingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleCountOutputTypeDefaultArgs instead
     */
    export type SaleCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = SaleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConditionCountOutputTypeDefaultArgs instead
     */
    export type ConditionCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ConditionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationCountOutputTypeDefaultArgs instead
     */
    export type ConversationCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ConversationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationDefaultArgs instead
     */
    export type OrganizationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = OrganizationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DropPointDefaultArgs instead
     */
    export type DropPointArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DropPointDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminDefaultArgs instead
     */
    export type AdminArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = AdminDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ManagerDefaultArgs instead
     */
    export type ManagerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ManagerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DonationDefaultArgs instead
     */
    export type DonationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DonationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedbackDefaultArgs instead
     */
    export type FeedbackArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = FeedbackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PeripheralDefaultArgs instead
     */
    export type PeripheralArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = PeripheralDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityDefaultArgs instead
     */
    export type CityArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvertisementDefaultArgs instead
     */
    export type AdvertisementArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = AdvertisementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdInteractionDefaultArgs instead
     */
    export type AdInteractionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = AdInteractionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KeyValueStoreDefaultArgs instead
     */
    export type KeyValueStoreArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = KeyValueStoreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ListingDefaultArgs instead
     */
    export type ListingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ListingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SavedListingDefaultArgs instead
     */
    export type SavedListingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = SavedListingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SaleDefaultArgs instead
     */
    export type SaleArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = SaleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RatingDefaultArgs instead
     */
    export type RatingArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = RatingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PhotoDefaultArgs instead
     */
    export type PhotoArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = PhotoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConditionDefaultArgs instead
     */
    export type ConditionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ConditionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConversationDefaultArgs instead
     */
    export type ConversationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ConversationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageDefaultArgs instead
     */
    export type MessageArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = MessageDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}