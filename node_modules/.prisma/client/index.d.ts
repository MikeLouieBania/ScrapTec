
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model DropPoint
 * 
 */
export type DropPoint = $Result.DefaultSelection<Prisma.$DropPointPayload>
/**
 * Model Manager
 * 
 */
export type Manager = $Result.DefaultSelection<Prisma.$ManagerPayload>
/**
 * Model Donation
 * 
 */
export type Donation = $Result.DefaultSelection<Prisma.$DonationPayload>
/**
 * Model Peripheral
 * 
 */
export type Peripheral = $Result.DefaultSelection<Prisma.$PeripheralPayload>
/**
 * Model City
 * 
 */
export type City = $Result.DefaultSelection<Prisma.$CityPayload>
/**
 * Model Advertisement
 * 
 */
export type Advertisement = $Result.DefaultSelection<Prisma.$AdvertisementPayload>
/**
 * Model AdInteraction
 * 
 */
export type AdInteraction = $Result.DefaultSelection<Prisma.$AdInteractionPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;

  /**
   * `prisma.dropPoint`: Exposes CRUD operations for the **DropPoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DropPoints
    * const dropPoints = await prisma.dropPoint.findMany()
    * ```
    */
  get dropPoint(): Prisma.DropPointDelegate<ExtArgs>;

  /**
   * `prisma.manager`: Exposes CRUD operations for the **Manager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Managers
    * const managers = await prisma.manager.findMany()
    * ```
    */
  get manager(): Prisma.ManagerDelegate<ExtArgs>;

  /**
   * `prisma.donation`: Exposes CRUD operations for the **Donation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Donations
    * const donations = await prisma.donation.findMany()
    * ```
    */
  get donation(): Prisma.DonationDelegate<ExtArgs>;

  /**
   * `prisma.peripheral`: Exposes CRUD operations for the **Peripheral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Peripherals
    * const peripherals = await prisma.peripheral.findMany()
    * ```
    */
  get peripheral(): Prisma.PeripheralDelegate<ExtArgs>;

  /**
   * `prisma.city`: Exposes CRUD operations for the **City** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.city.findMany()
    * ```
    */
  get city(): Prisma.CityDelegate<ExtArgs>;

  /**
   * `prisma.advertisement`: Exposes CRUD operations for the **Advertisement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Advertisements
    * const advertisements = await prisma.advertisement.findMany()
    * ```
    */
  get advertisement(): Prisma.AdvertisementDelegate<ExtArgs>;

  /**
   * `prisma.adInteraction`: Exposes CRUD operations for the **AdInteraction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdInteractions
    * const adInteractions = await prisma.adInteraction.findMany()
    * ```
    */
  get adInteraction(): Prisma.AdInteractionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.2.0
   * Query Engine version: 4bc8b6e1b66cb932731fb1bdbbc550d1e010de81
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Organization: 'Organization',
    Document: 'Document',
    DropPoint: 'DropPoint',
    Manager: 'Manager',
    Donation: 'Donation',
    Peripheral: 'Peripheral',
    City: 'City',
    Advertisement: 'Advertisement',
    AdInteraction: 'AdInteraction'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'organization' | 'document' | 'dropPoint' | 'manager' | 'donation' | 'peripheral' | 'city' | 'advertisement' | 'adInteraction'
      txIsolationLevel: never
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.OrganizationFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.OrganizationAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>,
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DocumentFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.DocumentAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      DropPoint: {
        payload: Prisma.$DropPointPayload<ExtArgs>
        fields: Prisma.DropPointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DropPointFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropPointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DropPointFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropPointPayload>
          }
          findFirst: {
            args: Prisma.DropPointFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropPointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DropPointFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropPointPayload>
          }
          findMany: {
            args: Prisma.DropPointFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropPointPayload>[]
          }
          create: {
            args: Prisma.DropPointCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropPointPayload>
          }
          createMany: {
            args: Prisma.DropPointCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DropPointDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropPointPayload>
          }
          update: {
            args: Prisma.DropPointUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropPointPayload>
          }
          deleteMany: {
            args: Prisma.DropPointDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DropPointUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DropPointUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DropPointPayload>
          }
          aggregate: {
            args: Prisma.DropPointAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDropPoint>
          }
          groupBy: {
            args: Prisma.DropPointGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DropPointGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DropPointFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.DropPointAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.DropPointCountArgs<ExtArgs>,
            result: $Utils.Optional<DropPointCountAggregateOutputType> | number
          }
        }
      }
      Manager: {
        payload: Prisma.$ManagerPayload<ExtArgs>
        fields: Prisma.ManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManagerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManagerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          findFirst: {
            args: Prisma.ManagerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManagerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          findMany: {
            args: Prisma.ManagerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          create: {
            args: Prisma.ManagerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          createMany: {
            args: Prisma.ManagerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ManagerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          update: {
            args: Prisma.ManagerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          deleteMany: {
            args: Prisma.ManagerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ManagerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ManagerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          aggregate: {
            args: Prisma.ManagerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateManager>
          }
          groupBy: {
            args: Prisma.ManagerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ManagerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ManagerFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.ManagerAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.ManagerCountArgs<ExtArgs>,
            result: $Utils.Optional<ManagerCountAggregateOutputType> | number
          }
        }
      }
      Donation: {
        payload: Prisma.$DonationPayload<ExtArgs>
        fields: Prisma.DonationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DonationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DonationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DonationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          findFirst: {
            args: Prisma.DonationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DonationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DonationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          findMany: {
            args: Prisma.DonationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>[]
          }
          create: {
            args: Prisma.DonationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          createMany: {
            args: Prisma.DonationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DonationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          update: {
            args: Prisma.DonationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          deleteMany: {
            args: Prisma.DonationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DonationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DonationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DonationPayload>
          }
          aggregate: {
            args: Prisma.DonationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDonation>
          }
          groupBy: {
            args: Prisma.DonationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DonationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DonationFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.DonationAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.DonationCountArgs<ExtArgs>,
            result: $Utils.Optional<DonationCountAggregateOutputType> | number
          }
        }
      }
      Peripheral: {
        payload: Prisma.$PeripheralPayload<ExtArgs>
        fields: Prisma.PeripheralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PeripheralFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PeripheralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PeripheralFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PeripheralPayload>
          }
          findFirst: {
            args: Prisma.PeripheralFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PeripheralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PeripheralFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PeripheralPayload>
          }
          findMany: {
            args: Prisma.PeripheralFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PeripheralPayload>[]
          }
          create: {
            args: Prisma.PeripheralCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PeripheralPayload>
          }
          createMany: {
            args: Prisma.PeripheralCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PeripheralDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PeripheralPayload>
          }
          update: {
            args: Prisma.PeripheralUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PeripheralPayload>
          }
          deleteMany: {
            args: Prisma.PeripheralDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PeripheralUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PeripheralUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PeripheralPayload>
          }
          aggregate: {
            args: Prisma.PeripheralAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePeripheral>
          }
          groupBy: {
            args: Prisma.PeripheralGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PeripheralGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PeripheralFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.PeripheralAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.PeripheralCountArgs<ExtArgs>,
            result: $Utils.Optional<PeripheralCountAggregateOutputType> | number
          }
        }
      }
      City: {
        payload: Prisma.$CityPayload<ExtArgs>
        fields: Prisma.CityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findFirst: {
            args: Prisma.CityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          findMany: {
            args: Prisma.CityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>[]
          }
          create: {
            args: Prisma.CityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          createMany: {
            args: Prisma.CityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          update: {
            args: Prisma.CityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          deleteMany: {
            args: Prisma.CityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CityPayload>
          }
          aggregate: {
            args: Prisma.CityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCity>
          }
          groupBy: {
            args: Prisma.CityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CityGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.CityFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.CityAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.CityCountArgs<ExtArgs>,
            result: $Utils.Optional<CityCountAggregateOutputType> | number
          }
        }
      }
      Advertisement: {
        payload: Prisma.$AdvertisementPayload<ExtArgs>
        fields: Prisma.AdvertisementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdvertisementFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdvertisementFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          findFirst: {
            args: Prisma.AdvertisementFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdvertisementFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          findMany: {
            args: Prisma.AdvertisementFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>[]
          }
          create: {
            args: Prisma.AdvertisementCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          createMany: {
            args: Prisma.AdvertisementCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdvertisementDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          update: {
            args: Prisma.AdvertisementUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          deleteMany: {
            args: Prisma.AdvertisementDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdvertisementUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdvertisementUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdvertisementPayload>
          }
          aggregate: {
            args: Prisma.AdvertisementAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdvertisement>
          }
          groupBy: {
            args: Prisma.AdvertisementGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdvertisementGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AdvertisementFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.AdvertisementAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.AdvertisementCountArgs<ExtArgs>,
            result: $Utils.Optional<AdvertisementCountAggregateOutputType> | number
          }
        }
      }
      AdInteraction: {
        payload: Prisma.$AdInteractionPayload<ExtArgs>
        fields: Prisma.AdInteractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdInteractionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdInteractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdInteractionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdInteractionPayload>
          }
          findFirst: {
            args: Prisma.AdInteractionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdInteractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdInteractionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdInteractionPayload>
          }
          findMany: {
            args: Prisma.AdInteractionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdInteractionPayload>[]
          }
          create: {
            args: Prisma.AdInteractionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdInteractionPayload>
          }
          createMany: {
            args: Prisma.AdInteractionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AdInteractionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdInteractionPayload>
          }
          update: {
            args: Prisma.AdInteractionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdInteractionPayload>
          }
          deleteMany: {
            args: Prisma.AdInteractionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AdInteractionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AdInteractionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AdInteractionPayload>
          }
          aggregate: {
            args: Prisma.AdInteractionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAdInteraction>
          }
          groupBy: {
            args: Prisma.AdInteractionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AdInteractionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AdInteractionFindRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          aggregateRaw: {
            args: Prisma.AdInteractionAggregateRawArgs<ExtArgs>,
            result: Prisma.JsonObject
          }
          count: {
            args: Prisma.AdInteractionCountArgs<ExtArgs>,
            result: $Utils.Optional<AdInteractionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    submittedDocuments: number
    donations: number
    advertisements: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    submittedDocuments?: boolean | OrganizationCountOutputTypeCountSubmittedDocumentsArgs
    donations?: boolean | OrganizationCountOutputTypeCountDonationsArgs
    advertisements?: boolean | OrganizationCountOutputTypeCountAdvertisementsArgs
  }

  // Custom InputTypes

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountSubmittedDocumentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }


  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountDonationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DonationWhereInput
  }


  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountAdvertisementsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AdvertisementWhereInput
  }



  /**
   * Count Type DropPointCountOutputType
   */

  export type DropPointCountOutputType = {
    donations: number
  }

  export type DropPointCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    donations?: boolean | DropPointCountOutputTypeCountDonationsArgs
  }

  // Custom InputTypes

  /**
   * DropPointCountOutputType without action
   */
  export type DropPointCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPointCountOutputType
     */
    select?: DropPointCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DropPointCountOutputType without action
   */
  export type DropPointCountOutputTypeCountDonationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DonationWhereInput
  }



  /**
   * Count Type ManagerCountOutputType
   */

  export type ManagerCountOutputType = {
    dropPoint: number
  }

  export type ManagerCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    dropPoint?: boolean | ManagerCountOutputTypeCountDropPointArgs
  }

  // Custom InputTypes

  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerCountOutputType
     */
    select?: ManagerCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeCountDropPointArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DropPointWhereInput
  }



  /**
   * Count Type DonationCountOutputType
   */

  export type DonationCountOutputType = {
    peripherals: number
  }

  export type DonationCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    peripherals?: boolean | DonationCountOutputTypeCountPeripheralsArgs
  }

  // Custom InputTypes

  /**
   * DonationCountOutputType without action
   */
  export type DonationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DonationCountOutputType
     */
    select?: DonationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DonationCountOutputType without action
   */
  export type DonationCountOutputTypeCountPeripheralsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PeripheralWhereInput
  }



  /**
   * Count Type CityCountOutputType
   */

  export type CityCountOutputType = {
    users: number
    advertisements: number
  }

  export type CityCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | CityCountOutputTypeCountUsersArgs
    advertisements?: boolean | CityCountOutputTypeCountAdvertisementsArgs
  }

  // Custom InputTypes

  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CityCountOutputType
     */
    select?: CityCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * CityCountOutputType without action
   */
  export type CityCountOutputTypeCountAdvertisementsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AdvertisementWhereInput
  }



  /**
   * Count Type AdvertisementCountOutputType
   */

  export type AdvertisementCountOutputType = {
    interactions: number
  }

  export type AdvertisementCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    interactions?: boolean | AdvertisementCountOutputTypeCountInteractionsArgs
  }

  // Custom InputTypes

  /**
   * AdvertisementCountOutputType without action
   */
  export type AdvertisementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdvertisementCountOutputType
     */
    select?: AdvertisementCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AdvertisementCountOutputType without action
   */
  export type AdvertisementCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AdInteractionWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    password: string | null
    cityId: string | null
    gender: string | null
    contactNumber: string | null
    profilePicture: Buffer | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    password: string | null
    cityId: string | null
    gender: string | null
    contactNumber: string | null
    profilePicture: Buffer | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    firstName: number
    lastName: number
    password: number
    cityId: number
    gender: number
    contactNumber: number
    profilePicture: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    password?: true
    cityId?: true
    gender?: true
    contactNumber?: true
    profilePicture?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    password?: true
    cityId?: true
    gender?: true
    contactNumber?: true
    profilePicture?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    firstName?: true
    lastName?: true
    password?: true
    cityId?: true
    gender?: true
    contactNumber?: true
    profilePicture?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    firstName: string
    lastName: string
    password: string
    cityId: string
    gender: string
    contactNumber: string
    profilePicture: Buffer | null
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    cityId?: boolean
    gender?: boolean
    contactNumber?: boolean
    profilePicture?: boolean
    createdAt?: boolean
    city?: boolean | CityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    cityId?: boolean
    gender?: boolean
    contactNumber?: boolean
    profilePicture?: boolean
    createdAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    city?: boolean | CityDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      city: Prisma.$CityPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      email: string
      firstName: string
      lastName: string
      password: string
      cityId: string
      gender: string
      contactNumber: string
      profilePicture: Buffer | null
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: UserFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: UserAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly cityId: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'String'>
    readonly contactNumber: FieldRef<"User", 'String'>
    readonly profilePicture: FieldRef<"User", 'Bytes'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationAvgAggregateOutputType = {
    totalPoints: number | null
  }

  export type OrganizationSumAggregateOutputType = {
    totalPoints: number | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: string | null
    organizationname: string | null
    email: string | null
    password: string | null
    address: string | null
    contactNumber: string | null
    secRegistrationNumber: string | null
    verificationStatus: string | null
    totalPoints: number | null
    type: string | null
    profilePicture: Buffer | null
    createdAt: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: string | null
    organizationname: string | null
    email: string | null
    password: string | null
    address: string | null
    contactNumber: string | null
    secRegistrationNumber: string | null
    verificationStatus: string | null
    totalPoints: number | null
    type: string | null
    profilePicture: Buffer | null
    createdAt: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    organizationname: number
    email: number
    password: number
    address: number
    contactNumber: number
    secRegistrationNumber: number
    verificationStatus: number
    totalPoints: number
    type: number
    profilePicture: number
    createdAt: number
    _all: number
  }


  export type OrganizationAvgAggregateInputType = {
    totalPoints?: true
  }

  export type OrganizationSumAggregateInputType = {
    totalPoints?: true
  }

  export type OrganizationMinAggregateInputType = {
    id?: true
    organizationname?: true
    email?: true
    password?: true
    address?: true
    contactNumber?: true
    secRegistrationNumber?: true
    verificationStatus?: true
    totalPoints?: true
    type?: true
    profilePicture?: true
    createdAt?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    organizationname?: true
    email?: true
    password?: true
    address?: true
    contactNumber?: true
    secRegistrationNumber?: true
    verificationStatus?: true
    totalPoints?: true
    type?: true
    profilePicture?: true
    createdAt?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    organizationname?: true
    email?: true
    password?: true
    address?: true
    contactNumber?: true
    secRegistrationNumber?: true
    verificationStatus?: true
    totalPoints?: true
    type?: true
    profilePicture?: true
    createdAt?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _avg?: OrganizationAvgAggregateInputType
    _sum?: OrganizationSumAggregateInputType
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber: string | null
    verificationStatus: string
    totalPoints: number
    type: string
    profilePicture: Buffer | null
    createdAt: Date
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationname?: boolean
    email?: boolean
    password?: boolean
    address?: boolean
    contactNumber?: boolean
    secRegistrationNumber?: boolean
    verificationStatus?: boolean
    totalPoints?: boolean
    type?: boolean
    profilePicture?: boolean
    createdAt?: boolean
    submittedDocuments?: boolean | Organization$submittedDocumentsArgs<ExtArgs>
    donations?: boolean | Organization$donationsArgs<ExtArgs>
    advertisements?: boolean | Organization$advertisementsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    organizationname?: boolean
    email?: boolean
    password?: boolean
    address?: boolean
    contactNumber?: boolean
    secRegistrationNumber?: boolean
    verificationStatus?: boolean
    totalPoints?: boolean
    type?: boolean
    profilePicture?: boolean
    createdAt?: boolean
  }

  export type OrganizationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    submittedDocuments?: boolean | Organization$submittedDocumentsArgs<ExtArgs>
    donations?: boolean | Organization$donationsArgs<ExtArgs>
    advertisements?: boolean | Organization$advertisementsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $OrganizationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      submittedDocuments: Prisma.$DocumentPayload<ExtArgs>[]
      donations: Prisma.$DonationPayload<ExtArgs>[]
      advertisements: Prisma.$AdvertisementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      organizationname: string
      email: string
      password: string
      address: string
      contactNumber: string
      secRegistrationNumber: string | null
      verificationStatus: string
      totalPoints: number
      type: string
      profilePicture: Buffer | null
      createdAt: Date
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }


  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<OrganizationFindManyArgs, 'select' | 'include'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OrganizationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Organization that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OrganizationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends OrganizationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
    **/
    create<T extends OrganizationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Organizations.
     *     @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     *     @example
     *     // Create many Organizations
     *     const organization = await prisma.organization.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends OrganizationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
    **/
    delete<T extends OrganizationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OrganizationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OrganizationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OrganizationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
    **/
    upsert<T extends OrganizationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>
    ): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Organizations that matches the filter.
     * @param {OrganizationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const organization = await prisma.organization.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: OrganizationFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Organization.
     * @param {OrganizationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const organization = await prisma.organization.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: OrganizationAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    submittedDocuments<T extends Organization$submittedDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$submittedDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'> | Null>;

    donations<T extends Organization$donationsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$donationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'findMany'> | Null>;

    advertisements<T extends Organization$advertisementsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$advertisementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Organization model
   */ 
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'String'>
    readonly organizationname: FieldRef<"Organization", 'String'>
    readonly email: FieldRef<"Organization", 'String'>
    readonly password: FieldRef<"Organization", 'String'>
    readonly address: FieldRef<"Organization", 'String'>
    readonly contactNumber: FieldRef<"Organization", 'String'>
    readonly secRegistrationNumber: FieldRef<"Organization", 'String'>
    readonly verificationStatus: FieldRef<"Organization", 'String'>
    readonly totalPoints: FieldRef<"Organization", 'Float'>
    readonly type: FieldRef<"Organization", 'String'>
    readonly profilePicture: FieldRef<"Organization", 'Bytes'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }


  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }


  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }


  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }


  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
  }


  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
  }


  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }


  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }


  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
  }


  /**
   * Organization findRaw
   */
  export type OrganizationFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Organization aggregateRaw
   */
  export type OrganizationAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Organization.submittedDocuments
   */
  export type Organization$submittedDocumentsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Organization.donations
   */
  export type Organization$donationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    where?: DonationWhereInput
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    cursor?: DonationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }


  /**
   * Organization.advertisements
   */
  export type Organization$advertisementsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    where?: AdvertisementWhereInput
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    cursor?: AdvertisementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }


  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: OrganizationInclude<ExtArgs> | null
  }



  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    filename: string | null
    url: string | null
    uploadedBy: string | null
    organizationId: string | null
    createdAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    filename: string | null
    url: string | null
    uploadedBy: string | null
    organizationId: string | null
    createdAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    filename: number
    url: number
    uploadedBy: number
    organizationId: number
    createdAt: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    filename?: true
    url?: true
    uploadedBy?: true
    organizationId?: true
    createdAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    filename?: true
    url?: true
    uploadedBy?: true
    organizationId?: true
    createdAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    filename?: true
    url?: true
    uploadedBy?: true
    organizationId?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    filename: string
    url: string
    uploadedBy: string
    organizationId: string | null
    createdAt: Date
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    url?: boolean
    uploadedBy?: boolean
    organizationId?: boolean
    createdAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    filename?: boolean
    url?: boolean
    uploadedBy?: boolean
    organizationId?: boolean
    createdAt?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }


  export type $DocumentPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetResult<{
      id: string
      filename: string
      url: string
      uploadedBy: string
      organizationId: string | null
      createdAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }


  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DocumentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DocumentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
    **/
    create<T extends DocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Documents.
     *     @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     *     @example
     *     // Create many Documents
     *     const document = await prisma.document.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
    **/
    delete<T extends DocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
    **/
    upsert<T extends DocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>
    ): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * @param {DocumentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const document = await prisma.document.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: DocumentFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Document.
     * @param {DocumentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const document = await prisma.document.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: DocumentAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly filename: FieldRef<"Document", 'String'>
    readonly url: FieldRef<"Document", 'String'>
    readonly uploadedBy: FieldRef<"Document", 'String'>
    readonly organizationId: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }


  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }


  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
  }


  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }


  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }


  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }


  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }


  /**
   * Document findRaw
   */
  export type DocumentFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Document aggregateRaw
   */
  export type DocumentAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DocumentInclude<ExtArgs> | null
  }



  /**
   * Model DropPoint
   */

  export type AggregateDropPoint = {
    _count: DropPointCountAggregateOutputType | null
    _min: DropPointMinAggregateOutputType | null
    _max: DropPointMaxAggregateOutputType | null
  }

  export type DropPointMinAggregateOutputType = {
    id: string | null
    name: string | null
    location: string | null
    openingTime: string | null
    closingTime: string | null
    description: string | null
    managerId: string | null
    password: string | null
  }

  export type DropPointMaxAggregateOutputType = {
    id: string | null
    name: string | null
    location: string | null
    openingTime: string | null
    closingTime: string | null
    description: string | null
    managerId: string | null
    password: string | null
  }

  export type DropPointCountAggregateOutputType = {
    id: number
    name: number
    location: number
    openingTime: number
    closingTime: number
    description: number
    managerId: number
    password: number
    _all: number
  }


  export type DropPointMinAggregateInputType = {
    id?: true
    name?: true
    location?: true
    openingTime?: true
    closingTime?: true
    description?: true
    managerId?: true
    password?: true
  }

  export type DropPointMaxAggregateInputType = {
    id?: true
    name?: true
    location?: true
    openingTime?: true
    closingTime?: true
    description?: true
    managerId?: true
    password?: true
  }

  export type DropPointCountAggregateInputType = {
    id?: true
    name?: true
    location?: true
    openingTime?: true
    closingTime?: true
    description?: true
    managerId?: true
    password?: true
    _all?: true
  }

  export type DropPointAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DropPoint to aggregate.
     */
    where?: DropPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropPoints to fetch.
     */
    orderBy?: DropPointOrderByWithRelationInput | DropPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DropPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DropPoints
    **/
    _count?: true | DropPointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DropPointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DropPointMaxAggregateInputType
  }

  export type GetDropPointAggregateType<T extends DropPointAggregateArgs> = {
        [P in keyof T & keyof AggregateDropPoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDropPoint[P]>
      : GetScalarType<T[P], AggregateDropPoint[P]>
  }




  export type DropPointGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DropPointWhereInput
    orderBy?: DropPointOrderByWithAggregationInput | DropPointOrderByWithAggregationInput[]
    by: DropPointScalarFieldEnum[] | DropPointScalarFieldEnum
    having?: DropPointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DropPointCountAggregateInputType | true
    _min?: DropPointMinAggregateInputType
    _max?: DropPointMaxAggregateInputType
  }

  export type DropPointGroupByOutputType = {
    id: string
    name: string
    location: string
    openingTime: string
    closingTime: string
    description: string
    managerId: string | null
    password: string | null
    _count: DropPointCountAggregateOutputType | null
    _min: DropPointMinAggregateOutputType | null
    _max: DropPointMaxAggregateOutputType | null
  }

  type GetDropPointGroupByPayload<T extends DropPointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DropPointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DropPointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DropPointGroupByOutputType[P]>
            : GetScalarType<T[P], DropPointGroupByOutputType[P]>
        }
      >
    >


  export type DropPointSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    location?: boolean
    openingTime?: boolean
    closingTime?: boolean
    description?: boolean
    managerId?: boolean
    password?: boolean
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
    donations?: boolean | DropPoint$donationsArgs<ExtArgs>
    _count?: boolean | DropPointCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dropPoint"]>

  export type DropPointSelectScalar = {
    id?: boolean
    name?: boolean
    location?: boolean
    openingTime?: boolean
    closingTime?: boolean
    description?: boolean
    managerId?: boolean
    password?: boolean
  }

  export type DropPointInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
    donations?: boolean | DropPoint$donationsArgs<ExtArgs>
    _count?: boolean | DropPointCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DropPointPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "DropPoint"
    objects: {
      manager: Prisma.$ManagerPayload<ExtArgs> | null
      donations: Prisma.$DonationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      name: string
      location: string
      openingTime: string
      closingTime: string
      description: string
      managerId: string | null
      password: string | null
    }, ExtArgs["result"]["dropPoint"]>
    composites: {}
  }


  type DropPointGetPayload<S extends boolean | null | undefined | DropPointDefaultArgs> = $Result.GetResult<Prisma.$DropPointPayload, S>

  type DropPointCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DropPointFindManyArgs, 'select' | 'include'> & {
      select?: DropPointCountAggregateInputType | true
    }

  export interface DropPointDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DropPoint'], meta: { name: 'DropPoint' } }
    /**
     * Find zero or one DropPoint that matches the filter.
     * @param {DropPointFindUniqueArgs} args - Arguments to find a DropPoint
     * @example
     * // Get one DropPoint
     * const dropPoint = await prisma.dropPoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DropPointFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DropPointFindUniqueArgs<ExtArgs>>
    ): Prisma__DropPointClient<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one DropPoint that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DropPointFindUniqueOrThrowArgs} args - Arguments to find a DropPoint
     * @example
     * // Get one DropPoint
     * const dropPoint = await prisma.dropPoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DropPointFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DropPointFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DropPointClient<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first DropPoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropPointFindFirstArgs} args - Arguments to find a DropPoint
     * @example
     * // Get one DropPoint
     * const dropPoint = await prisma.dropPoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DropPointFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DropPointFindFirstArgs<ExtArgs>>
    ): Prisma__DropPointClient<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first DropPoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropPointFindFirstOrThrowArgs} args - Arguments to find a DropPoint
     * @example
     * // Get one DropPoint
     * const dropPoint = await prisma.dropPoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DropPointFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DropPointFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DropPointClient<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more DropPoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropPointFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DropPoints
     * const dropPoints = await prisma.dropPoint.findMany()
     * 
     * // Get first 10 DropPoints
     * const dropPoints = await prisma.dropPoint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dropPointWithIdOnly = await prisma.dropPoint.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DropPointFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DropPointFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a DropPoint.
     * @param {DropPointCreateArgs} args - Arguments to create a DropPoint.
     * @example
     * // Create one DropPoint
     * const DropPoint = await prisma.dropPoint.create({
     *   data: {
     *     // ... data to create a DropPoint
     *   }
     * })
     * 
    **/
    create<T extends DropPointCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DropPointCreateArgs<ExtArgs>>
    ): Prisma__DropPointClient<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many DropPoints.
     *     @param {DropPointCreateManyArgs} args - Arguments to create many DropPoints.
     *     @example
     *     // Create many DropPoints
     *     const dropPoint = await prisma.dropPoint.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DropPointCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DropPointCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DropPoint.
     * @param {DropPointDeleteArgs} args - Arguments to delete one DropPoint.
     * @example
     * // Delete one DropPoint
     * const DropPoint = await prisma.dropPoint.delete({
     *   where: {
     *     // ... filter to delete one DropPoint
     *   }
     * })
     * 
    **/
    delete<T extends DropPointDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DropPointDeleteArgs<ExtArgs>>
    ): Prisma__DropPointClient<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one DropPoint.
     * @param {DropPointUpdateArgs} args - Arguments to update one DropPoint.
     * @example
     * // Update one DropPoint
     * const dropPoint = await prisma.dropPoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DropPointUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DropPointUpdateArgs<ExtArgs>>
    ): Prisma__DropPointClient<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more DropPoints.
     * @param {DropPointDeleteManyArgs} args - Arguments to filter DropPoints to delete.
     * @example
     * // Delete a few DropPoints
     * const { count } = await prisma.dropPoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DropPointDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DropPointDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DropPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropPointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DropPoints
     * const dropPoint = await prisma.dropPoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DropPointUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DropPointUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DropPoint.
     * @param {DropPointUpsertArgs} args - Arguments to update or create a DropPoint.
     * @example
     * // Update or create a DropPoint
     * const dropPoint = await prisma.dropPoint.upsert({
     *   create: {
     *     // ... data to create a DropPoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DropPoint we want to update
     *   }
     * })
    **/
    upsert<T extends DropPointUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DropPointUpsertArgs<ExtArgs>>
    ): Prisma__DropPointClient<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more DropPoints that matches the filter.
     * @param {DropPointFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dropPoint = await prisma.dropPoint.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: DropPointFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DropPoint.
     * @param {DropPointAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dropPoint = await prisma.dropPoint.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: DropPointAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of DropPoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropPointCountArgs} args - Arguments to filter DropPoints to count.
     * @example
     * // Count the number of DropPoints
     * const count = await prisma.dropPoint.count({
     *   where: {
     *     // ... the filter for the DropPoints we want to count
     *   }
     * })
    **/
    count<T extends DropPointCountArgs>(
      args?: Subset<T, DropPointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DropPointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DropPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropPointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DropPointAggregateArgs>(args: Subset<T, DropPointAggregateArgs>): Prisma.PrismaPromise<GetDropPointAggregateType<T>>

    /**
     * Group by DropPoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DropPointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DropPointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DropPointGroupByArgs['orderBy'] }
        : { orderBy?: DropPointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DropPointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDropPointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DropPoint model
   */
  readonly fields: DropPointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DropPoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DropPointClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    manager<T extends ManagerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ManagerDefaultArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    donations<T extends DropPoint$donationsArgs<ExtArgs> = {}>(args?: Subset<T, DropPoint$donationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the DropPoint model
   */ 
  interface DropPointFieldRefs {
    readonly id: FieldRef<"DropPoint", 'String'>
    readonly name: FieldRef<"DropPoint", 'String'>
    readonly location: FieldRef<"DropPoint", 'String'>
    readonly openingTime: FieldRef<"DropPoint", 'String'>
    readonly closingTime: FieldRef<"DropPoint", 'String'>
    readonly description: FieldRef<"DropPoint", 'String'>
    readonly managerId: FieldRef<"DropPoint", 'String'>
    readonly password: FieldRef<"DropPoint", 'String'>
  }
    

  // Custom InputTypes

  /**
   * DropPoint findUnique
   */
  export type DropPointFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
    /**
     * Filter, which DropPoint to fetch.
     */
    where: DropPointWhereUniqueInput
  }


  /**
   * DropPoint findUniqueOrThrow
   */
  export type DropPointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
    /**
     * Filter, which DropPoint to fetch.
     */
    where: DropPointWhereUniqueInput
  }


  /**
   * DropPoint findFirst
   */
  export type DropPointFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
    /**
     * Filter, which DropPoint to fetch.
     */
    where?: DropPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropPoints to fetch.
     */
    orderBy?: DropPointOrderByWithRelationInput | DropPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DropPoints.
     */
    cursor?: DropPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DropPoints.
     */
    distinct?: DropPointScalarFieldEnum | DropPointScalarFieldEnum[]
  }


  /**
   * DropPoint findFirstOrThrow
   */
  export type DropPointFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
    /**
     * Filter, which DropPoint to fetch.
     */
    where?: DropPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropPoints to fetch.
     */
    orderBy?: DropPointOrderByWithRelationInput | DropPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DropPoints.
     */
    cursor?: DropPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropPoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DropPoints.
     */
    distinct?: DropPointScalarFieldEnum | DropPointScalarFieldEnum[]
  }


  /**
   * DropPoint findMany
   */
  export type DropPointFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
    /**
     * Filter, which DropPoints to fetch.
     */
    where?: DropPointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DropPoints to fetch.
     */
    orderBy?: DropPointOrderByWithRelationInput | DropPointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DropPoints.
     */
    cursor?: DropPointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DropPoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DropPoints.
     */
    skip?: number
    distinct?: DropPointScalarFieldEnum | DropPointScalarFieldEnum[]
  }


  /**
   * DropPoint create
   */
  export type DropPointCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
    /**
     * The data needed to create a DropPoint.
     */
    data: XOR<DropPointCreateInput, DropPointUncheckedCreateInput>
  }


  /**
   * DropPoint createMany
   */
  export type DropPointCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DropPoints.
     */
    data: DropPointCreateManyInput | DropPointCreateManyInput[]
  }


  /**
   * DropPoint update
   */
  export type DropPointUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
    /**
     * The data needed to update a DropPoint.
     */
    data: XOR<DropPointUpdateInput, DropPointUncheckedUpdateInput>
    /**
     * Choose, which DropPoint to update.
     */
    where: DropPointWhereUniqueInput
  }


  /**
   * DropPoint updateMany
   */
  export type DropPointUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DropPoints.
     */
    data: XOR<DropPointUpdateManyMutationInput, DropPointUncheckedUpdateManyInput>
    /**
     * Filter which DropPoints to update
     */
    where?: DropPointWhereInput
  }


  /**
   * DropPoint upsert
   */
  export type DropPointUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
    /**
     * The filter to search for the DropPoint to update in case it exists.
     */
    where: DropPointWhereUniqueInput
    /**
     * In case the DropPoint found by the `where` argument doesn't exist, create a new DropPoint with this data.
     */
    create: XOR<DropPointCreateInput, DropPointUncheckedCreateInput>
    /**
     * In case the DropPoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DropPointUpdateInput, DropPointUncheckedUpdateInput>
  }


  /**
   * DropPoint delete
   */
  export type DropPointDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
    /**
     * Filter which DropPoint to delete.
     */
    where: DropPointWhereUniqueInput
  }


  /**
   * DropPoint deleteMany
   */
  export type DropPointDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which DropPoints to delete
     */
    where?: DropPointWhereInput
  }


  /**
   * DropPoint findRaw
   */
  export type DropPointFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * DropPoint aggregateRaw
   */
  export type DropPointAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * DropPoint.donations
   */
  export type DropPoint$donationsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    where?: DonationWhereInput
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    cursor?: DonationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }


  /**
   * DropPoint without action
   */
  export type DropPointDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
  }



  /**
   * Model Manager
   */

  export type AggregateManager = {
    _count: ManagerCountAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  export type ManagerMinAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phoneNumber: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ManagerMaxAggregateOutputType = {
    id: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phoneNumber: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ManagerCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    email: number
    phoneNumber: number
    address: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ManagerMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ManagerMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ManagerCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    email?: true
    phoneNumber?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ManagerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Manager to aggregate.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Managers
    **/
    _count?: true | ManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManagerMaxAggregateInputType
  }

  export type GetManagerAggregateType<T extends ManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManager[P]>
      : GetScalarType<T[P], AggregateManager[P]>
  }




  export type ManagerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ManagerWhereInput
    orderBy?: ManagerOrderByWithAggregationInput | ManagerOrderByWithAggregationInput[]
    by: ManagerScalarFieldEnum[] | ManagerScalarFieldEnum
    having?: ManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManagerCountAggregateInputType | true
    _min?: ManagerMinAggregateInputType
    _max?: ManagerMaxAggregateInputType
  }

  export type ManagerGroupByOutputType = {
    id: string
    firstName: string
    lastName: string
    email: string
    phoneNumber: string | null
    address: string | null
    createdAt: Date
    updatedAt: Date
    _count: ManagerCountAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  type GetManagerGroupByPayload<T extends ManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManagerGroupByOutputType[P]>
            : GetScalarType<T[P], ManagerGroupByOutputType[P]>
        }
      >
    >


  export type ManagerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dropPoint?: boolean | Manager$dropPointArgs<ExtArgs>
    _count?: boolean | ManagerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manager"]>

  export type ManagerSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phoneNumber?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ManagerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    dropPoint?: boolean | Manager$dropPointArgs<ExtArgs>
    _count?: boolean | ManagerCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ManagerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Manager"
    objects: {
      dropPoint: Prisma.$DropPointPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      firstName: string
      lastName: string
      email: string
      phoneNumber: string | null
      address: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["manager"]>
    composites: {}
  }


  type ManagerGetPayload<S extends boolean | null | undefined | ManagerDefaultArgs> = $Result.GetResult<Prisma.$ManagerPayload, S>

  type ManagerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ManagerFindManyArgs, 'select' | 'include'> & {
      select?: ManagerCountAggregateInputType | true
    }

  export interface ManagerDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Manager'], meta: { name: 'Manager' } }
    /**
     * Find zero or one Manager that matches the filter.
     * @param {ManagerFindUniqueArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ManagerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ManagerFindUniqueArgs<ExtArgs>>
    ): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Manager that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ManagerFindUniqueOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ManagerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ManagerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Manager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ManagerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ManagerFindFirstArgs<ExtArgs>>
    ): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Manager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ManagerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ManagerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Managers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Managers
     * const managers = await prisma.manager.findMany()
     * 
     * // Get first 10 Managers
     * const managers = await prisma.manager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const managerWithIdOnly = await prisma.manager.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ManagerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ManagerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Manager.
     * @param {ManagerCreateArgs} args - Arguments to create a Manager.
     * @example
     * // Create one Manager
     * const Manager = await prisma.manager.create({
     *   data: {
     *     // ... data to create a Manager
     *   }
     * })
     * 
    **/
    create<T extends ManagerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ManagerCreateArgs<ExtArgs>>
    ): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Managers.
     *     @param {ManagerCreateManyArgs} args - Arguments to create many Managers.
     *     @example
     *     // Create many Managers
     *     const manager = await prisma.manager.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ManagerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ManagerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Manager.
     * @param {ManagerDeleteArgs} args - Arguments to delete one Manager.
     * @example
     * // Delete one Manager
     * const Manager = await prisma.manager.delete({
     *   where: {
     *     // ... filter to delete one Manager
     *   }
     * })
     * 
    **/
    delete<T extends ManagerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ManagerDeleteArgs<ExtArgs>>
    ): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Manager.
     * @param {ManagerUpdateArgs} args - Arguments to update one Manager.
     * @example
     * // Update one Manager
     * const manager = await prisma.manager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ManagerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ManagerUpdateArgs<ExtArgs>>
    ): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Managers.
     * @param {ManagerDeleteManyArgs} args - Arguments to filter Managers to delete.
     * @example
     * // Delete a few Managers
     * const { count } = await prisma.manager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ManagerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ManagerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Managers
     * const manager = await prisma.manager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ManagerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ManagerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Manager.
     * @param {ManagerUpsertArgs} args - Arguments to update or create a Manager.
     * @example
     * // Update or create a Manager
     * const manager = await prisma.manager.upsert({
     *   create: {
     *     // ... data to create a Manager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manager we want to update
     *   }
     * })
    **/
    upsert<T extends ManagerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ManagerUpsertArgs<ExtArgs>>
    ): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Managers that matches the filter.
     * @param {ManagerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const manager = await prisma.manager.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: ManagerFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Manager.
     * @param {ManagerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const manager = await prisma.manager.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: ManagerAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerCountArgs} args - Arguments to filter Managers to count.
     * @example
     * // Count the number of Managers
     * const count = await prisma.manager.count({
     *   where: {
     *     // ... the filter for the Managers we want to count
     *   }
     * })
    **/
    count<T extends ManagerCountArgs>(
      args?: Subset<T, ManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManagerAggregateArgs>(args: Subset<T, ManagerAggregateArgs>): Prisma.PrismaPromise<GetManagerAggregateType<T>>

    /**
     * Group by Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManagerGroupByArgs['orderBy'] }
        : { orderBy?: ManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Manager model
   */
  readonly fields: ManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Manager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManagerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    dropPoint<T extends Manager$dropPointArgs<ExtArgs> = {}>(args?: Subset<T, Manager$dropPointArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Manager model
   */ 
  interface ManagerFieldRefs {
    readonly id: FieldRef<"Manager", 'String'>
    readonly firstName: FieldRef<"Manager", 'String'>
    readonly lastName: FieldRef<"Manager", 'String'>
    readonly email: FieldRef<"Manager", 'String'>
    readonly phoneNumber: FieldRef<"Manager", 'String'>
    readonly address: FieldRef<"Manager", 'String'>
    readonly createdAt: FieldRef<"Manager", 'DateTime'>
    readonly updatedAt: FieldRef<"Manager", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Manager findUnique
   */
  export type ManagerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }


  /**
   * Manager findUniqueOrThrow
   */
  export type ManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }


  /**
   * Manager findFirst
   */
  export type ManagerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }


  /**
   * Manager findFirstOrThrow
   */
  export type ManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }


  /**
   * Manager findMany
   */
  export type ManagerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Managers to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }


  /**
   * Manager create
   */
  export type ManagerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a Manager.
     */
    data: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
  }


  /**
   * Manager createMany
   */
  export type ManagerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Managers.
     */
    data: ManagerCreateManyInput | ManagerCreateManyInput[]
  }


  /**
   * Manager update
   */
  export type ManagerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a Manager.
     */
    data: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
    /**
     * Choose, which Manager to update.
     */
    where: ManagerWhereUniqueInput
  }


  /**
   * Manager updateMany
   */
  export type ManagerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Managers.
     */
    data: XOR<ManagerUpdateManyMutationInput, ManagerUncheckedUpdateManyInput>
    /**
     * Filter which Managers to update
     */
    where?: ManagerWhereInput
  }


  /**
   * Manager upsert
   */
  export type ManagerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the Manager to update in case it exists.
     */
    where: ManagerWhereUniqueInput
    /**
     * In case the Manager found by the `where` argument doesn't exist, create a new Manager with this data.
     */
    create: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
    /**
     * In case the Manager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
  }


  /**
   * Manager delete
   */
  export type ManagerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter which Manager to delete.
     */
    where: ManagerWhereUniqueInput
  }


  /**
   * Manager deleteMany
   */
  export type ManagerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Managers to delete
     */
    where?: ManagerWhereInput
  }


  /**
   * Manager findRaw
   */
  export type ManagerFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Manager aggregateRaw
   */
  export type ManagerAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Manager.dropPoint
   */
  export type Manager$dropPointArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DropPoint
     */
    select?: DropPointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DropPointInclude<ExtArgs> | null
    where?: DropPointWhereInput
    orderBy?: DropPointOrderByWithRelationInput | DropPointOrderByWithRelationInput[]
    cursor?: DropPointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DropPointScalarFieldEnum | DropPointScalarFieldEnum[]
  }


  /**
   * Manager without action
   */
  export type ManagerDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ManagerInclude<ExtArgs> | null
  }



  /**
   * Model Donation
   */

  export type AggregateDonation = {
    _count: DonationCountAggregateOutputType | null
    _avg: DonationAvgAggregateOutputType | null
    _sum: DonationSumAggregateOutputType | null
    _min: DonationMinAggregateOutputType | null
    _max: DonationMaxAggregateOutputType | null
  }

  export type DonationAvgAggregateOutputType = {
    points: number | null
  }

  export type DonationSumAggregateOutputType = {
    points: number | null
  }

  export type DonationMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    dropPointId: string | null
    createdAt: Date | null
    expectedDateOfArrival: Date | null
    confirmedByName: string | null
    confirmedByEmail: string | null
    status: string | null
    isSubmitted: boolean | null
    points: number | null
  }

  export type DonationMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    dropPointId: string | null
    createdAt: Date | null
    expectedDateOfArrival: Date | null
    confirmedByName: string | null
    confirmedByEmail: string | null
    status: string | null
    isSubmitted: boolean | null
    points: number | null
  }

  export type DonationCountAggregateOutputType = {
    id: number
    organizationId: number
    dropPointId: number
    createdAt: number
    expectedDateOfArrival: number
    confirmedByName: number
    confirmedByEmail: number
    status: number
    isSubmitted: number
    points: number
    _all: number
  }


  export type DonationAvgAggregateInputType = {
    points?: true
  }

  export type DonationSumAggregateInputType = {
    points?: true
  }

  export type DonationMinAggregateInputType = {
    id?: true
    organizationId?: true
    dropPointId?: true
    createdAt?: true
    expectedDateOfArrival?: true
    confirmedByName?: true
    confirmedByEmail?: true
    status?: true
    isSubmitted?: true
    points?: true
  }

  export type DonationMaxAggregateInputType = {
    id?: true
    organizationId?: true
    dropPointId?: true
    createdAt?: true
    expectedDateOfArrival?: true
    confirmedByName?: true
    confirmedByEmail?: true
    status?: true
    isSubmitted?: true
    points?: true
  }

  export type DonationCountAggregateInputType = {
    id?: true
    organizationId?: true
    dropPointId?: true
    createdAt?: true
    expectedDateOfArrival?: true
    confirmedByName?: true
    confirmedByEmail?: true
    status?: true
    isSubmitted?: true
    points?: true
    _all?: true
  }

  export type DonationAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Donation to aggregate.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Donations
    **/
    _count?: true | DonationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DonationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DonationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DonationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DonationMaxAggregateInputType
  }

  export type GetDonationAggregateType<T extends DonationAggregateArgs> = {
        [P in keyof T & keyof AggregateDonation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDonation[P]>
      : GetScalarType<T[P], AggregateDonation[P]>
  }




  export type DonationGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: DonationWhereInput
    orderBy?: DonationOrderByWithAggregationInput | DonationOrderByWithAggregationInput[]
    by: DonationScalarFieldEnum[] | DonationScalarFieldEnum
    having?: DonationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DonationCountAggregateInputType | true
    _avg?: DonationAvgAggregateInputType
    _sum?: DonationSumAggregateInputType
    _min?: DonationMinAggregateInputType
    _max?: DonationMaxAggregateInputType
  }

  export type DonationGroupByOutputType = {
    id: string
    organizationId: string
    dropPointId: string
    createdAt: Date
    expectedDateOfArrival: Date | null
    confirmedByName: string | null
    confirmedByEmail: string | null
    status: string | null
    isSubmitted: boolean
    points: number | null
    _count: DonationCountAggregateOutputType | null
    _avg: DonationAvgAggregateOutputType | null
    _sum: DonationSumAggregateOutputType | null
    _min: DonationMinAggregateOutputType | null
    _max: DonationMaxAggregateOutputType | null
  }

  type GetDonationGroupByPayload<T extends DonationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DonationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DonationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DonationGroupByOutputType[P]>
            : GetScalarType<T[P], DonationGroupByOutputType[P]>
        }
      >
    >


  export type DonationSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    dropPointId?: boolean
    createdAt?: boolean
    expectedDateOfArrival?: boolean
    confirmedByName?: boolean
    confirmedByEmail?: boolean
    status?: boolean
    isSubmitted?: boolean
    points?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    dropPoint?: boolean | DropPointDefaultArgs<ExtArgs>
    peripherals?: boolean | Donation$peripheralsArgs<ExtArgs>
    _count?: boolean | DonationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["donation"]>

  export type DonationSelectScalar = {
    id?: boolean
    organizationId?: boolean
    dropPointId?: boolean
    createdAt?: boolean
    expectedDateOfArrival?: boolean
    confirmedByName?: boolean
    confirmedByEmail?: boolean
    status?: boolean
    isSubmitted?: boolean
    points?: boolean
  }

  export type DonationInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    dropPoint?: boolean | DropPointDefaultArgs<ExtArgs>
    peripherals?: boolean | Donation$peripheralsArgs<ExtArgs>
    _count?: boolean | DonationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DonationPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Donation"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      dropPoint: Prisma.$DropPointPayload<ExtArgs>
      peripherals: Prisma.$PeripheralPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      organizationId: string
      dropPointId: string
      createdAt: Date
      expectedDateOfArrival: Date | null
      confirmedByName: string | null
      confirmedByEmail: string | null
      status: string | null
      isSubmitted: boolean
      points: number | null
    }, ExtArgs["result"]["donation"]>
    composites: {}
  }


  type DonationGetPayload<S extends boolean | null | undefined | DonationDefaultArgs> = $Result.GetResult<Prisma.$DonationPayload, S>

  type DonationCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<DonationFindManyArgs, 'select' | 'include'> & {
      select?: DonationCountAggregateInputType | true
    }

  export interface DonationDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Donation'], meta: { name: 'Donation' } }
    /**
     * Find zero or one Donation that matches the filter.
     * @param {DonationFindUniqueArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DonationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DonationFindUniqueArgs<ExtArgs>>
    ): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Donation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DonationFindUniqueOrThrowArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DonationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DonationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Donation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationFindFirstArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DonationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DonationFindFirstArgs<ExtArgs>>
    ): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Donation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationFindFirstOrThrowArgs} args - Arguments to find a Donation
     * @example
     * // Get one Donation
     * const donation = await prisma.donation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DonationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DonationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Donations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Donations
     * const donations = await prisma.donation.findMany()
     * 
     * // Get first 10 Donations
     * const donations = await prisma.donation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const donationWithIdOnly = await prisma.donation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DonationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DonationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Donation.
     * @param {DonationCreateArgs} args - Arguments to create a Donation.
     * @example
     * // Create one Donation
     * const Donation = await prisma.donation.create({
     *   data: {
     *     // ... data to create a Donation
     *   }
     * })
     * 
    **/
    create<T extends DonationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DonationCreateArgs<ExtArgs>>
    ): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Donations.
     *     @param {DonationCreateManyArgs} args - Arguments to create many Donations.
     *     @example
     *     // Create many Donations
     *     const donation = await prisma.donation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DonationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DonationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Donation.
     * @param {DonationDeleteArgs} args - Arguments to delete one Donation.
     * @example
     * // Delete one Donation
     * const Donation = await prisma.donation.delete({
     *   where: {
     *     // ... filter to delete one Donation
     *   }
     * })
     * 
    **/
    delete<T extends DonationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DonationDeleteArgs<ExtArgs>>
    ): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Donation.
     * @param {DonationUpdateArgs} args - Arguments to update one Donation.
     * @example
     * // Update one Donation
     * const donation = await prisma.donation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DonationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DonationUpdateArgs<ExtArgs>>
    ): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Donations.
     * @param {DonationDeleteManyArgs} args - Arguments to filter Donations to delete.
     * @example
     * // Delete a few Donations
     * const { count } = await prisma.donation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DonationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DonationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Donations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Donations
     * const donation = await prisma.donation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DonationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DonationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Donation.
     * @param {DonationUpsertArgs} args - Arguments to update or create a Donation.
     * @example
     * // Update or create a Donation
     * const donation = await prisma.donation.upsert({
     *   create: {
     *     // ... data to create a Donation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Donation we want to update
     *   }
     * })
    **/
    upsert<T extends DonationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DonationUpsertArgs<ExtArgs>>
    ): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Donations that matches the filter.
     * @param {DonationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const donation = await prisma.donation.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: DonationFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Donation.
     * @param {DonationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const donation = await prisma.donation.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: DonationAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Donations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationCountArgs} args - Arguments to filter Donations to count.
     * @example
     * // Count the number of Donations
     * const count = await prisma.donation.count({
     *   where: {
     *     // ... the filter for the Donations we want to count
     *   }
     * })
    **/
    count<T extends DonationCountArgs>(
      args?: Subset<T, DonationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DonationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Donation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DonationAggregateArgs>(args: Subset<T, DonationAggregateArgs>): Prisma.PrismaPromise<GetDonationAggregateType<T>>

    /**
     * Group by Donation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DonationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DonationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DonationGroupByArgs['orderBy'] }
        : { orderBy?: DonationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DonationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDonationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Donation model
   */
  readonly fields: DonationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Donation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DonationClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    dropPoint<T extends DropPointDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DropPointDefaultArgs<ExtArgs>>): Prisma__DropPointClient<$Result.GetResult<Prisma.$DropPointPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    peripherals<T extends Donation$peripheralsArgs<ExtArgs> = {}>(args?: Subset<T, Donation$peripheralsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeripheralPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Donation model
   */ 
  interface DonationFieldRefs {
    readonly id: FieldRef<"Donation", 'String'>
    readonly organizationId: FieldRef<"Donation", 'String'>
    readonly dropPointId: FieldRef<"Donation", 'String'>
    readonly createdAt: FieldRef<"Donation", 'DateTime'>
    readonly expectedDateOfArrival: FieldRef<"Donation", 'DateTime'>
    readonly confirmedByName: FieldRef<"Donation", 'String'>
    readonly confirmedByEmail: FieldRef<"Donation", 'String'>
    readonly status: FieldRef<"Donation", 'String'>
    readonly isSubmitted: FieldRef<"Donation", 'Boolean'>
    readonly points: FieldRef<"Donation", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * Donation findUnique
   */
  export type DonationFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where: DonationWhereUniqueInput
  }


  /**
   * Donation findUniqueOrThrow
   */
  export type DonationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where: DonationWhereUniqueInput
  }


  /**
   * Donation findFirst
   */
  export type DonationFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Donations.
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Donations.
     */
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }


  /**
   * Donation findFirstOrThrow
   */
  export type DonationFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donation to fetch.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Donations.
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Donations.
     */
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }


  /**
   * Donation findMany
   */
  export type DonationFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter, which Donations to fetch.
     */
    where?: DonationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Donations to fetch.
     */
    orderBy?: DonationOrderByWithRelationInput | DonationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Donations.
     */
    cursor?: DonationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Donations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Donations.
     */
    skip?: number
    distinct?: DonationScalarFieldEnum | DonationScalarFieldEnum[]
  }


  /**
   * Donation create
   */
  export type DonationCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * The data needed to create a Donation.
     */
    data: XOR<DonationCreateInput, DonationUncheckedCreateInput>
  }


  /**
   * Donation createMany
   */
  export type DonationCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Donations.
     */
    data: DonationCreateManyInput | DonationCreateManyInput[]
  }


  /**
   * Donation update
   */
  export type DonationUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * The data needed to update a Donation.
     */
    data: XOR<DonationUpdateInput, DonationUncheckedUpdateInput>
    /**
     * Choose, which Donation to update.
     */
    where: DonationWhereUniqueInput
  }


  /**
   * Donation updateMany
   */
  export type DonationUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Donations.
     */
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyInput>
    /**
     * Filter which Donations to update
     */
    where?: DonationWhereInput
  }


  /**
   * Donation upsert
   */
  export type DonationUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * The filter to search for the Donation to update in case it exists.
     */
    where: DonationWhereUniqueInput
    /**
     * In case the Donation found by the `where` argument doesn't exist, create a new Donation with this data.
     */
    create: XOR<DonationCreateInput, DonationUncheckedCreateInput>
    /**
     * In case the Donation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DonationUpdateInput, DonationUncheckedUpdateInput>
  }


  /**
   * Donation delete
   */
  export type DonationDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
    /**
     * Filter which Donation to delete.
     */
    where: DonationWhereUniqueInput
  }


  /**
   * Donation deleteMany
   */
  export type DonationDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Donations to delete
     */
    where?: DonationWhereInput
  }


  /**
   * Donation findRaw
   */
  export type DonationFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Donation aggregateRaw
   */
  export type DonationAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Donation.peripherals
   */
  export type Donation$peripheralsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
    where?: PeripheralWhereInput
    orderBy?: PeripheralOrderByWithRelationInput | PeripheralOrderByWithRelationInput[]
    cursor?: PeripheralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PeripheralScalarFieldEnum | PeripheralScalarFieldEnum[]
  }


  /**
   * Donation without action
   */
  export type DonationDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Donation
     */
    select?: DonationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DonationInclude<ExtArgs> | null
  }



  /**
   * Model Peripheral
   */

  export type AggregatePeripheral = {
    _count: PeripheralCountAggregateOutputType | null
    _avg: PeripheralAvgAggregateOutputType | null
    _sum: PeripheralSumAggregateOutputType | null
    _min: PeripheralMinAggregateOutputType | null
    _max: PeripheralMaxAggregateOutputType | null
  }

  export type PeripheralAvgAggregateOutputType = {
    quantity: number | null
  }

  export type PeripheralSumAggregateOutputType = {
    quantity: number | null
  }

  export type PeripheralMinAggregateOutputType = {
    id: string | null
    type: string | null
    brand: string | null
    model: string | null
    condition: string | null
    quantity: number | null
    donationId: string | null
  }

  export type PeripheralMaxAggregateOutputType = {
    id: string | null
    type: string | null
    brand: string | null
    model: string | null
    condition: string | null
    quantity: number | null
    donationId: string | null
  }

  export type PeripheralCountAggregateOutputType = {
    id: number
    type: number
    brand: number
    model: number
    condition: number
    quantity: number
    donationId: number
    _all: number
  }


  export type PeripheralAvgAggregateInputType = {
    quantity?: true
  }

  export type PeripheralSumAggregateInputType = {
    quantity?: true
  }

  export type PeripheralMinAggregateInputType = {
    id?: true
    type?: true
    brand?: true
    model?: true
    condition?: true
    quantity?: true
    donationId?: true
  }

  export type PeripheralMaxAggregateInputType = {
    id?: true
    type?: true
    brand?: true
    model?: true
    condition?: true
    quantity?: true
    donationId?: true
  }

  export type PeripheralCountAggregateInputType = {
    id?: true
    type?: true
    brand?: true
    model?: true
    condition?: true
    quantity?: true
    donationId?: true
    _all?: true
  }

  export type PeripheralAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Peripheral to aggregate.
     */
    where?: PeripheralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Peripherals to fetch.
     */
    orderBy?: PeripheralOrderByWithRelationInput | PeripheralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PeripheralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Peripherals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Peripherals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Peripherals
    **/
    _count?: true | PeripheralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PeripheralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PeripheralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PeripheralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PeripheralMaxAggregateInputType
  }

  export type GetPeripheralAggregateType<T extends PeripheralAggregateArgs> = {
        [P in keyof T & keyof AggregatePeripheral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePeripheral[P]>
      : GetScalarType<T[P], AggregatePeripheral[P]>
  }




  export type PeripheralGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PeripheralWhereInput
    orderBy?: PeripheralOrderByWithAggregationInput | PeripheralOrderByWithAggregationInput[]
    by: PeripheralScalarFieldEnum[] | PeripheralScalarFieldEnum
    having?: PeripheralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PeripheralCountAggregateInputType | true
    _avg?: PeripheralAvgAggregateInputType
    _sum?: PeripheralSumAggregateInputType
    _min?: PeripheralMinAggregateInputType
    _max?: PeripheralMaxAggregateInputType
  }

  export type PeripheralGroupByOutputType = {
    id: string
    type: string
    brand: string
    model: string
    condition: string
    quantity: number
    donationId: string
    _count: PeripheralCountAggregateOutputType | null
    _avg: PeripheralAvgAggregateOutputType | null
    _sum: PeripheralSumAggregateOutputType | null
    _min: PeripheralMinAggregateOutputType | null
    _max: PeripheralMaxAggregateOutputType | null
  }

  type GetPeripheralGroupByPayload<T extends PeripheralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PeripheralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PeripheralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PeripheralGroupByOutputType[P]>
            : GetScalarType<T[P], PeripheralGroupByOutputType[P]>
        }
      >
    >


  export type PeripheralSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    brand?: boolean
    model?: boolean
    condition?: boolean
    quantity?: boolean
    donationId?: boolean
    donation?: boolean | DonationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["peripheral"]>

  export type PeripheralSelectScalar = {
    id?: boolean
    type?: boolean
    brand?: boolean
    model?: boolean
    condition?: boolean
    quantity?: boolean
    donationId?: boolean
  }

  export type PeripheralInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    donation?: boolean | DonationDefaultArgs<ExtArgs>
  }


  export type $PeripheralPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Peripheral"
    objects: {
      donation: Prisma.$DonationPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      type: string
      brand: string
      model: string
      condition: string
      quantity: number
      donationId: string
    }, ExtArgs["result"]["peripheral"]>
    composites: {}
  }


  type PeripheralGetPayload<S extends boolean | null | undefined | PeripheralDefaultArgs> = $Result.GetResult<Prisma.$PeripheralPayload, S>

  type PeripheralCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PeripheralFindManyArgs, 'select' | 'include'> & {
      select?: PeripheralCountAggregateInputType | true
    }

  export interface PeripheralDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Peripheral'], meta: { name: 'Peripheral' } }
    /**
     * Find zero or one Peripheral that matches the filter.
     * @param {PeripheralFindUniqueArgs} args - Arguments to find a Peripheral
     * @example
     * // Get one Peripheral
     * const peripheral = await prisma.peripheral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PeripheralFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PeripheralFindUniqueArgs<ExtArgs>>
    ): Prisma__PeripheralClient<$Result.GetResult<Prisma.$PeripheralPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Peripheral that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PeripheralFindUniqueOrThrowArgs} args - Arguments to find a Peripheral
     * @example
     * // Get one Peripheral
     * const peripheral = await prisma.peripheral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PeripheralFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PeripheralFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PeripheralClient<$Result.GetResult<Prisma.$PeripheralPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Peripheral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeripheralFindFirstArgs} args - Arguments to find a Peripheral
     * @example
     * // Get one Peripheral
     * const peripheral = await prisma.peripheral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PeripheralFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PeripheralFindFirstArgs<ExtArgs>>
    ): Prisma__PeripheralClient<$Result.GetResult<Prisma.$PeripheralPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Peripheral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeripheralFindFirstOrThrowArgs} args - Arguments to find a Peripheral
     * @example
     * // Get one Peripheral
     * const peripheral = await prisma.peripheral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PeripheralFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PeripheralFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PeripheralClient<$Result.GetResult<Prisma.$PeripheralPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Peripherals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeripheralFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Peripherals
     * const peripherals = await prisma.peripheral.findMany()
     * 
     * // Get first 10 Peripherals
     * const peripherals = await prisma.peripheral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const peripheralWithIdOnly = await prisma.peripheral.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PeripheralFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PeripheralFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PeripheralPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Peripheral.
     * @param {PeripheralCreateArgs} args - Arguments to create a Peripheral.
     * @example
     * // Create one Peripheral
     * const Peripheral = await prisma.peripheral.create({
     *   data: {
     *     // ... data to create a Peripheral
     *   }
     * })
     * 
    **/
    create<T extends PeripheralCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PeripheralCreateArgs<ExtArgs>>
    ): Prisma__PeripheralClient<$Result.GetResult<Prisma.$PeripheralPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Peripherals.
     *     @param {PeripheralCreateManyArgs} args - Arguments to create many Peripherals.
     *     @example
     *     // Create many Peripherals
     *     const peripheral = await prisma.peripheral.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PeripheralCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PeripheralCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Peripheral.
     * @param {PeripheralDeleteArgs} args - Arguments to delete one Peripheral.
     * @example
     * // Delete one Peripheral
     * const Peripheral = await prisma.peripheral.delete({
     *   where: {
     *     // ... filter to delete one Peripheral
     *   }
     * })
     * 
    **/
    delete<T extends PeripheralDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PeripheralDeleteArgs<ExtArgs>>
    ): Prisma__PeripheralClient<$Result.GetResult<Prisma.$PeripheralPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Peripheral.
     * @param {PeripheralUpdateArgs} args - Arguments to update one Peripheral.
     * @example
     * // Update one Peripheral
     * const peripheral = await prisma.peripheral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PeripheralUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PeripheralUpdateArgs<ExtArgs>>
    ): Prisma__PeripheralClient<$Result.GetResult<Prisma.$PeripheralPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Peripherals.
     * @param {PeripheralDeleteManyArgs} args - Arguments to filter Peripherals to delete.
     * @example
     * // Delete a few Peripherals
     * const { count } = await prisma.peripheral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PeripheralDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PeripheralDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Peripherals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeripheralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Peripherals
     * const peripheral = await prisma.peripheral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PeripheralUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PeripheralUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Peripheral.
     * @param {PeripheralUpsertArgs} args - Arguments to update or create a Peripheral.
     * @example
     * // Update or create a Peripheral
     * const peripheral = await prisma.peripheral.upsert({
     *   create: {
     *     // ... data to create a Peripheral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Peripheral we want to update
     *   }
     * })
    **/
    upsert<T extends PeripheralUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PeripheralUpsertArgs<ExtArgs>>
    ): Prisma__PeripheralClient<$Result.GetResult<Prisma.$PeripheralPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Peripherals that matches the filter.
     * @param {PeripheralFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const peripheral = await prisma.peripheral.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: PeripheralFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Peripheral.
     * @param {PeripheralAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const peripheral = await prisma.peripheral.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: PeripheralAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Peripherals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeripheralCountArgs} args - Arguments to filter Peripherals to count.
     * @example
     * // Count the number of Peripherals
     * const count = await prisma.peripheral.count({
     *   where: {
     *     // ... the filter for the Peripherals we want to count
     *   }
     * })
    **/
    count<T extends PeripheralCountArgs>(
      args?: Subset<T, PeripheralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PeripheralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Peripheral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeripheralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PeripheralAggregateArgs>(args: Subset<T, PeripheralAggregateArgs>): Prisma.PrismaPromise<GetPeripheralAggregateType<T>>

    /**
     * Group by Peripheral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PeripheralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PeripheralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PeripheralGroupByArgs['orderBy'] }
        : { orderBy?: PeripheralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PeripheralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPeripheralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Peripheral model
   */
  readonly fields: PeripheralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Peripheral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PeripheralClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    donation<T extends DonationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DonationDefaultArgs<ExtArgs>>): Prisma__DonationClient<$Result.GetResult<Prisma.$DonationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Peripheral model
   */ 
  interface PeripheralFieldRefs {
    readonly id: FieldRef<"Peripheral", 'String'>
    readonly type: FieldRef<"Peripheral", 'String'>
    readonly brand: FieldRef<"Peripheral", 'String'>
    readonly model: FieldRef<"Peripheral", 'String'>
    readonly condition: FieldRef<"Peripheral", 'String'>
    readonly quantity: FieldRef<"Peripheral", 'Int'>
    readonly donationId: FieldRef<"Peripheral", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Peripheral findUnique
   */
  export type PeripheralFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
    /**
     * Filter, which Peripheral to fetch.
     */
    where: PeripheralWhereUniqueInput
  }


  /**
   * Peripheral findUniqueOrThrow
   */
  export type PeripheralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
    /**
     * Filter, which Peripheral to fetch.
     */
    where: PeripheralWhereUniqueInput
  }


  /**
   * Peripheral findFirst
   */
  export type PeripheralFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
    /**
     * Filter, which Peripheral to fetch.
     */
    where?: PeripheralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Peripherals to fetch.
     */
    orderBy?: PeripheralOrderByWithRelationInput | PeripheralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Peripherals.
     */
    cursor?: PeripheralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Peripherals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Peripherals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Peripherals.
     */
    distinct?: PeripheralScalarFieldEnum | PeripheralScalarFieldEnum[]
  }


  /**
   * Peripheral findFirstOrThrow
   */
  export type PeripheralFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
    /**
     * Filter, which Peripheral to fetch.
     */
    where?: PeripheralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Peripherals to fetch.
     */
    orderBy?: PeripheralOrderByWithRelationInput | PeripheralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Peripherals.
     */
    cursor?: PeripheralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Peripherals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Peripherals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Peripherals.
     */
    distinct?: PeripheralScalarFieldEnum | PeripheralScalarFieldEnum[]
  }


  /**
   * Peripheral findMany
   */
  export type PeripheralFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
    /**
     * Filter, which Peripherals to fetch.
     */
    where?: PeripheralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Peripherals to fetch.
     */
    orderBy?: PeripheralOrderByWithRelationInput | PeripheralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Peripherals.
     */
    cursor?: PeripheralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Peripherals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Peripherals.
     */
    skip?: number
    distinct?: PeripheralScalarFieldEnum | PeripheralScalarFieldEnum[]
  }


  /**
   * Peripheral create
   */
  export type PeripheralCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
    /**
     * The data needed to create a Peripheral.
     */
    data: XOR<PeripheralCreateInput, PeripheralUncheckedCreateInput>
  }


  /**
   * Peripheral createMany
   */
  export type PeripheralCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Peripherals.
     */
    data: PeripheralCreateManyInput | PeripheralCreateManyInput[]
  }


  /**
   * Peripheral update
   */
  export type PeripheralUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
    /**
     * The data needed to update a Peripheral.
     */
    data: XOR<PeripheralUpdateInput, PeripheralUncheckedUpdateInput>
    /**
     * Choose, which Peripheral to update.
     */
    where: PeripheralWhereUniqueInput
  }


  /**
   * Peripheral updateMany
   */
  export type PeripheralUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Peripherals.
     */
    data: XOR<PeripheralUpdateManyMutationInput, PeripheralUncheckedUpdateManyInput>
    /**
     * Filter which Peripherals to update
     */
    where?: PeripheralWhereInput
  }


  /**
   * Peripheral upsert
   */
  export type PeripheralUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
    /**
     * The filter to search for the Peripheral to update in case it exists.
     */
    where: PeripheralWhereUniqueInput
    /**
     * In case the Peripheral found by the `where` argument doesn't exist, create a new Peripheral with this data.
     */
    create: XOR<PeripheralCreateInput, PeripheralUncheckedCreateInput>
    /**
     * In case the Peripheral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PeripheralUpdateInput, PeripheralUncheckedUpdateInput>
  }


  /**
   * Peripheral delete
   */
  export type PeripheralDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
    /**
     * Filter which Peripheral to delete.
     */
    where: PeripheralWhereUniqueInput
  }


  /**
   * Peripheral deleteMany
   */
  export type PeripheralDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Peripherals to delete
     */
    where?: PeripheralWhereInput
  }


  /**
   * Peripheral findRaw
   */
  export type PeripheralFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Peripheral aggregateRaw
   */
  export type PeripheralAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Peripheral without action
   */
  export type PeripheralDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Peripheral
     */
    select?: PeripheralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PeripheralInclude<ExtArgs> | null
  }



  /**
   * Model City
   */

  export type AggregateCity = {
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  export type CityAvgAggregateOutputType = {
    requiredPoints: number | null
  }

  export type CitySumAggregateOutputType = {
    requiredPoints: number | null
  }

  export type CityMinAggregateOutputType = {
    id: string | null
    name: string | null
    requiredPoints: number | null
  }

  export type CityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    requiredPoints: number | null
  }

  export type CityCountAggregateOutputType = {
    id: number
    name: number
    requiredPoints: number
    _all: number
  }


  export type CityAvgAggregateInputType = {
    requiredPoints?: true
  }

  export type CitySumAggregateInputType = {
    requiredPoints?: true
  }

  export type CityMinAggregateInputType = {
    id?: true
    name?: true
    requiredPoints?: true
  }

  export type CityMaxAggregateInputType = {
    id?: true
    name?: true
    requiredPoints?: true
  }

  export type CityCountAggregateInputType = {
    id?: true
    name?: true
    requiredPoints?: true
    _all?: true
  }

  export type CityAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which City to aggregate.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cities
    **/
    _count?: true | CityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CityMaxAggregateInputType
  }

  export type GetCityAggregateType<T extends CityAggregateArgs> = {
        [P in keyof T & keyof AggregateCity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCity[P]>
      : GetScalarType<T[P], AggregateCity[P]>
  }




  export type CityGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: CityWhereInput
    orderBy?: CityOrderByWithAggregationInput | CityOrderByWithAggregationInput[]
    by: CityScalarFieldEnum[] | CityScalarFieldEnum
    having?: CityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CityCountAggregateInputType | true
    _avg?: CityAvgAggregateInputType
    _sum?: CitySumAggregateInputType
    _min?: CityMinAggregateInputType
    _max?: CityMaxAggregateInputType
  }

  export type CityGroupByOutputType = {
    id: string
    name: string
    requiredPoints: number | null
    _count: CityCountAggregateOutputType | null
    _avg: CityAvgAggregateOutputType | null
    _sum: CitySumAggregateOutputType | null
    _min: CityMinAggregateOutputType | null
    _max: CityMaxAggregateOutputType | null
  }

  type GetCityGroupByPayload<T extends CityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CityGroupByOutputType[P]>
            : GetScalarType<T[P], CityGroupByOutputType[P]>
        }
      >
    >


  export type CitySelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    requiredPoints?: boolean
    users?: boolean | City$usersArgs<ExtArgs>
    advertisements?: boolean | City$advertisementsArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["city"]>

  export type CitySelectScalar = {
    id?: boolean
    name?: boolean
    requiredPoints?: boolean
  }

  export type CityInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    users?: boolean | City$usersArgs<ExtArgs>
    advertisements?: boolean | City$advertisementsArgs<ExtArgs>
    _count?: boolean | CityCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CityPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "City"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      advertisements: Prisma.$AdvertisementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      name: string
      requiredPoints: number | null
    }, ExtArgs["result"]["city"]>
    composites: {}
  }


  type CityGetPayload<S extends boolean | null | undefined | CityDefaultArgs> = $Result.GetResult<Prisma.$CityPayload, S>

  type CityCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<CityFindManyArgs, 'select' | 'include'> & {
      select?: CityCountAggregateInputType | true
    }

  export interface CityDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['City'], meta: { name: 'City' } }
    /**
     * Find zero or one City that matches the filter.
     * @param {CityFindUniqueArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CityFindUniqueArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one City that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CityFindUniqueOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first City that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CityFindFirstArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first City that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindFirstOrThrowArgs} args - Arguments to find a City
     * @example
     * // Get one City
     * const city = await prisma.city.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.city.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.city.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cityWithIdOnly = await prisma.city.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a City.
     * @param {CityCreateArgs} args - Arguments to create a City.
     * @example
     * // Create one City
     * const City = await prisma.city.create({
     *   data: {
     *     // ... data to create a City
     *   }
     * })
     * 
    **/
    create<T extends CityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CityCreateArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Cities.
     *     @param {CityCreateManyArgs} args - Arguments to create many Cities.
     *     @example
     *     // Create many Cities
     *     const city = await prisma.city.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a City.
     * @param {CityDeleteArgs} args - Arguments to delete one City.
     * @example
     * // Delete one City
     * const City = await prisma.city.delete({
     *   where: {
     *     // ... filter to delete one City
     *   }
     * })
     * 
    **/
    delete<T extends CityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CityDeleteArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one City.
     * @param {CityUpdateArgs} args - Arguments to update one City.
     * @example
     * // Update one City
     * const city = await prisma.city.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CityUpdateArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Cities.
     * @param {CityDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.city.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const city = await prisma.city.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one City.
     * @param {CityUpsertArgs} args - Arguments to update or create a City.
     * @example
     * // Update or create a City
     * const city = await prisma.city.upsert({
     *   create: {
     *     // ... data to create a City
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the City we want to update
     *   }
     * })
    **/
    upsert<T extends CityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CityUpsertArgs<ExtArgs>>
    ): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Cities that matches the filter.
     * @param {CityFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const city = await prisma.city.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: CityFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a City.
     * @param {CityAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const city = await prisma.city.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: CityAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.city.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends CityCountArgs>(
      args?: Subset<T, CityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CityAggregateArgs>(args: Subset<T, CityAggregateArgs>): Prisma.PrismaPromise<GetCityAggregateType<T>>

    /**
     * Group by City.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CityGroupByArgs['orderBy'] }
        : { orderBy?: CityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the City model
   */
  readonly fields: CityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for City.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CityClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    users<T extends City$usersArgs<ExtArgs> = {}>(args?: Subset<T, City$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'> | Null>;

    advertisements<T extends City$advertisementsArgs<ExtArgs> = {}>(args?: Subset<T, City$advertisementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the City model
   */ 
  interface CityFieldRefs {
    readonly id: FieldRef<"City", 'String'>
    readonly name: FieldRef<"City", 'String'>
    readonly requiredPoints: FieldRef<"City", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * City findUnique
   */
  export type CityFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }


  /**
   * City findUniqueOrThrow
   */
  export type CityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where: CityWhereUniqueInput
  }


  /**
   * City findFirst
   */
  export type CityFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }


  /**
   * City findFirstOrThrow
   */
  export type CityFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which City to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cities.
     */
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }


  /**
   * City findMany
   */
  export type CityFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter, which Cities to fetch.
     */
    where?: CityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cities to fetch.
     */
    orderBy?: CityOrderByWithRelationInput | CityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cities.
     */
    cursor?: CityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cities.
     */
    skip?: number
    distinct?: CityScalarFieldEnum | CityScalarFieldEnum[]
  }


  /**
   * City create
   */
  export type CityCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to create a City.
     */
    data: XOR<CityCreateInput, CityUncheckedCreateInput>
  }


  /**
   * City createMany
   */
  export type CityCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cities.
     */
    data: CityCreateManyInput | CityCreateManyInput[]
  }


  /**
   * City update
   */
  export type CityUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The data needed to update a City.
     */
    data: XOR<CityUpdateInput, CityUncheckedUpdateInput>
    /**
     * Choose, which City to update.
     */
    where: CityWhereUniqueInput
  }


  /**
   * City updateMany
   */
  export type CityUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cities.
     */
    data: XOR<CityUpdateManyMutationInput, CityUncheckedUpdateManyInput>
    /**
     * Filter which Cities to update
     */
    where?: CityWhereInput
  }


  /**
   * City upsert
   */
  export type CityUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * The filter to search for the City to update in case it exists.
     */
    where: CityWhereUniqueInput
    /**
     * In case the City found by the `where` argument doesn't exist, create a new City with this data.
     */
    create: XOR<CityCreateInput, CityUncheckedCreateInput>
    /**
     * In case the City was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CityUpdateInput, CityUncheckedUpdateInput>
  }


  /**
   * City delete
   */
  export type CityDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
    /**
     * Filter which City to delete.
     */
    where: CityWhereUniqueInput
  }


  /**
   * City deleteMany
   */
  export type CityDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cities to delete
     */
    where?: CityWhereInput
  }


  /**
   * City findRaw
   */
  export type CityFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * City aggregateRaw
   */
  export type CityAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * City.users
   */
  export type City$usersArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * City.advertisements
   */
  export type City$advertisementsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    where?: AdvertisementWhereInput
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    cursor?: AdvertisementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }


  /**
   * City without action
   */
  export type CityDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the City
     */
    select?: CitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CityInclude<ExtArgs> | null
  }



  /**
   * Model Advertisement
   */

  export type AggregateAdvertisement = {
    _count: AdvertisementCountAggregateOutputType | null
    _avg: AdvertisementAvgAggregateOutputType | null
    _sum: AdvertisementSumAggregateOutputType | null
    _min: AdvertisementMinAggregateOutputType | null
    _max: AdvertisementMaxAggregateOutputType | null
  }

  export type AdvertisementAvgAggregateOutputType = {
    pointsSpent: number | null
  }

  export type AdvertisementSumAggregateOutputType = {
    pointsSpent: number | null
  }

  export type AdvertisementMinAggregateOutputType = {
    id: string | null
    organizationId: string | null
    cityId: string | null
    title: string | null
    content: string | null
    pointsSpent: number | null
    link: string | null
    imageUrl: Buffer | null
    isActive: boolean | null
    startDate: Date | null
    expiryDate: Date | null
  }

  export type AdvertisementMaxAggregateOutputType = {
    id: string | null
    organizationId: string | null
    cityId: string | null
    title: string | null
    content: string | null
    pointsSpent: number | null
    link: string | null
    imageUrl: Buffer | null
    isActive: boolean | null
    startDate: Date | null
    expiryDate: Date | null
  }

  export type AdvertisementCountAggregateOutputType = {
    id: number
    organizationId: number
    cityId: number
    title: number
    content: number
    pointsSpent: number
    link: number
    imageUrl: number
    isActive: number
    startDate: number
    expiryDate: number
    _all: number
  }


  export type AdvertisementAvgAggregateInputType = {
    pointsSpent?: true
  }

  export type AdvertisementSumAggregateInputType = {
    pointsSpent?: true
  }

  export type AdvertisementMinAggregateInputType = {
    id?: true
    organizationId?: true
    cityId?: true
    title?: true
    content?: true
    pointsSpent?: true
    link?: true
    imageUrl?: true
    isActive?: true
    startDate?: true
    expiryDate?: true
  }

  export type AdvertisementMaxAggregateInputType = {
    id?: true
    organizationId?: true
    cityId?: true
    title?: true
    content?: true
    pointsSpent?: true
    link?: true
    imageUrl?: true
    isActive?: true
    startDate?: true
    expiryDate?: true
  }

  export type AdvertisementCountAggregateInputType = {
    id?: true
    organizationId?: true
    cityId?: true
    title?: true
    content?: true
    pointsSpent?: true
    link?: true
    imageUrl?: true
    isActive?: true
    startDate?: true
    expiryDate?: true
    _all?: true
  }

  export type AdvertisementAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advertisement to aggregate.
     */
    where?: AdvertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
     */
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdvertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Advertisements
    **/
    _count?: true | AdvertisementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdvertisementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdvertisementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdvertisementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdvertisementMaxAggregateInputType
  }

  export type GetAdvertisementAggregateType<T extends AdvertisementAggregateArgs> = {
        [P in keyof T & keyof AggregateAdvertisement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdvertisement[P]>
      : GetScalarType<T[P], AggregateAdvertisement[P]>
  }




  export type AdvertisementGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AdvertisementWhereInput
    orderBy?: AdvertisementOrderByWithAggregationInput | AdvertisementOrderByWithAggregationInput[]
    by: AdvertisementScalarFieldEnum[] | AdvertisementScalarFieldEnum
    having?: AdvertisementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdvertisementCountAggregateInputType | true
    _avg?: AdvertisementAvgAggregateInputType
    _sum?: AdvertisementSumAggregateInputType
    _min?: AdvertisementMinAggregateInputType
    _max?: AdvertisementMaxAggregateInputType
  }

  export type AdvertisementGroupByOutputType = {
    id: string
    organizationId: string
    cityId: string
    title: string
    content: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate: Date
    expiryDate: Date
    _count: AdvertisementCountAggregateOutputType | null
    _avg: AdvertisementAvgAggregateOutputType | null
    _sum: AdvertisementSumAggregateOutputType | null
    _min: AdvertisementMinAggregateOutputType | null
    _max: AdvertisementMaxAggregateOutputType | null
  }

  type GetAdvertisementGroupByPayload<T extends AdvertisementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdvertisementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdvertisementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdvertisementGroupByOutputType[P]>
            : GetScalarType<T[P], AdvertisementGroupByOutputType[P]>
        }
      >
    >


  export type AdvertisementSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    cityId?: boolean
    title?: boolean
    content?: boolean
    pointsSpent?: boolean
    link?: boolean
    imageUrl?: boolean
    isActive?: boolean
    startDate?: boolean
    expiryDate?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    interactions?: boolean | Advertisement$interactionsArgs<ExtArgs>
    _count?: boolean | AdvertisementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["advertisement"]>

  export type AdvertisementSelectScalar = {
    id?: boolean
    organizationId?: boolean
    cityId?: boolean
    title?: boolean
    content?: boolean
    pointsSpent?: boolean
    link?: boolean
    imageUrl?: boolean
    isActive?: boolean
    startDate?: boolean
    expiryDate?: boolean
  }

  export type AdvertisementInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    city?: boolean | CityDefaultArgs<ExtArgs>
    interactions?: boolean | Advertisement$interactionsArgs<ExtArgs>
    _count?: boolean | AdvertisementCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AdvertisementPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "Advertisement"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      city: Prisma.$CityPayload<ExtArgs>
      interactions: Prisma.$AdInteractionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetResult<{
      id: string
      organizationId: string
      cityId: string
      title: string
      content: string
      pointsSpent: number
      link: string
      imageUrl: Buffer
      isActive: boolean
      startDate: Date
      expiryDate: Date
    }, ExtArgs["result"]["advertisement"]>
    composites: {}
  }


  type AdvertisementGetPayload<S extends boolean | null | undefined | AdvertisementDefaultArgs> = $Result.GetResult<Prisma.$AdvertisementPayload, S>

  type AdvertisementCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AdvertisementFindManyArgs, 'select' | 'include'> & {
      select?: AdvertisementCountAggregateInputType | true
    }

  export interface AdvertisementDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Advertisement'], meta: { name: 'Advertisement' } }
    /**
     * Find zero or one Advertisement that matches the filter.
     * @param {AdvertisementFindUniqueArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdvertisementFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdvertisementFindUniqueArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Advertisement that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdvertisementFindUniqueOrThrowArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdvertisementFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvertisementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Advertisement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementFindFirstArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdvertisementFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvertisementFindFirstArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Advertisement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementFindFirstOrThrowArgs} args - Arguments to find a Advertisement
     * @example
     * // Get one Advertisement
     * const advertisement = await prisma.advertisement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdvertisementFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvertisementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Advertisements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Advertisements
     * const advertisements = await prisma.advertisement.findMany()
     * 
     * // Get first 10 Advertisements
     * const advertisements = await prisma.advertisement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const advertisementWithIdOnly = await prisma.advertisement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdvertisementFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvertisementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Advertisement.
     * @param {AdvertisementCreateArgs} args - Arguments to create a Advertisement.
     * @example
     * // Create one Advertisement
     * const Advertisement = await prisma.advertisement.create({
     *   data: {
     *     // ... data to create a Advertisement
     *   }
     * })
     * 
    **/
    create<T extends AdvertisementCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdvertisementCreateArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Advertisements.
     *     @param {AdvertisementCreateManyArgs} args - Arguments to create many Advertisements.
     *     @example
     *     // Create many Advertisements
     *     const advertisement = await prisma.advertisement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdvertisementCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvertisementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Advertisement.
     * @param {AdvertisementDeleteArgs} args - Arguments to delete one Advertisement.
     * @example
     * // Delete one Advertisement
     * const Advertisement = await prisma.advertisement.delete({
     *   where: {
     *     // ... filter to delete one Advertisement
     *   }
     * })
     * 
    **/
    delete<T extends AdvertisementDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdvertisementDeleteArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Advertisement.
     * @param {AdvertisementUpdateArgs} args - Arguments to update one Advertisement.
     * @example
     * // Update one Advertisement
     * const advertisement = await prisma.advertisement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdvertisementUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdvertisementUpdateArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Advertisements.
     * @param {AdvertisementDeleteManyArgs} args - Arguments to filter Advertisements to delete.
     * @example
     * // Delete a few Advertisements
     * const { count } = await prisma.advertisement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdvertisementDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdvertisementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Advertisements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Advertisements
     * const advertisement = await prisma.advertisement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdvertisementUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdvertisementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Advertisement.
     * @param {AdvertisementUpsertArgs} args - Arguments to update or create a Advertisement.
     * @example
     * // Update or create a Advertisement
     * const advertisement = await prisma.advertisement.upsert({
     *   create: {
     *     // ... data to create a Advertisement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Advertisement we want to update
     *   }
     * })
    **/
    upsert<T extends AdvertisementUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdvertisementUpsertArgs<ExtArgs>>
    ): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more Advertisements that matches the filter.
     * @param {AdvertisementFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const advertisement = await prisma.advertisement.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: AdvertisementFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Advertisement.
     * @param {AdvertisementAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const advertisement = await prisma.advertisement.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: AdvertisementAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of Advertisements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementCountArgs} args - Arguments to filter Advertisements to count.
     * @example
     * // Count the number of Advertisements
     * const count = await prisma.advertisement.count({
     *   where: {
     *     // ... the filter for the Advertisements we want to count
     *   }
     * })
    **/
    count<T extends AdvertisementCountArgs>(
      args?: Subset<T, AdvertisementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdvertisementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Advertisement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdvertisementAggregateArgs>(args: Subset<T, AdvertisementAggregateArgs>): Prisma.PrismaPromise<GetAdvertisementAggregateType<T>>

    /**
     * Group by Advertisement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdvertisementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdvertisementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdvertisementGroupByArgs['orderBy'] }
        : { orderBy?: AdvertisementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdvertisementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdvertisementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Advertisement model
   */
  readonly fields: AdvertisementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Advertisement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdvertisementClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    city<T extends CityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CityDefaultArgs<ExtArgs>>): Prisma__CityClient<$Result.GetResult<Prisma.$CityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    interactions<T extends Advertisement$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, Advertisement$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdInteractionPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Advertisement model
   */ 
  interface AdvertisementFieldRefs {
    readonly id: FieldRef<"Advertisement", 'String'>
    readonly organizationId: FieldRef<"Advertisement", 'String'>
    readonly cityId: FieldRef<"Advertisement", 'String'>
    readonly title: FieldRef<"Advertisement", 'String'>
    readonly content: FieldRef<"Advertisement", 'String'>
    readonly pointsSpent: FieldRef<"Advertisement", 'Float'>
    readonly link: FieldRef<"Advertisement", 'String'>
    readonly imageUrl: FieldRef<"Advertisement", 'Bytes'>
    readonly isActive: FieldRef<"Advertisement", 'Boolean'>
    readonly startDate: FieldRef<"Advertisement", 'DateTime'>
    readonly expiryDate: FieldRef<"Advertisement", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Advertisement findUnique
   */
  export type AdvertisementFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter, which Advertisement to fetch.
     */
    where: AdvertisementWhereUniqueInput
  }


  /**
   * Advertisement findUniqueOrThrow
   */
  export type AdvertisementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter, which Advertisement to fetch.
     */
    where: AdvertisementWhereUniqueInput
  }


  /**
   * Advertisement findFirst
   */
  export type AdvertisementFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter, which Advertisement to fetch.
     */
    where?: AdvertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
     */
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advertisements.
     */
    cursor?: AdvertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advertisements.
     */
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }


  /**
   * Advertisement findFirstOrThrow
   */
  export type AdvertisementFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter, which Advertisement to fetch.
     */
    where?: AdvertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
     */
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Advertisements.
     */
    cursor?: AdvertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Advertisements.
     */
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }


  /**
   * Advertisement findMany
   */
  export type AdvertisementFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter, which Advertisements to fetch.
     */
    where?: AdvertisementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Advertisements to fetch.
     */
    orderBy?: AdvertisementOrderByWithRelationInput | AdvertisementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Advertisements.
     */
    cursor?: AdvertisementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Advertisements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Advertisements.
     */
    skip?: number
    distinct?: AdvertisementScalarFieldEnum | AdvertisementScalarFieldEnum[]
  }


  /**
   * Advertisement create
   */
  export type AdvertisementCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * The data needed to create a Advertisement.
     */
    data: XOR<AdvertisementCreateInput, AdvertisementUncheckedCreateInput>
  }


  /**
   * Advertisement createMany
   */
  export type AdvertisementCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Advertisements.
     */
    data: AdvertisementCreateManyInput | AdvertisementCreateManyInput[]
  }


  /**
   * Advertisement update
   */
  export type AdvertisementUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * The data needed to update a Advertisement.
     */
    data: XOR<AdvertisementUpdateInput, AdvertisementUncheckedUpdateInput>
    /**
     * Choose, which Advertisement to update.
     */
    where: AdvertisementWhereUniqueInput
  }


  /**
   * Advertisement updateMany
   */
  export type AdvertisementUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Advertisements.
     */
    data: XOR<AdvertisementUpdateManyMutationInput, AdvertisementUncheckedUpdateManyInput>
    /**
     * Filter which Advertisements to update
     */
    where?: AdvertisementWhereInput
  }


  /**
   * Advertisement upsert
   */
  export type AdvertisementUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * The filter to search for the Advertisement to update in case it exists.
     */
    where: AdvertisementWhereUniqueInput
    /**
     * In case the Advertisement found by the `where` argument doesn't exist, create a new Advertisement with this data.
     */
    create: XOR<AdvertisementCreateInput, AdvertisementUncheckedCreateInput>
    /**
     * In case the Advertisement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdvertisementUpdateInput, AdvertisementUncheckedUpdateInput>
  }


  /**
   * Advertisement delete
   */
  export type AdvertisementDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
    /**
     * Filter which Advertisement to delete.
     */
    where: AdvertisementWhereUniqueInput
  }


  /**
   * Advertisement deleteMany
   */
  export type AdvertisementDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Advertisements to delete
     */
    where?: AdvertisementWhereInput
  }


  /**
   * Advertisement findRaw
   */
  export type AdvertisementFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Advertisement aggregateRaw
   */
  export type AdvertisementAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * Advertisement.interactions
   */
  export type Advertisement$interactionsArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
    where?: AdInteractionWhereInput
    orderBy?: AdInteractionOrderByWithRelationInput | AdInteractionOrderByWithRelationInput[]
    cursor?: AdInteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdInteractionScalarFieldEnum | AdInteractionScalarFieldEnum[]
  }


  /**
   * Advertisement without action
   */
  export type AdvertisementDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Advertisement
     */
    select?: AdvertisementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdvertisementInclude<ExtArgs> | null
  }



  /**
   * Model AdInteraction
   */

  export type AggregateAdInteraction = {
    _count: AdInteractionCountAggregateOutputType | null
    _min: AdInteractionMinAggregateOutputType | null
    _max: AdInteractionMaxAggregateOutputType | null
  }

  export type AdInteractionMinAggregateOutputType = {
    id: string | null
    advertisementId: string | null
    clickedAt: Date | null
  }

  export type AdInteractionMaxAggregateOutputType = {
    id: string | null
    advertisementId: string | null
    clickedAt: Date | null
  }

  export type AdInteractionCountAggregateOutputType = {
    id: number
    advertisementId: number
    clickedAt: number
    _all: number
  }


  export type AdInteractionMinAggregateInputType = {
    id?: true
    advertisementId?: true
    clickedAt?: true
  }

  export type AdInteractionMaxAggregateInputType = {
    id?: true
    advertisementId?: true
    clickedAt?: true
  }

  export type AdInteractionCountAggregateInputType = {
    id?: true
    advertisementId?: true
    clickedAt?: true
    _all?: true
  }

  export type AdInteractionAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdInteraction to aggregate.
     */
    where?: AdInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdInteractions to fetch.
     */
    orderBy?: AdInteractionOrderByWithRelationInput | AdInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdInteractions
    **/
    _count?: true | AdInteractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdInteractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdInteractionMaxAggregateInputType
  }

  export type GetAdInteractionAggregateType<T extends AdInteractionAggregateArgs> = {
        [P in keyof T & keyof AggregateAdInteraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdInteraction[P]>
      : GetScalarType<T[P], AggregateAdInteraction[P]>
  }




  export type AdInteractionGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: AdInteractionWhereInput
    orderBy?: AdInteractionOrderByWithAggregationInput | AdInteractionOrderByWithAggregationInput[]
    by: AdInteractionScalarFieldEnum[] | AdInteractionScalarFieldEnum
    having?: AdInteractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdInteractionCountAggregateInputType | true
    _min?: AdInteractionMinAggregateInputType
    _max?: AdInteractionMaxAggregateInputType
  }

  export type AdInteractionGroupByOutputType = {
    id: string
    advertisementId: string
    clickedAt: Date
    _count: AdInteractionCountAggregateOutputType | null
    _min: AdInteractionMinAggregateOutputType | null
    _max: AdInteractionMaxAggregateOutputType | null
  }

  type GetAdInteractionGroupByPayload<T extends AdInteractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdInteractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdInteractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdInteractionGroupByOutputType[P]>
            : GetScalarType<T[P], AdInteractionGroupByOutputType[P]>
        }
      >
    >


  export type AdInteractionSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    advertisementId?: boolean
    clickedAt?: boolean
    advertisement?: boolean | AdvertisementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adInteraction"]>

  export type AdInteractionSelectScalar = {
    id?: boolean
    advertisementId?: boolean
    clickedAt?: boolean
  }

  export type AdInteractionInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    advertisement?: boolean | AdvertisementDefaultArgs<ExtArgs>
  }


  export type $AdInteractionPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    name: "AdInteraction"
    objects: {
      advertisement: Prisma.$AdvertisementPayload<ExtArgs>
    }
    scalars: $Extensions.GetResult<{
      id: string
      advertisementId: string
      clickedAt: Date
    }, ExtArgs["result"]["adInteraction"]>
    composites: {}
  }


  type AdInteractionGetPayload<S extends boolean | null | undefined | AdInteractionDefaultArgs> = $Result.GetResult<Prisma.$AdInteractionPayload, S>

  type AdInteractionCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<AdInteractionFindManyArgs, 'select' | 'include'> & {
      select?: AdInteractionCountAggregateInputType | true
    }

  export interface AdInteractionDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdInteraction'], meta: { name: 'AdInteraction' } }
    /**
     * Find zero or one AdInteraction that matches the filter.
     * @param {AdInteractionFindUniqueArgs} args - Arguments to find a AdInteraction
     * @example
     * // Get one AdInteraction
     * const adInteraction = await prisma.adInteraction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AdInteractionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AdInteractionFindUniqueArgs<ExtArgs>>
    ): Prisma__AdInteractionClient<$Result.GetResult<Prisma.$AdInteractionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AdInteraction that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AdInteractionFindUniqueOrThrowArgs} args - Arguments to find a AdInteraction
     * @example
     * // Get one AdInteraction
     * const adInteraction = await prisma.adInteraction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AdInteractionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdInteractionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AdInteractionClient<$Result.GetResult<Prisma.$AdInteractionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AdInteraction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdInteractionFindFirstArgs} args - Arguments to find a AdInteraction
     * @example
     * // Get one AdInteraction
     * const adInteraction = await prisma.adInteraction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AdInteractionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AdInteractionFindFirstArgs<ExtArgs>>
    ): Prisma__AdInteractionClient<$Result.GetResult<Prisma.$AdInteractionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AdInteraction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdInteractionFindFirstOrThrowArgs} args - Arguments to find a AdInteraction
     * @example
     * // Get one AdInteraction
     * const adInteraction = await prisma.adInteraction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AdInteractionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AdInteractionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AdInteractionClient<$Result.GetResult<Prisma.$AdInteractionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AdInteractions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdInteractionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdInteractions
     * const adInteractions = await prisma.adInteraction.findMany()
     * 
     * // Get first 10 AdInteractions
     * const adInteractions = await prisma.adInteraction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adInteractionWithIdOnly = await prisma.adInteraction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AdInteractionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdInteractionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdInteractionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AdInteraction.
     * @param {AdInteractionCreateArgs} args - Arguments to create a AdInteraction.
     * @example
     * // Create one AdInteraction
     * const AdInteraction = await prisma.adInteraction.create({
     *   data: {
     *     // ... data to create a AdInteraction
     *   }
     * })
     * 
    **/
    create<T extends AdInteractionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AdInteractionCreateArgs<ExtArgs>>
    ): Prisma__AdInteractionClient<$Result.GetResult<Prisma.$AdInteractionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AdInteractions.
     *     @param {AdInteractionCreateManyArgs} args - Arguments to create many AdInteractions.
     *     @example
     *     // Create many AdInteractions
     *     const adInteraction = await prisma.adInteraction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AdInteractionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdInteractionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AdInteraction.
     * @param {AdInteractionDeleteArgs} args - Arguments to delete one AdInteraction.
     * @example
     * // Delete one AdInteraction
     * const AdInteraction = await prisma.adInteraction.delete({
     *   where: {
     *     // ... filter to delete one AdInteraction
     *   }
     * })
     * 
    **/
    delete<T extends AdInteractionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AdInteractionDeleteArgs<ExtArgs>>
    ): Prisma__AdInteractionClient<$Result.GetResult<Prisma.$AdInteractionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AdInteraction.
     * @param {AdInteractionUpdateArgs} args - Arguments to update one AdInteraction.
     * @example
     * // Update one AdInteraction
     * const adInteraction = await prisma.adInteraction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AdInteractionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AdInteractionUpdateArgs<ExtArgs>>
    ): Prisma__AdInteractionClient<$Result.GetResult<Prisma.$AdInteractionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AdInteractions.
     * @param {AdInteractionDeleteManyArgs} args - Arguments to filter AdInteractions to delete.
     * @example
     * // Delete a few AdInteractions
     * const { count } = await prisma.adInteraction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AdInteractionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AdInteractionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdInteractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdInteractions
     * const adInteraction = await prisma.adInteraction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AdInteractionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AdInteractionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdInteraction.
     * @param {AdInteractionUpsertArgs} args - Arguments to update or create a AdInteraction.
     * @example
     * // Update or create a AdInteraction
     * const adInteraction = await prisma.adInteraction.upsert({
     *   create: {
     *     // ... data to create a AdInteraction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdInteraction we want to update
     *   }
     * })
    **/
    upsert<T extends AdInteractionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AdInteractionUpsertArgs<ExtArgs>>
    ): Prisma__AdInteractionClient<$Result.GetResult<Prisma.$AdInteractionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Find zero or more AdInteractions that matches the filter.
     * @param {AdInteractionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const adInteraction = await prisma.adInteraction.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
    **/
    findRaw(
      args?: AdInteractionFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AdInteraction.
     * @param {AdInteractionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const adInteraction = await prisma.adInteraction.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
    **/
    aggregateRaw(
      args?: AdInteractionAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>

    /**
     * Count the number of AdInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdInteractionCountArgs} args - Arguments to filter AdInteractions to count.
     * @example
     * // Count the number of AdInteractions
     * const count = await prisma.adInteraction.count({
     *   where: {
     *     // ... the filter for the AdInteractions we want to count
     *   }
     * })
    **/
    count<T extends AdInteractionCountArgs>(
      args?: Subset<T, AdInteractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdInteractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdInteractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdInteractionAggregateArgs>(args: Subset<T, AdInteractionAggregateArgs>): Prisma.PrismaPromise<GetAdInteractionAggregateType<T>>

    /**
     * Group by AdInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdInteractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdInteractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdInteractionGroupByArgs['orderBy'] }
        : { orderBy?: AdInteractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdInteractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdInteractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdInteraction model
   */
  readonly fields: AdInteractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdInteraction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdInteractionClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    advertisement<T extends AdvertisementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AdvertisementDefaultArgs<ExtArgs>>): Prisma__AdvertisementClient<$Result.GetResult<Prisma.$AdvertisementPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AdInteraction model
   */ 
  interface AdInteractionFieldRefs {
    readonly id: FieldRef<"AdInteraction", 'String'>
    readonly advertisementId: FieldRef<"AdInteraction", 'String'>
    readonly clickedAt: FieldRef<"AdInteraction", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * AdInteraction findUnique
   */
  export type AdInteractionFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
    /**
     * Filter, which AdInteraction to fetch.
     */
    where: AdInteractionWhereUniqueInput
  }


  /**
   * AdInteraction findUniqueOrThrow
   */
  export type AdInteractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
    /**
     * Filter, which AdInteraction to fetch.
     */
    where: AdInteractionWhereUniqueInput
  }


  /**
   * AdInteraction findFirst
   */
  export type AdInteractionFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
    /**
     * Filter, which AdInteraction to fetch.
     */
    where?: AdInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdInteractions to fetch.
     */
    orderBy?: AdInteractionOrderByWithRelationInput | AdInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdInteractions.
     */
    cursor?: AdInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdInteractions.
     */
    distinct?: AdInteractionScalarFieldEnum | AdInteractionScalarFieldEnum[]
  }


  /**
   * AdInteraction findFirstOrThrow
   */
  export type AdInteractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
    /**
     * Filter, which AdInteraction to fetch.
     */
    where?: AdInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdInteractions to fetch.
     */
    orderBy?: AdInteractionOrderByWithRelationInput | AdInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdInteractions.
     */
    cursor?: AdInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdInteractions.
     */
    distinct?: AdInteractionScalarFieldEnum | AdInteractionScalarFieldEnum[]
  }


  /**
   * AdInteraction findMany
   */
  export type AdInteractionFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
    /**
     * Filter, which AdInteractions to fetch.
     */
    where?: AdInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdInteractions to fetch.
     */
    orderBy?: AdInteractionOrderByWithRelationInput | AdInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdInteractions.
     */
    cursor?: AdInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdInteractions.
     */
    skip?: number
    distinct?: AdInteractionScalarFieldEnum | AdInteractionScalarFieldEnum[]
  }


  /**
   * AdInteraction create
   */
  export type AdInteractionCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
    /**
     * The data needed to create a AdInteraction.
     */
    data: XOR<AdInteractionCreateInput, AdInteractionUncheckedCreateInput>
  }


  /**
   * AdInteraction createMany
   */
  export type AdInteractionCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdInteractions.
     */
    data: AdInteractionCreateManyInput | AdInteractionCreateManyInput[]
  }


  /**
   * AdInteraction update
   */
  export type AdInteractionUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
    /**
     * The data needed to update a AdInteraction.
     */
    data: XOR<AdInteractionUpdateInput, AdInteractionUncheckedUpdateInput>
    /**
     * Choose, which AdInteraction to update.
     */
    where: AdInteractionWhereUniqueInput
  }


  /**
   * AdInteraction updateMany
   */
  export type AdInteractionUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdInteractions.
     */
    data: XOR<AdInteractionUpdateManyMutationInput, AdInteractionUncheckedUpdateManyInput>
    /**
     * Filter which AdInteractions to update
     */
    where?: AdInteractionWhereInput
  }


  /**
   * AdInteraction upsert
   */
  export type AdInteractionUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
    /**
     * The filter to search for the AdInteraction to update in case it exists.
     */
    where: AdInteractionWhereUniqueInput
    /**
     * In case the AdInteraction found by the `where` argument doesn't exist, create a new AdInteraction with this data.
     */
    create: XOR<AdInteractionCreateInput, AdInteractionUncheckedCreateInput>
    /**
     * In case the AdInteraction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdInteractionUpdateInput, AdInteractionUncheckedUpdateInput>
  }


  /**
   * AdInteraction delete
   */
  export type AdInteractionDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
    /**
     * Filter which AdInteraction to delete.
     */
    where: AdInteractionWhereUniqueInput
  }


  /**
   * AdInteraction deleteMany
   */
  export type AdInteractionDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdInteractions to delete
     */
    where?: AdInteractionWhereInput
  }


  /**
   * AdInteraction findRaw
   */
  export type AdInteractionFindRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * AdInteraction aggregateRaw
   */
  export type AdInteractionAggregateRawArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }


  /**
   * AdInteraction without action
   */
  export type AdInteractionDefaultArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdInteraction
     */
    select?: AdInteractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AdInteractionInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    password: 'password',
    cityId: 'cityId',
    gender: 'gender',
    contactNumber: 'contactNumber',
    profilePicture: 'profilePicture',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    organizationname: 'organizationname',
    email: 'email',
    password: 'password',
    address: 'address',
    contactNumber: 'contactNumber',
    secRegistrationNumber: 'secRegistrationNumber',
    verificationStatus: 'verificationStatus',
    totalPoints: 'totalPoints',
    type: 'type',
    profilePicture: 'profilePicture',
    createdAt: 'createdAt'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    url: 'url',
    uploadedBy: 'uploadedBy',
    organizationId: 'organizationId',
    createdAt: 'createdAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const DropPointScalarFieldEnum: {
    id: 'id',
    name: 'name',
    location: 'location',
    openingTime: 'openingTime',
    closingTime: 'closingTime',
    description: 'description',
    managerId: 'managerId',
    password: 'password'
  };

  export type DropPointScalarFieldEnum = (typeof DropPointScalarFieldEnum)[keyof typeof DropPointScalarFieldEnum]


  export const ManagerScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phoneNumber: 'phoneNumber',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ManagerScalarFieldEnum = (typeof ManagerScalarFieldEnum)[keyof typeof ManagerScalarFieldEnum]


  export const DonationScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    dropPointId: 'dropPointId',
    createdAt: 'createdAt',
    expectedDateOfArrival: 'expectedDateOfArrival',
    confirmedByName: 'confirmedByName',
    confirmedByEmail: 'confirmedByEmail',
    status: 'status',
    isSubmitted: 'isSubmitted',
    points: 'points'
  };

  export type DonationScalarFieldEnum = (typeof DonationScalarFieldEnum)[keyof typeof DonationScalarFieldEnum]


  export const PeripheralScalarFieldEnum: {
    id: 'id',
    type: 'type',
    brand: 'brand',
    model: 'model',
    condition: 'condition',
    quantity: 'quantity',
    donationId: 'donationId'
  };

  export type PeripheralScalarFieldEnum = (typeof PeripheralScalarFieldEnum)[keyof typeof PeripheralScalarFieldEnum]


  export const CityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    requiredPoints: 'requiredPoints'
  };

  export type CityScalarFieldEnum = (typeof CityScalarFieldEnum)[keyof typeof CityScalarFieldEnum]


  export const AdvertisementScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    cityId: 'cityId',
    title: 'title',
    content: 'content',
    pointsSpent: 'pointsSpent',
    link: 'link',
    imageUrl: 'imageUrl',
    isActive: 'isActive',
    startDate: 'startDate',
    expiryDate: 'expiryDate'
  };

  export type AdvertisementScalarFieldEnum = (typeof AdvertisementScalarFieldEnum)[keyof typeof AdvertisementScalarFieldEnum]


  export const AdInteractionScalarFieldEnum: {
    id: 'id',
    advertisementId: 'advertisementId',
    clickedAt: 'clickedAt'
  };

  export type AdInteractionScalarFieldEnum = (typeof AdInteractionScalarFieldEnum)[keyof typeof AdInteractionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter | string
    email?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    password?: StringFilter | string
    cityId?: StringFilter | string
    gender?: StringFilter | string
    contactNumber?: StringFilter | string
    profilePicture?: BytesNullableFilter | Buffer | null
    createdAt?: DateTimeFilter | Date | string
    city?: XOR<CityRelationFilter, CityWhereInput>
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    cityId?: SortOrder
    gender?: SortOrder
    contactNumber?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    city?: CityOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    cityId?: SortOrder
    gender?: SortOrder
    contactNumber?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    cityId?: StringWithAggregatesFilter | string
    gender?: StringWithAggregatesFilter | string
    contactNumber?: StringWithAggregatesFilter | string
    profilePicture?: BytesNullableWithAggregatesFilter | Buffer | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: StringFilter | string
    organizationname?: StringFilter | string
    email?: StringFilter | string
    password?: StringFilter | string
    address?: StringFilter | string
    contactNumber?: StringFilter | string
    secRegistrationNumber?: StringNullableFilter | string | null
    verificationStatus?: StringFilter | string
    totalPoints?: FloatFilter | number
    type?: StringFilter | string
    profilePicture?: BytesNullableFilter | Buffer | null
    createdAt?: DateTimeFilter | Date | string
    submittedDocuments?: DocumentListRelationFilter
    donations?: DonationListRelationFilter
    advertisements?: AdvertisementListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    organizationname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    contactNumber?: SortOrder
    secRegistrationNumber?: SortOrder
    verificationStatus?: SortOrder
    totalPoints?: SortOrder
    type?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    submittedDocuments?: DocumentOrderByRelationAggregateInput
    donations?: DonationOrderByRelationAggregateInput
    advertisements?: AdvertisementOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = {
    id?: string
    organizationname?: string
    email?: string
    contactNumber?: string
    secRegistrationNumber?: string
  }

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    organizationname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    contactNumber?: SortOrder
    secRegistrationNumber?: SortOrder
    verificationStatus?: SortOrder
    totalPoints?: SortOrder
    type?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _avg?: OrganizationAvgOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
    _sum?: OrganizationSumOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    organizationname?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    address?: StringWithAggregatesFilter | string
    contactNumber?: StringWithAggregatesFilter | string
    secRegistrationNumber?: StringNullableWithAggregatesFilter | string | null
    verificationStatus?: StringWithAggregatesFilter | string
    totalPoints?: FloatWithAggregatesFilter | number
    type?: StringWithAggregatesFilter | string
    profilePicture?: BytesNullableWithAggregatesFilter | Buffer | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter | string
    filename?: StringFilter | string
    url?: StringFilter | string
    uploadedBy?: StringFilter | string
    organizationId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput> | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = {
    id?: string
  }

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    filename?: StringWithAggregatesFilter | string
    url?: StringWithAggregatesFilter | string
    uploadedBy?: StringWithAggregatesFilter | string
    organizationId?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DropPointWhereInput = {
    AND?: DropPointWhereInput | DropPointWhereInput[]
    OR?: DropPointWhereInput[]
    NOT?: DropPointWhereInput | DropPointWhereInput[]
    id?: StringFilter | string
    name?: StringFilter | string
    location?: StringFilter | string
    openingTime?: StringFilter | string
    closingTime?: StringFilter | string
    description?: StringFilter | string
    managerId?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
    manager?: XOR<ManagerRelationFilter, ManagerWhereInput> | null
    donations?: DonationListRelationFilter
  }

  export type DropPointOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    password?: SortOrder
    manager?: ManagerOrderByWithRelationInput
    donations?: DonationOrderByRelationAggregateInput
  }

  export type DropPointWhereUniqueInput = {
    id?: string
  }

  export type DropPointOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    password?: SortOrder
    _count?: DropPointCountOrderByAggregateInput
    _max?: DropPointMaxOrderByAggregateInput
    _min?: DropPointMinOrderByAggregateInput
  }

  export type DropPointScalarWhereWithAggregatesInput = {
    AND?: DropPointScalarWhereWithAggregatesInput | DropPointScalarWhereWithAggregatesInput[]
    OR?: DropPointScalarWhereWithAggregatesInput[]
    NOT?: DropPointScalarWhereWithAggregatesInput | DropPointScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    location?: StringWithAggregatesFilter | string
    openingTime?: StringWithAggregatesFilter | string
    closingTime?: StringWithAggregatesFilter | string
    description?: StringWithAggregatesFilter | string
    managerId?: StringNullableWithAggregatesFilter | string | null
    password?: StringNullableWithAggregatesFilter | string | null
  }

  export type ManagerWhereInput = {
    AND?: ManagerWhereInput | ManagerWhereInput[]
    OR?: ManagerWhereInput[]
    NOT?: ManagerWhereInput | ManagerWhereInput[]
    id?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    email?: StringFilter | string
    phoneNumber?: StringNullableFilter | string | null
    address?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    dropPoint?: DropPointListRelationFilter
  }

  export type ManagerOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dropPoint?: DropPointOrderByRelationAggregateInput
  }

  export type ManagerWhereUniqueInput = {
    id?: string
    email?: string
  }

  export type ManagerOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ManagerCountOrderByAggregateInput
    _max?: ManagerMaxOrderByAggregateInput
    _min?: ManagerMinOrderByAggregateInput
  }

  export type ManagerScalarWhereWithAggregatesInput = {
    AND?: ManagerScalarWhereWithAggregatesInput | ManagerScalarWhereWithAggregatesInput[]
    OR?: ManagerScalarWhereWithAggregatesInput[]
    NOT?: ManagerScalarWhereWithAggregatesInput | ManagerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    firstName?: StringWithAggregatesFilter | string
    lastName?: StringWithAggregatesFilter | string
    email?: StringWithAggregatesFilter | string
    phoneNumber?: StringNullableWithAggregatesFilter | string | null
    address?: StringNullableWithAggregatesFilter | string | null
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type DonationWhereInput = {
    AND?: DonationWhereInput | DonationWhereInput[]
    OR?: DonationWhereInput[]
    NOT?: DonationWhereInput | DonationWhereInput[]
    id?: StringFilter | string
    organizationId?: StringFilter | string
    dropPointId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    expectedDateOfArrival?: DateTimeNullableFilter | Date | string | null
    confirmedByName?: StringNullableFilter | string | null
    confirmedByEmail?: StringNullableFilter | string | null
    status?: StringNullableFilter | string | null
    isSubmitted?: BoolFilter | boolean
    points?: FloatNullableFilter | number | null
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    dropPoint?: XOR<DropPointRelationFilter, DropPointWhereInput>
    peripherals?: PeripheralListRelationFilter
  }

  export type DonationOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    dropPointId?: SortOrder
    createdAt?: SortOrder
    expectedDateOfArrival?: SortOrder
    confirmedByName?: SortOrder
    confirmedByEmail?: SortOrder
    status?: SortOrder
    isSubmitted?: SortOrder
    points?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    dropPoint?: DropPointOrderByWithRelationInput
    peripherals?: PeripheralOrderByRelationAggregateInput
  }

  export type DonationWhereUniqueInput = {
    id?: string
  }

  export type DonationOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    dropPointId?: SortOrder
    createdAt?: SortOrder
    expectedDateOfArrival?: SortOrder
    confirmedByName?: SortOrder
    confirmedByEmail?: SortOrder
    status?: SortOrder
    isSubmitted?: SortOrder
    points?: SortOrder
    _count?: DonationCountOrderByAggregateInput
    _avg?: DonationAvgOrderByAggregateInput
    _max?: DonationMaxOrderByAggregateInput
    _min?: DonationMinOrderByAggregateInput
    _sum?: DonationSumOrderByAggregateInput
  }

  export type DonationScalarWhereWithAggregatesInput = {
    AND?: DonationScalarWhereWithAggregatesInput | DonationScalarWhereWithAggregatesInput[]
    OR?: DonationScalarWhereWithAggregatesInput[]
    NOT?: DonationScalarWhereWithAggregatesInput | DonationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    organizationId?: StringWithAggregatesFilter | string
    dropPointId?: StringWithAggregatesFilter | string
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    expectedDateOfArrival?: DateTimeNullableWithAggregatesFilter | Date | string | null
    confirmedByName?: StringNullableWithAggregatesFilter | string | null
    confirmedByEmail?: StringNullableWithAggregatesFilter | string | null
    status?: StringNullableWithAggregatesFilter | string | null
    isSubmitted?: BoolWithAggregatesFilter | boolean
    points?: FloatNullableWithAggregatesFilter | number | null
  }

  export type PeripheralWhereInput = {
    AND?: PeripheralWhereInput | PeripheralWhereInput[]
    OR?: PeripheralWhereInput[]
    NOT?: PeripheralWhereInput | PeripheralWhereInput[]
    id?: StringFilter | string
    type?: StringFilter | string
    brand?: StringFilter | string
    model?: StringFilter | string
    condition?: StringFilter | string
    quantity?: IntFilter | number
    donationId?: StringFilter | string
    donation?: XOR<DonationRelationFilter, DonationWhereInput>
  }

  export type PeripheralOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    condition?: SortOrder
    quantity?: SortOrder
    donationId?: SortOrder
    donation?: DonationOrderByWithRelationInput
  }

  export type PeripheralWhereUniqueInput = {
    id?: string
  }

  export type PeripheralOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    condition?: SortOrder
    quantity?: SortOrder
    donationId?: SortOrder
    _count?: PeripheralCountOrderByAggregateInput
    _avg?: PeripheralAvgOrderByAggregateInput
    _max?: PeripheralMaxOrderByAggregateInput
    _min?: PeripheralMinOrderByAggregateInput
    _sum?: PeripheralSumOrderByAggregateInput
  }

  export type PeripheralScalarWhereWithAggregatesInput = {
    AND?: PeripheralScalarWhereWithAggregatesInput | PeripheralScalarWhereWithAggregatesInput[]
    OR?: PeripheralScalarWhereWithAggregatesInput[]
    NOT?: PeripheralScalarWhereWithAggregatesInput | PeripheralScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    brand?: StringWithAggregatesFilter | string
    model?: StringWithAggregatesFilter | string
    condition?: StringWithAggregatesFilter | string
    quantity?: IntWithAggregatesFilter | number
    donationId?: StringWithAggregatesFilter | string
  }

  export type CityWhereInput = {
    AND?: CityWhereInput | CityWhereInput[]
    OR?: CityWhereInput[]
    NOT?: CityWhereInput | CityWhereInput[]
    id?: StringFilter | string
    name?: StringFilter | string
    requiredPoints?: FloatNullableFilter | number | null
    users?: UserListRelationFilter
    advertisements?: AdvertisementListRelationFilter
  }

  export type CityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    requiredPoints?: SortOrder
    users?: UserOrderByRelationAggregateInput
    advertisements?: AdvertisementOrderByRelationAggregateInput
  }

  export type CityWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type CityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    requiredPoints?: SortOrder
    _count?: CityCountOrderByAggregateInput
    _avg?: CityAvgOrderByAggregateInput
    _max?: CityMaxOrderByAggregateInput
    _min?: CityMinOrderByAggregateInput
    _sum?: CitySumOrderByAggregateInput
  }

  export type CityScalarWhereWithAggregatesInput = {
    AND?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    OR?: CityScalarWhereWithAggregatesInput[]
    NOT?: CityScalarWhereWithAggregatesInput | CityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    requiredPoints?: FloatNullableWithAggregatesFilter | number | null
  }

  export type AdvertisementWhereInput = {
    AND?: AdvertisementWhereInput | AdvertisementWhereInput[]
    OR?: AdvertisementWhereInput[]
    NOT?: AdvertisementWhereInput | AdvertisementWhereInput[]
    id?: StringFilter | string
    organizationId?: StringFilter | string
    cityId?: StringFilter | string
    title?: StringFilter | string
    content?: StringFilter | string
    pointsSpent?: FloatFilter | number
    link?: StringFilter | string
    imageUrl?: BytesFilter | Buffer
    isActive?: BoolFilter | boolean
    startDate?: DateTimeFilter | Date | string
    expiryDate?: DateTimeFilter | Date | string
    organization?: XOR<OrganizationRelationFilter, OrganizationWhereInput>
    city?: XOR<CityRelationFilter, CityWhereInput>
    interactions?: AdInteractionListRelationFilter
  }

  export type AdvertisementOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    cityId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    pointsSpent?: SortOrder
    link?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    city?: CityOrderByWithRelationInput
    interactions?: AdInteractionOrderByRelationAggregateInput
  }

  export type AdvertisementWhereUniqueInput = {
    id?: string
  }

  export type AdvertisementOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    cityId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    pointsSpent?: SortOrder
    link?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
    _count?: AdvertisementCountOrderByAggregateInput
    _avg?: AdvertisementAvgOrderByAggregateInput
    _max?: AdvertisementMaxOrderByAggregateInput
    _min?: AdvertisementMinOrderByAggregateInput
    _sum?: AdvertisementSumOrderByAggregateInput
  }

  export type AdvertisementScalarWhereWithAggregatesInput = {
    AND?: AdvertisementScalarWhereWithAggregatesInput | AdvertisementScalarWhereWithAggregatesInput[]
    OR?: AdvertisementScalarWhereWithAggregatesInput[]
    NOT?: AdvertisementScalarWhereWithAggregatesInput | AdvertisementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    organizationId?: StringWithAggregatesFilter | string
    cityId?: StringWithAggregatesFilter | string
    title?: StringWithAggregatesFilter | string
    content?: StringWithAggregatesFilter | string
    pointsSpent?: FloatWithAggregatesFilter | number
    link?: StringWithAggregatesFilter | string
    imageUrl?: BytesWithAggregatesFilter | Buffer
    isActive?: BoolWithAggregatesFilter | boolean
    startDate?: DateTimeWithAggregatesFilter | Date | string
    expiryDate?: DateTimeWithAggregatesFilter | Date | string
  }

  export type AdInteractionWhereInput = {
    AND?: AdInteractionWhereInput | AdInteractionWhereInput[]
    OR?: AdInteractionWhereInput[]
    NOT?: AdInteractionWhereInput | AdInteractionWhereInput[]
    id?: StringFilter | string
    advertisementId?: StringFilter | string
    clickedAt?: DateTimeFilter | Date | string
    advertisement?: XOR<AdvertisementRelationFilter, AdvertisementWhereInput>
  }

  export type AdInteractionOrderByWithRelationInput = {
    id?: SortOrder
    advertisementId?: SortOrder
    clickedAt?: SortOrder
    advertisement?: AdvertisementOrderByWithRelationInput
  }

  export type AdInteractionWhereUniqueInput = {
    id?: string
  }

  export type AdInteractionOrderByWithAggregationInput = {
    id?: SortOrder
    advertisementId?: SortOrder
    clickedAt?: SortOrder
    _count?: AdInteractionCountOrderByAggregateInput
    _max?: AdInteractionMaxOrderByAggregateInput
    _min?: AdInteractionMinOrderByAggregateInput
  }

  export type AdInteractionScalarWhereWithAggregatesInput = {
    AND?: AdInteractionScalarWhereWithAggregatesInput | AdInteractionScalarWhereWithAggregatesInput[]
    OR?: AdInteractionScalarWhereWithAggregatesInput[]
    NOT?: AdInteractionScalarWhereWithAggregatesInput | AdInteractionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter | string
    advertisementId?: StringWithAggregatesFilter | string
    clickedAt?: DateTimeWithAggregatesFilter | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    city: CityCreateNestedOneWithoutUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    cityId: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    cityId: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationCreateInput = {
    id?: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber?: string | null
    verificationStatus?: string
    totalPoints?: number
    type: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    submittedDocuments?: DocumentCreateNestedManyWithoutOrganizationInput
    donations?: DonationCreateNestedManyWithoutOrganizationInput
    advertisements?: AdvertisementCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber?: string | null
    verificationStatus?: string
    totalPoints?: number
    type: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    submittedDocuments?: DocumentUncheckedCreateNestedManyWithoutOrganizationInput
    donations?: DonationUncheckedCreateNestedManyWithoutOrganizationInput
    advertisements?: AdvertisementUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedDocuments?: DocumentUpdateManyWithoutOrganizationNestedInput
    donations?: DonationUpdateManyWithoutOrganizationNestedInput
    advertisements?: AdvertisementUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedDocuments?: DocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    donations?: DonationUncheckedUpdateManyWithoutOrganizationNestedInput
    advertisements?: AdvertisementUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber?: string | null
    verificationStatus?: string
    totalPoints?: number
    type: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
  }

  export type OrganizationUpdateManyMutationInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrganizationUncheckedUpdateManyInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    filename: string
    url: string
    uploadedBy: string
    createdAt?: Date | string
    organization?: OrganizationCreateNestedOneWithoutSubmittedDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    filename: string
    url: string
    uploadedBy: string
    organizationId?: string | null
    createdAt?: Date | string
  }

  export type DocumentUpdateInput = {
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneWithoutSubmittedDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyInput = {
    id?: string
    filename: string
    url: string
    uploadedBy: string
    organizationId?: string | null
    createdAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    organizationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DropPointCreateInput = {
    id?: string
    name: string
    location: string
    openingTime: string
    closingTime: string
    description: string
    password?: string | null
    manager?: ManagerCreateNestedOneWithoutDropPointInput
    donations?: DonationCreateNestedManyWithoutDropPointInput
  }

  export type DropPointUncheckedCreateInput = {
    id?: string
    name: string
    location: string
    openingTime: string
    closingTime: string
    description: string
    managerId?: string | null
    password?: string | null
    donations?: DonationUncheckedCreateNestedManyWithoutDropPointInput
  }

  export type DropPointUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    openingTime?: StringFieldUpdateOperationsInput | string
    closingTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: ManagerUpdateOneWithoutDropPointNestedInput
    donations?: DonationUpdateManyWithoutDropPointNestedInput
  }

  export type DropPointUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    openingTime?: StringFieldUpdateOperationsInput | string
    closingTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    donations?: DonationUncheckedUpdateManyWithoutDropPointNestedInput
  }

  export type DropPointCreateManyInput = {
    id?: string
    name: string
    location: string
    openingTime: string
    closingTime: string
    description: string
    managerId?: string | null
    password?: string | null
  }

  export type DropPointUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    openingTime?: StringFieldUpdateOperationsInput | string
    closingTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DropPointUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    openingTime?: StringFieldUpdateOperationsInput | string
    closingTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ManagerCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phoneNumber?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropPoint?: DropPointCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phoneNumber?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dropPoint?: DropPointUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropPoint?: DropPointUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dropPoint?: DropPointUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type ManagerCreateManyInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phoneNumber?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManagerUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerUncheckedUpdateManyInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationCreateInput = {
    id?: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
    organization: OrganizationCreateNestedOneWithoutDonationsInput
    dropPoint: DropPointCreateNestedOneWithoutDonationsInput
    peripherals?: PeripheralCreateNestedManyWithoutDonationInput
  }

  export type DonationUncheckedCreateInput = {
    id?: string
    organizationId: string
    dropPointId: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
    peripherals?: PeripheralUncheckedCreateNestedManyWithoutDonationInput
  }

  export type DonationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneRequiredWithoutDonationsNestedInput
    dropPoint?: DropPointUpdateOneRequiredWithoutDonationsNestedInput
    peripherals?: PeripheralUpdateManyWithoutDonationNestedInput
  }

  export type DonationUncheckedUpdateInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    dropPointId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
    peripherals?: PeripheralUncheckedUpdateManyWithoutDonationNestedInput
  }

  export type DonationCreateManyInput = {
    id?: string
    organizationId: string
    dropPointId: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
  }

  export type DonationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type DonationUncheckedUpdateManyInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    dropPointId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PeripheralCreateInput = {
    id?: string
    type: string
    brand: string
    model: string
    condition: string
    quantity?: number
    donation: DonationCreateNestedOneWithoutPeripheralsInput
  }

  export type PeripheralUncheckedCreateInput = {
    id?: string
    type: string
    brand: string
    model: string
    condition: string
    quantity?: number
    donationId: string
  }

  export type PeripheralUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    donation?: DonationUpdateOneRequiredWithoutPeripheralsNestedInput
  }

  export type PeripheralUncheckedUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    donationId?: StringFieldUpdateOperationsInput | string
  }

  export type PeripheralCreateManyInput = {
    id?: string
    type: string
    brand: string
    model: string
    condition: string
    quantity?: number
    donationId: string
  }

  export type PeripheralUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type PeripheralUncheckedUpdateManyInput = {
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    donationId?: StringFieldUpdateOperationsInput | string
  }

  export type CityCreateInput = {
    id?: string
    name: string
    requiredPoints?: number | null
    users?: UserCreateNestedManyWithoutCityInput
    advertisements?: AdvertisementCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateInput = {
    id?: string
    name: string
    requiredPoints?: number | null
    users?: UserUncheckedCreateNestedManyWithoutCityInput
    advertisements?: AdvertisementUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    requiredPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    users?: UserUpdateManyWithoutCityNestedInput
    advertisements?: AdvertisementUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    requiredPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
    advertisements?: AdvertisementUncheckedUpdateManyWithoutCityNestedInput
  }

  export type CityCreateManyInput = {
    id?: string
    name: string
    requiredPoints?: number | null
  }

  export type CityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    requiredPoints?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type CityUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    requiredPoints?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AdvertisementCreateInput = {
    id?: string
    title: string
    content: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate: Date | string
    expiryDate: Date | string
    organization: OrganizationCreateNestedOneWithoutAdvertisementsInput
    city: CityCreateNestedOneWithoutAdvertisementsInput
    interactions?: AdInteractionCreateNestedManyWithoutAdvertisementInput
  }

  export type AdvertisementUncheckedCreateInput = {
    id?: string
    organizationId: string
    cityId: string
    title: string
    content: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate: Date | string
    expiryDate: Date | string
    interactions?: AdInteractionUncheckedCreateNestedManyWithoutAdvertisementInput
  }

  export type AdvertisementUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAdvertisementsNestedInput
    city?: CityUpdateOneRequiredWithoutAdvertisementsNestedInput
    interactions?: AdInteractionUpdateManyWithoutAdvertisementNestedInput
  }

  export type AdvertisementUncheckedUpdateInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: AdInteractionUncheckedUpdateManyWithoutAdvertisementNestedInput
  }

  export type AdvertisementCreateManyInput = {
    id?: string
    organizationId: string
    cityId: string
    title: string
    content: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate: Date | string
    expiryDate: Date | string
  }

  export type AdvertisementUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisementUncheckedUpdateManyInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdInteractionCreateInput = {
    id?: string
    clickedAt?: Date | string
    advertisement: AdvertisementCreateNestedOneWithoutInteractionsInput
  }

  export type AdInteractionUncheckedCreateInput = {
    id?: string
    advertisementId: string
    clickedAt?: Date | string
  }

  export type AdInteractionUpdateInput = {
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    advertisement?: AdvertisementUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type AdInteractionUncheckedUpdateInput = {
    advertisementId?: StringFieldUpdateOperationsInput | string
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdInteractionCreateManyInput = {
    id?: string
    advertisementId: string
    clickedAt?: Date | string
  }

  export type AdInteractionUpdateManyMutationInput = {
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdInteractionUncheckedUpdateManyInput = {
    advertisementId?: StringFieldUpdateOperationsInput | string
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: string[] | string
    notIn?: string[] | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type BytesNullableFilter = {
    equals?: Buffer | null
    in?: Buffer[] | Buffer | null
    notIn?: Buffer[] | Buffer | null
    not?: NestedBytesNullableFilter | Buffer | null
    isSet?: boolean
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Date[] | string[] | Date | string
    notIn?: Date[] | string[] | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type CityRelationFilter = {
    is?: CityWhereInput | null
    isNot?: CityWhereInput | null
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    cityId?: SortOrder
    gender?: SortOrder
    contactNumber?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    cityId?: SortOrder
    gender?: SortOrder
    contactNumber?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    cityId?: SortOrder
    gender?: SortOrder
    contactNumber?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: string[] | string
    notIn?: string[] | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type BytesNullableWithAggregatesFilter = {
    equals?: Buffer | null
    in?: Buffer[] | Buffer | null
    notIn?: Buffer[] | Buffer | null
    not?: NestedBytesNullableWithAggregatesFilter | Buffer | null
    _count?: NestedIntNullableFilter
    _min?: NestedBytesNullableFilter
    _max?: NestedBytesNullableFilter
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Date[] | string[] | Date | string
    notIn?: Date[] | string[] | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: string[] | string | null
    notIn?: string[] | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
    isSet?: boolean
  }

  export type FloatFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type DonationListRelationFilter = {
    every?: DonationWhereInput
    some?: DonationWhereInput
    none?: DonationWhereInput
  }

  export type AdvertisementListRelationFilter = {
    every?: AdvertisementWhereInput
    some?: AdvertisementWhereInput
    none?: AdvertisementWhereInput
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DonationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdvertisementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    organizationname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    contactNumber?: SortOrder
    secRegistrationNumber?: SortOrder
    verificationStatus?: SortOrder
    totalPoints?: SortOrder
    type?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
  }

  export type OrganizationAvgOrderByAggregateInput = {
    totalPoints?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    contactNumber?: SortOrder
    secRegistrationNumber?: SortOrder
    verificationStatus?: SortOrder
    totalPoints?: SortOrder
    type?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    organizationname?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    contactNumber?: SortOrder
    secRegistrationNumber?: SortOrder
    verificationStatus?: SortOrder
    totalPoints?: SortOrder
    type?: SortOrder
    profilePicture?: SortOrder
    createdAt?: SortOrder
  }

  export type OrganizationSumOrderByAggregateInput = {
    totalPoints?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: string[] | string | null
    notIn?: string[] | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    isSet?: boolean
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type OrganizationRelationFilter = {
    is?: OrganizationWhereInput | null
    isNot?: OrganizationWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
  }

  export type ManagerRelationFilter = {
    is?: ManagerWhereInput | null
    isNot?: ManagerWhereInput | null
  }

  export type DropPointCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    password?: SortOrder
  }

  export type DropPointMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    password?: SortOrder
  }

  export type DropPointMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    location?: SortOrder
    openingTime?: SortOrder
    closingTime?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    password?: SortOrder
  }

  export type DropPointListRelationFilter = {
    every?: DropPointWhereInput
    some?: DropPointWhereInput
    none?: DropPointWhereInput
  }

  export type DropPointOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ManagerCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ManagerMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | Date | string | null
    notIn?: Date[] | string[] | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
    isSet?: boolean
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: number[] | number | null
    notIn?: number[] | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
    isSet?: boolean
  }

  export type DropPointRelationFilter = {
    is?: DropPointWhereInput | null
    isNot?: DropPointWhereInput | null
  }

  export type PeripheralListRelationFilter = {
    every?: PeripheralWhereInput
    some?: PeripheralWhereInput
    none?: PeripheralWhereInput
  }

  export type PeripheralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DonationCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    dropPointId?: SortOrder
    createdAt?: SortOrder
    expectedDateOfArrival?: SortOrder
    confirmedByName?: SortOrder
    confirmedByEmail?: SortOrder
    status?: SortOrder
    isSubmitted?: SortOrder
    points?: SortOrder
  }

  export type DonationAvgOrderByAggregateInput = {
    points?: SortOrder
  }

  export type DonationMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    dropPointId?: SortOrder
    createdAt?: SortOrder
    expectedDateOfArrival?: SortOrder
    confirmedByName?: SortOrder
    confirmedByEmail?: SortOrder
    status?: SortOrder
    isSubmitted?: SortOrder
    points?: SortOrder
  }

  export type DonationMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    dropPointId?: SortOrder
    createdAt?: SortOrder
    expectedDateOfArrival?: SortOrder
    confirmedByName?: SortOrder
    confirmedByEmail?: SortOrder
    status?: SortOrder
    isSubmitted?: SortOrder
    points?: SortOrder
  }

  export type DonationSumOrderByAggregateInput = {
    points?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | Date | string | null
    notIn?: Date[] | string[] | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    isSet?: boolean
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: number[] | number | null
    notIn?: number[] | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
    isSet?: boolean
  }

  export type IntFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type DonationRelationFilter = {
    is?: DonationWhereInput | null
    isNot?: DonationWhereInput | null
  }

  export type PeripheralCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    condition?: SortOrder
    quantity?: SortOrder
    donationId?: SortOrder
  }

  export type PeripheralAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type PeripheralMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    condition?: SortOrder
    quantity?: SortOrder
    donationId?: SortOrder
  }

  export type PeripheralMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    condition?: SortOrder
    quantity?: SortOrder
    donationId?: SortOrder
  }

  export type PeripheralSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    requiredPoints?: SortOrder
  }

  export type CityAvgOrderByAggregateInput = {
    requiredPoints?: SortOrder
  }

  export type CityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    requiredPoints?: SortOrder
  }

  export type CityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    requiredPoints?: SortOrder
  }

  export type CitySumOrderByAggregateInput = {
    requiredPoints?: SortOrder
  }

  export type BytesFilter = {
    equals?: Buffer
    in?: Buffer[] | Buffer
    notIn?: Buffer[] | Buffer
    not?: NestedBytesFilter | Buffer
  }

  export type AdInteractionListRelationFilter = {
    every?: AdInteractionWhereInput
    some?: AdInteractionWhereInput
    none?: AdInteractionWhereInput
  }

  export type AdInteractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdvertisementCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    cityId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    pointsSpent?: SortOrder
    link?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
  }

  export type AdvertisementAvgOrderByAggregateInput = {
    pointsSpent?: SortOrder
  }

  export type AdvertisementMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    cityId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    pointsSpent?: SortOrder
    link?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
  }

  export type AdvertisementMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    cityId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    pointsSpent?: SortOrder
    link?: SortOrder
    imageUrl?: SortOrder
    isActive?: SortOrder
    startDate?: SortOrder
    expiryDate?: SortOrder
  }

  export type AdvertisementSumOrderByAggregateInput = {
    pointsSpent?: SortOrder
  }

  export type BytesWithAggregatesFilter = {
    equals?: Buffer
    in?: Buffer[] | Buffer
    notIn?: Buffer[] | Buffer
    not?: NestedBytesWithAggregatesFilter | Buffer
    _count?: NestedIntFilter
    _min?: NestedBytesFilter
    _max?: NestedBytesFilter
  }

  export type AdvertisementRelationFilter = {
    is?: AdvertisementWhereInput | null
    isNot?: AdvertisementWhereInput | null
  }

  export type AdInteractionCountOrderByAggregateInput = {
    id?: SortOrder
    advertisementId?: SortOrder
    clickedAt?: SortOrder
  }

  export type AdInteractionMaxOrderByAggregateInput = {
    id?: SortOrder
    advertisementId?: SortOrder
    clickedAt?: SortOrder
  }

  export type AdInteractionMinOrderByAggregateInput = {
    id?: SortOrder
    advertisementId?: SortOrder
    clickedAt?: SortOrder
  }

  export type CityCreateNestedOneWithoutUsersInput = {
    create?: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CityCreateOrConnectWithoutUsersInput
    connect?: CityWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
    unset?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CityUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CityCreateOrConnectWithoutUsersInput
    upsert?: CityUpsertWithoutUsersInput
    connect?: CityWhereUniqueInput
    update?: XOR<CityUpdateWithoutUsersInput, CityUncheckedUpdateWithoutUsersInput>
  }

  export type DocumentCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<DocumentCreateWithoutOrganizationInput, DocumentUncheckedCreateWithoutOrganizationInput> | DocumentCreateWithoutOrganizationInput[] | DocumentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOrganizationInput | DocumentCreateOrConnectWithoutOrganizationInput[]
    createMany?: DocumentCreateManyOrganizationInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DonationCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<DonationCreateWithoutOrganizationInput, DonationUncheckedCreateWithoutOrganizationInput> | DonationCreateWithoutOrganizationInput[] | DonationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutOrganizationInput | DonationCreateOrConnectWithoutOrganizationInput[]
    createMany?: DonationCreateManyOrganizationInputEnvelope
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
  }

  export type AdvertisementCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<AdvertisementCreateWithoutOrganizationInput, AdvertisementUncheckedCreateWithoutOrganizationInput> | AdvertisementCreateWithoutOrganizationInput[] | AdvertisementUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AdvertisementCreateOrConnectWithoutOrganizationInput | AdvertisementCreateOrConnectWithoutOrganizationInput[]
    createMany?: AdvertisementCreateManyOrganizationInputEnvelope
    connect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<DocumentCreateWithoutOrganizationInput, DocumentUncheckedCreateWithoutOrganizationInput> | DocumentCreateWithoutOrganizationInput[] | DocumentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOrganizationInput | DocumentCreateOrConnectWithoutOrganizationInput[]
    createMany?: DocumentCreateManyOrganizationInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DonationUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<DonationCreateWithoutOrganizationInput, DonationUncheckedCreateWithoutOrganizationInput> | DonationCreateWithoutOrganizationInput[] | DonationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutOrganizationInput | DonationCreateOrConnectWithoutOrganizationInput[]
    createMany?: DonationCreateManyOrganizationInputEnvelope
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
  }

  export type AdvertisementUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<AdvertisementCreateWithoutOrganizationInput, AdvertisementUncheckedCreateWithoutOrganizationInput> | AdvertisementCreateWithoutOrganizationInput[] | AdvertisementUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AdvertisementCreateOrConnectWithoutOrganizationInput | AdvertisementCreateOrConnectWithoutOrganizationInput[]
    createMany?: AdvertisementCreateManyOrganizationInputEnvelope
    connect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DocumentUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<DocumentCreateWithoutOrganizationInput, DocumentUncheckedCreateWithoutOrganizationInput> | DocumentCreateWithoutOrganizationInput[] | DocumentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOrganizationInput | DocumentCreateOrConnectWithoutOrganizationInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutOrganizationInput | DocumentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: DocumentCreateManyOrganizationInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutOrganizationInput | DocumentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutOrganizationInput | DocumentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DonationUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<DonationCreateWithoutOrganizationInput, DonationUncheckedCreateWithoutOrganizationInput> | DonationCreateWithoutOrganizationInput[] | DonationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutOrganizationInput | DonationCreateOrConnectWithoutOrganizationInput[]
    upsert?: DonationUpsertWithWhereUniqueWithoutOrganizationInput | DonationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: DonationCreateManyOrganizationInputEnvelope
    set?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    disconnect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    delete?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    update?: DonationUpdateWithWhereUniqueWithoutOrganizationInput | DonationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: DonationUpdateManyWithWhereWithoutOrganizationInput | DonationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: DonationScalarWhereInput | DonationScalarWhereInput[]
  }

  export type AdvertisementUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<AdvertisementCreateWithoutOrganizationInput, AdvertisementUncheckedCreateWithoutOrganizationInput> | AdvertisementCreateWithoutOrganizationInput[] | AdvertisementUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AdvertisementCreateOrConnectWithoutOrganizationInput | AdvertisementCreateOrConnectWithoutOrganizationInput[]
    upsert?: AdvertisementUpsertWithWhereUniqueWithoutOrganizationInput | AdvertisementUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: AdvertisementCreateManyOrganizationInputEnvelope
    set?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    disconnect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    delete?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    connect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    update?: AdvertisementUpdateWithWhereUniqueWithoutOrganizationInput | AdvertisementUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: AdvertisementUpdateManyWithWhereWithoutOrganizationInput | AdvertisementUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: AdvertisementScalarWhereInput | AdvertisementScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<DocumentCreateWithoutOrganizationInput, DocumentUncheckedCreateWithoutOrganizationInput> | DocumentCreateWithoutOrganizationInput[] | DocumentUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutOrganizationInput | DocumentCreateOrConnectWithoutOrganizationInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutOrganizationInput | DocumentUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: DocumentCreateManyOrganizationInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutOrganizationInput | DocumentUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutOrganizationInput | DocumentUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DonationUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<DonationCreateWithoutOrganizationInput, DonationUncheckedCreateWithoutOrganizationInput> | DonationCreateWithoutOrganizationInput[] | DonationUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutOrganizationInput | DonationCreateOrConnectWithoutOrganizationInput[]
    upsert?: DonationUpsertWithWhereUniqueWithoutOrganizationInput | DonationUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: DonationCreateManyOrganizationInputEnvelope
    set?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    disconnect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    delete?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    update?: DonationUpdateWithWhereUniqueWithoutOrganizationInput | DonationUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: DonationUpdateManyWithWhereWithoutOrganizationInput | DonationUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: DonationScalarWhereInput | DonationScalarWhereInput[]
  }

  export type AdvertisementUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<AdvertisementCreateWithoutOrganizationInput, AdvertisementUncheckedCreateWithoutOrganizationInput> | AdvertisementCreateWithoutOrganizationInput[] | AdvertisementUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: AdvertisementCreateOrConnectWithoutOrganizationInput | AdvertisementCreateOrConnectWithoutOrganizationInput[]
    upsert?: AdvertisementUpsertWithWhereUniqueWithoutOrganizationInput | AdvertisementUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: AdvertisementCreateManyOrganizationInputEnvelope
    set?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    disconnect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    delete?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    connect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    update?: AdvertisementUpdateWithWhereUniqueWithoutOrganizationInput | AdvertisementUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: AdvertisementUpdateManyWithWhereWithoutOrganizationInput | AdvertisementUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: AdvertisementScalarWhereInput | AdvertisementScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutSubmittedDocumentsInput = {
    create?: XOR<OrganizationCreateWithoutSubmittedDocumentsInput, OrganizationUncheckedCreateWithoutSubmittedDocumentsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubmittedDocumentsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type OrganizationUpdateOneWithoutSubmittedDocumentsNestedInput = {
    create?: XOR<OrganizationCreateWithoutSubmittedDocumentsInput, OrganizationUncheckedCreateWithoutSubmittedDocumentsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutSubmittedDocumentsInput
    upsert?: OrganizationUpsertWithoutSubmittedDocumentsInput
    disconnect?: boolean
    delete?: boolean
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutSubmittedDocumentsInput, OrganizationUncheckedUpdateWithoutSubmittedDocumentsInput>
  }

  export type ManagerCreateNestedOneWithoutDropPointInput = {
    create?: XOR<ManagerCreateWithoutDropPointInput, ManagerUncheckedCreateWithoutDropPointInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutDropPointInput
    connect?: ManagerWhereUniqueInput
  }

  export type DonationCreateNestedManyWithoutDropPointInput = {
    create?: XOR<DonationCreateWithoutDropPointInput, DonationUncheckedCreateWithoutDropPointInput> | DonationCreateWithoutDropPointInput[] | DonationUncheckedCreateWithoutDropPointInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutDropPointInput | DonationCreateOrConnectWithoutDropPointInput[]
    createMany?: DonationCreateManyDropPointInputEnvelope
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
  }

  export type DonationUncheckedCreateNestedManyWithoutDropPointInput = {
    create?: XOR<DonationCreateWithoutDropPointInput, DonationUncheckedCreateWithoutDropPointInput> | DonationCreateWithoutDropPointInput[] | DonationUncheckedCreateWithoutDropPointInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutDropPointInput | DonationCreateOrConnectWithoutDropPointInput[]
    createMany?: DonationCreateManyDropPointInputEnvelope
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
  }

  export type ManagerUpdateOneWithoutDropPointNestedInput = {
    create?: XOR<ManagerCreateWithoutDropPointInput, ManagerUncheckedCreateWithoutDropPointInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutDropPointInput
    upsert?: ManagerUpsertWithoutDropPointInput
    disconnect?: boolean
    delete?: boolean
    connect?: ManagerWhereUniqueInput
    update?: XOR<ManagerUpdateWithoutDropPointInput, ManagerUncheckedUpdateWithoutDropPointInput>
  }

  export type DonationUpdateManyWithoutDropPointNestedInput = {
    create?: XOR<DonationCreateWithoutDropPointInput, DonationUncheckedCreateWithoutDropPointInput> | DonationCreateWithoutDropPointInput[] | DonationUncheckedCreateWithoutDropPointInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutDropPointInput | DonationCreateOrConnectWithoutDropPointInput[]
    upsert?: DonationUpsertWithWhereUniqueWithoutDropPointInput | DonationUpsertWithWhereUniqueWithoutDropPointInput[]
    createMany?: DonationCreateManyDropPointInputEnvelope
    set?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    disconnect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    delete?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    update?: DonationUpdateWithWhereUniqueWithoutDropPointInput | DonationUpdateWithWhereUniqueWithoutDropPointInput[]
    updateMany?: DonationUpdateManyWithWhereWithoutDropPointInput | DonationUpdateManyWithWhereWithoutDropPointInput[]
    deleteMany?: DonationScalarWhereInput | DonationScalarWhereInput[]
  }

  export type DonationUncheckedUpdateManyWithoutDropPointNestedInput = {
    create?: XOR<DonationCreateWithoutDropPointInput, DonationUncheckedCreateWithoutDropPointInput> | DonationCreateWithoutDropPointInput[] | DonationUncheckedCreateWithoutDropPointInput[]
    connectOrCreate?: DonationCreateOrConnectWithoutDropPointInput | DonationCreateOrConnectWithoutDropPointInput[]
    upsert?: DonationUpsertWithWhereUniqueWithoutDropPointInput | DonationUpsertWithWhereUniqueWithoutDropPointInput[]
    createMany?: DonationCreateManyDropPointInputEnvelope
    set?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    disconnect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    delete?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    connect?: DonationWhereUniqueInput | DonationWhereUniqueInput[]
    update?: DonationUpdateWithWhereUniqueWithoutDropPointInput | DonationUpdateWithWhereUniqueWithoutDropPointInput[]
    updateMany?: DonationUpdateManyWithWhereWithoutDropPointInput | DonationUpdateManyWithWhereWithoutDropPointInput[]
    deleteMany?: DonationScalarWhereInput | DonationScalarWhereInput[]
  }

  export type DropPointCreateNestedManyWithoutManagerInput = {
    create?: XOR<DropPointCreateWithoutManagerInput, DropPointUncheckedCreateWithoutManagerInput> | DropPointCreateWithoutManagerInput[] | DropPointUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: DropPointCreateOrConnectWithoutManagerInput | DropPointCreateOrConnectWithoutManagerInput[]
    createMany?: DropPointCreateManyManagerInputEnvelope
    connect?: DropPointWhereUniqueInput | DropPointWhereUniqueInput[]
  }

  export type DropPointUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<DropPointCreateWithoutManagerInput, DropPointUncheckedCreateWithoutManagerInput> | DropPointCreateWithoutManagerInput[] | DropPointUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: DropPointCreateOrConnectWithoutManagerInput | DropPointCreateOrConnectWithoutManagerInput[]
    createMany?: DropPointCreateManyManagerInputEnvelope
    connect?: DropPointWhereUniqueInput | DropPointWhereUniqueInput[]
  }

  export type DropPointUpdateManyWithoutManagerNestedInput = {
    create?: XOR<DropPointCreateWithoutManagerInput, DropPointUncheckedCreateWithoutManagerInput> | DropPointCreateWithoutManagerInput[] | DropPointUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: DropPointCreateOrConnectWithoutManagerInput | DropPointCreateOrConnectWithoutManagerInput[]
    upsert?: DropPointUpsertWithWhereUniqueWithoutManagerInput | DropPointUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: DropPointCreateManyManagerInputEnvelope
    set?: DropPointWhereUniqueInput | DropPointWhereUniqueInput[]
    disconnect?: DropPointWhereUniqueInput | DropPointWhereUniqueInput[]
    delete?: DropPointWhereUniqueInput | DropPointWhereUniqueInput[]
    connect?: DropPointWhereUniqueInput | DropPointWhereUniqueInput[]
    update?: DropPointUpdateWithWhereUniqueWithoutManagerInput | DropPointUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: DropPointUpdateManyWithWhereWithoutManagerInput | DropPointUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: DropPointScalarWhereInput | DropPointScalarWhereInput[]
  }

  export type DropPointUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<DropPointCreateWithoutManagerInput, DropPointUncheckedCreateWithoutManagerInput> | DropPointCreateWithoutManagerInput[] | DropPointUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: DropPointCreateOrConnectWithoutManagerInput | DropPointCreateOrConnectWithoutManagerInput[]
    upsert?: DropPointUpsertWithWhereUniqueWithoutManagerInput | DropPointUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: DropPointCreateManyManagerInputEnvelope
    set?: DropPointWhereUniqueInput | DropPointWhereUniqueInput[]
    disconnect?: DropPointWhereUniqueInput | DropPointWhereUniqueInput[]
    delete?: DropPointWhereUniqueInput | DropPointWhereUniqueInput[]
    connect?: DropPointWhereUniqueInput | DropPointWhereUniqueInput[]
    update?: DropPointUpdateWithWhereUniqueWithoutManagerInput | DropPointUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: DropPointUpdateManyWithWhereWithoutManagerInput | DropPointUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: DropPointScalarWhereInput | DropPointScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutDonationsInput = {
    create?: XOR<OrganizationCreateWithoutDonationsInput, OrganizationUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutDonationsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type DropPointCreateNestedOneWithoutDonationsInput = {
    create?: XOR<DropPointCreateWithoutDonationsInput, DropPointUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: DropPointCreateOrConnectWithoutDonationsInput
    connect?: DropPointWhereUniqueInput
  }

  export type PeripheralCreateNestedManyWithoutDonationInput = {
    create?: XOR<PeripheralCreateWithoutDonationInput, PeripheralUncheckedCreateWithoutDonationInput> | PeripheralCreateWithoutDonationInput[] | PeripheralUncheckedCreateWithoutDonationInput[]
    connectOrCreate?: PeripheralCreateOrConnectWithoutDonationInput | PeripheralCreateOrConnectWithoutDonationInput[]
    createMany?: PeripheralCreateManyDonationInputEnvelope
    connect?: PeripheralWhereUniqueInput | PeripheralWhereUniqueInput[]
  }

  export type PeripheralUncheckedCreateNestedManyWithoutDonationInput = {
    create?: XOR<PeripheralCreateWithoutDonationInput, PeripheralUncheckedCreateWithoutDonationInput> | PeripheralCreateWithoutDonationInput[] | PeripheralUncheckedCreateWithoutDonationInput[]
    connectOrCreate?: PeripheralCreateOrConnectWithoutDonationInput | PeripheralCreateOrConnectWithoutDonationInput[]
    createMany?: PeripheralCreateManyDonationInputEnvelope
    connect?: PeripheralWhereUniqueInput | PeripheralWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type OrganizationUpdateOneRequiredWithoutDonationsNestedInput = {
    create?: XOR<OrganizationCreateWithoutDonationsInput, OrganizationUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutDonationsInput
    upsert?: OrganizationUpsertWithoutDonationsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutDonationsInput, OrganizationUncheckedUpdateWithoutDonationsInput>
  }

  export type DropPointUpdateOneRequiredWithoutDonationsNestedInput = {
    create?: XOR<DropPointCreateWithoutDonationsInput, DropPointUncheckedCreateWithoutDonationsInput>
    connectOrCreate?: DropPointCreateOrConnectWithoutDonationsInput
    upsert?: DropPointUpsertWithoutDonationsInput
    connect?: DropPointWhereUniqueInput
    update?: XOR<DropPointUpdateWithoutDonationsInput, DropPointUncheckedUpdateWithoutDonationsInput>
  }

  export type PeripheralUpdateManyWithoutDonationNestedInput = {
    create?: XOR<PeripheralCreateWithoutDonationInput, PeripheralUncheckedCreateWithoutDonationInput> | PeripheralCreateWithoutDonationInput[] | PeripheralUncheckedCreateWithoutDonationInput[]
    connectOrCreate?: PeripheralCreateOrConnectWithoutDonationInput | PeripheralCreateOrConnectWithoutDonationInput[]
    upsert?: PeripheralUpsertWithWhereUniqueWithoutDonationInput | PeripheralUpsertWithWhereUniqueWithoutDonationInput[]
    createMany?: PeripheralCreateManyDonationInputEnvelope
    set?: PeripheralWhereUniqueInput | PeripheralWhereUniqueInput[]
    disconnect?: PeripheralWhereUniqueInput | PeripheralWhereUniqueInput[]
    delete?: PeripheralWhereUniqueInput | PeripheralWhereUniqueInput[]
    connect?: PeripheralWhereUniqueInput | PeripheralWhereUniqueInput[]
    update?: PeripheralUpdateWithWhereUniqueWithoutDonationInput | PeripheralUpdateWithWhereUniqueWithoutDonationInput[]
    updateMany?: PeripheralUpdateManyWithWhereWithoutDonationInput | PeripheralUpdateManyWithWhereWithoutDonationInput[]
    deleteMany?: PeripheralScalarWhereInput | PeripheralScalarWhereInput[]
  }

  export type PeripheralUncheckedUpdateManyWithoutDonationNestedInput = {
    create?: XOR<PeripheralCreateWithoutDonationInput, PeripheralUncheckedCreateWithoutDonationInput> | PeripheralCreateWithoutDonationInput[] | PeripheralUncheckedCreateWithoutDonationInput[]
    connectOrCreate?: PeripheralCreateOrConnectWithoutDonationInput | PeripheralCreateOrConnectWithoutDonationInput[]
    upsert?: PeripheralUpsertWithWhereUniqueWithoutDonationInput | PeripheralUpsertWithWhereUniqueWithoutDonationInput[]
    createMany?: PeripheralCreateManyDonationInputEnvelope
    set?: PeripheralWhereUniqueInput | PeripheralWhereUniqueInput[]
    disconnect?: PeripheralWhereUniqueInput | PeripheralWhereUniqueInput[]
    delete?: PeripheralWhereUniqueInput | PeripheralWhereUniqueInput[]
    connect?: PeripheralWhereUniqueInput | PeripheralWhereUniqueInput[]
    update?: PeripheralUpdateWithWhereUniqueWithoutDonationInput | PeripheralUpdateWithWhereUniqueWithoutDonationInput[]
    updateMany?: PeripheralUpdateManyWithWhereWithoutDonationInput | PeripheralUpdateManyWithWhereWithoutDonationInput[]
    deleteMany?: PeripheralScalarWhereInput | PeripheralScalarWhereInput[]
  }

  export type DonationCreateNestedOneWithoutPeripheralsInput = {
    create?: XOR<DonationCreateWithoutPeripheralsInput, DonationUncheckedCreateWithoutPeripheralsInput>
    connectOrCreate?: DonationCreateOrConnectWithoutPeripheralsInput
    connect?: DonationWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DonationUpdateOneRequiredWithoutPeripheralsNestedInput = {
    create?: XOR<DonationCreateWithoutPeripheralsInput, DonationUncheckedCreateWithoutPeripheralsInput>
    connectOrCreate?: DonationCreateOrConnectWithoutPeripheralsInput
    upsert?: DonationUpsertWithoutPeripheralsInput
    connect?: DonationWhereUniqueInput
    update?: XOR<DonationUpdateWithoutPeripheralsInput, DonationUncheckedUpdateWithoutPeripheralsInput>
  }

  export type UserCreateNestedManyWithoutCityInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdvertisementCreateNestedManyWithoutCityInput = {
    create?: XOR<AdvertisementCreateWithoutCityInput, AdvertisementUncheckedCreateWithoutCityInput> | AdvertisementCreateWithoutCityInput[] | AdvertisementUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdvertisementCreateOrConnectWithoutCityInput | AdvertisementCreateOrConnectWithoutCityInput[]
    createMany?: AdvertisementCreateManyCityInputEnvelope
    connect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type AdvertisementUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<AdvertisementCreateWithoutCityInput, AdvertisementUncheckedCreateWithoutCityInput> | AdvertisementCreateWithoutCityInput[] | AdvertisementUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdvertisementCreateOrConnectWithoutCityInput | AdvertisementCreateOrConnectWithoutCityInput[]
    createMany?: AdvertisementCreateManyCityInputEnvelope
    connect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutCityNestedInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCityInput | UserUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCityInput | UserUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCityInput | UserUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdvertisementUpdateManyWithoutCityNestedInput = {
    create?: XOR<AdvertisementCreateWithoutCityInput, AdvertisementUncheckedCreateWithoutCityInput> | AdvertisementCreateWithoutCityInput[] | AdvertisementUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdvertisementCreateOrConnectWithoutCityInput | AdvertisementCreateOrConnectWithoutCityInput[]
    upsert?: AdvertisementUpsertWithWhereUniqueWithoutCityInput | AdvertisementUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: AdvertisementCreateManyCityInputEnvelope
    set?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    disconnect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    delete?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    connect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    update?: AdvertisementUpdateWithWhereUniqueWithoutCityInput | AdvertisementUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: AdvertisementUpdateManyWithWhereWithoutCityInput | AdvertisementUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: AdvertisementScalarWhereInput | AdvertisementScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput> | UserCreateWithoutCityInput[] | UserUncheckedCreateWithoutCityInput[]
    connectOrCreate?: UserCreateOrConnectWithoutCityInput | UserCreateOrConnectWithoutCityInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutCityInput | UserUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: UserCreateManyCityInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutCityInput | UserUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: UserUpdateManyWithWhereWithoutCityInput | UserUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type AdvertisementUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<AdvertisementCreateWithoutCityInput, AdvertisementUncheckedCreateWithoutCityInput> | AdvertisementCreateWithoutCityInput[] | AdvertisementUncheckedCreateWithoutCityInput[]
    connectOrCreate?: AdvertisementCreateOrConnectWithoutCityInput | AdvertisementCreateOrConnectWithoutCityInput[]
    upsert?: AdvertisementUpsertWithWhereUniqueWithoutCityInput | AdvertisementUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: AdvertisementCreateManyCityInputEnvelope
    set?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    disconnect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    delete?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    connect?: AdvertisementWhereUniqueInput | AdvertisementWhereUniqueInput[]
    update?: AdvertisementUpdateWithWhereUniqueWithoutCityInput | AdvertisementUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: AdvertisementUpdateManyWithWhereWithoutCityInput | AdvertisementUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: AdvertisementScalarWhereInput | AdvertisementScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutAdvertisementsInput = {
    create?: XOR<OrganizationCreateWithoutAdvertisementsInput, OrganizationUncheckedCreateWithoutAdvertisementsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAdvertisementsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type CityCreateNestedOneWithoutAdvertisementsInput = {
    create?: XOR<CityCreateWithoutAdvertisementsInput, CityUncheckedCreateWithoutAdvertisementsInput>
    connectOrCreate?: CityCreateOrConnectWithoutAdvertisementsInput
    connect?: CityWhereUniqueInput
  }

  export type AdInteractionCreateNestedManyWithoutAdvertisementInput = {
    create?: XOR<AdInteractionCreateWithoutAdvertisementInput, AdInteractionUncheckedCreateWithoutAdvertisementInput> | AdInteractionCreateWithoutAdvertisementInput[] | AdInteractionUncheckedCreateWithoutAdvertisementInput[]
    connectOrCreate?: AdInteractionCreateOrConnectWithoutAdvertisementInput | AdInteractionCreateOrConnectWithoutAdvertisementInput[]
    createMany?: AdInteractionCreateManyAdvertisementInputEnvelope
    connect?: AdInteractionWhereUniqueInput | AdInteractionWhereUniqueInput[]
  }

  export type AdInteractionUncheckedCreateNestedManyWithoutAdvertisementInput = {
    create?: XOR<AdInteractionCreateWithoutAdvertisementInput, AdInteractionUncheckedCreateWithoutAdvertisementInput> | AdInteractionCreateWithoutAdvertisementInput[] | AdInteractionUncheckedCreateWithoutAdvertisementInput[]
    connectOrCreate?: AdInteractionCreateOrConnectWithoutAdvertisementInput | AdInteractionCreateOrConnectWithoutAdvertisementInput[]
    createMany?: AdInteractionCreateManyAdvertisementInputEnvelope
    connect?: AdInteractionWhereUniqueInput | AdInteractionWhereUniqueInput[]
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Buffer
  }

  export type OrganizationUpdateOneRequiredWithoutAdvertisementsNestedInput = {
    create?: XOR<OrganizationCreateWithoutAdvertisementsInput, OrganizationUncheckedCreateWithoutAdvertisementsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutAdvertisementsInput
    upsert?: OrganizationUpsertWithoutAdvertisementsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<OrganizationUpdateWithoutAdvertisementsInput, OrganizationUncheckedUpdateWithoutAdvertisementsInput>
  }

  export type CityUpdateOneRequiredWithoutAdvertisementsNestedInput = {
    create?: XOR<CityCreateWithoutAdvertisementsInput, CityUncheckedCreateWithoutAdvertisementsInput>
    connectOrCreate?: CityCreateOrConnectWithoutAdvertisementsInput
    upsert?: CityUpsertWithoutAdvertisementsInput
    connect?: CityWhereUniqueInput
    update?: XOR<CityUpdateWithoutAdvertisementsInput, CityUncheckedUpdateWithoutAdvertisementsInput>
  }

  export type AdInteractionUpdateManyWithoutAdvertisementNestedInput = {
    create?: XOR<AdInteractionCreateWithoutAdvertisementInput, AdInteractionUncheckedCreateWithoutAdvertisementInput> | AdInteractionCreateWithoutAdvertisementInput[] | AdInteractionUncheckedCreateWithoutAdvertisementInput[]
    connectOrCreate?: AdInteractionCreateOrConnectWithoutAdvertisementInput | AdInteractionCreateOrConnectWithoutAdvertisementInput[]
    upsert?: AdInteractionUpsertWithWhereUniqueWithoutAdvertisementInput | AdInteractionUpsertWithWhereUniqueWithoutAdvertisementInput[]
    createMany?: AdInteractionCreateManyAdvertisementInputEnvelope
    set?: AdInteractionWhereUniqueInput | AdInteractionWhereUniqueInput[]
    disconnect?: AdInteractionWhereUniqueInput | AdInteractionWhereUniqueInput[]
    delete?: AdInteractionWhereUniqueInput | AdInteractionWhereUniqueInput[]
    connect?: AdInteractionWhereUniqueInput | AdInteractionWhereUniqueInput[]
    update?: AdInteractionUpdateWithWhereUniqueWithoutAdvertisementInput | AdInteractionUpdateWithWhereUniqueWithoutAdvertisementInput[]
    updateMany?: AdInteractionUpdateManyWithWhereWithoutAdvertisementInput | AdInteractionUpdateManyWithWhereWithoutAdvertisementInput[]
    deleteMany?: AdInteractionScalarWhereInput | AdInteractionScalarWhereInput[]
  }

  export type AdInteractionUncheckedUpdateManyWithoutAdvertisementNestedInput = {
    create?: XOR<AdInteractionCreateWithoutAdvertisementInput, AdInteractionUncheckedCreateWithoutAdvertisementInput> | AdInteractionCreateWithoutAdvertisementInput[] | AdInteractionUncheckedCreateWithoutAdvertisementInput[]
    connectOrCreate?: AdInteractionCreateOrConnectWithoutAdvertisementInput | AdInteractionCreateOrConnectWithoutAdvertisementInput[]
    upsert?: AdInteractionUpsertWithWhereUniqueWithoutAdvertisementInput | AdInteractionUpsertWithWhereUniqueWithoutAdvertisementInput[]
    createMany?: AdInteractionCreateManyAdvertisementInputEnvelope
    set?: AdInteractionWhereUniqueInput | AdInteractionWhereUniqueInput[]
    disconnect?: AdInteractionWhereUniqueInput | AdInteractionWhereUniqueInput[]
    delete?: AdInteractionWhereUniqueInput | AdInteractionWhereUniqueInput[]
    connect?: AdInteractionWhereUniqueInput | AdInteractionWhereUniqueInput[]
    update?: AdInteractionUpdateWithWhereUniqueWithoutAdvertisementInput | AdInteractionUpdateWithWhereUniqueWithoutAdvertisementInput[]
    updateMany?: AdInteractionUpdateManyWithWhereWithoutAdvertisementInput | AdInteractionUpdateManyWithWhereWithoutAdvertisementInput[]
    deleteMany?: AdInteractionScalarWhereInput | AdInteractionScalarWhereInput[]
  }

  export type AdvertisementCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<AdvertisementCreateWithoutInteractionsInput, AdvertisementUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: AdvertisementCreateOrConnectWithoutInteractionsInput
    connect?: AdvertisementWhereUniqueInput
  }

  export type AdvertisementUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<AdvertisementCreateWithoutInteractionsInput, AdvertisementUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: AdvertisementCreateOrConnectWithoutInteractionsInput
    upsert?: AdvertisementUpsertWithoutInteractionsInput
    connect?: AdvertisementWhereUniqueInput
    update?: XOR<AdvertisementUpdateWithoutInteractionsInput, AdvertisementUncheckedUpdateWithoutInteractionsInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: string[] | string
    notIn?: string[] | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedBytesNullableFilter = {
    equals?: Buffer | null
    in?: Buffer[] | Buffer | null
    notIn?: Buffer[] | Buffer | null
    not?: NestedBytesNullableFilter | Buffer | null
    isSet?: boolean
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Date[] | string[] | Date | string
    notIn?: Date[] | string[] | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: string[] | string
    notIn?: string[] | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedBytesNullableWithAggregatesFilter = {
    equals?: Buffer | null
    in?: Buffer[] | Buffer | null
    notIn?: Buffer[] | Buffer | null
    not?: NestedBytesNullableWithAggregatesFilter | Buffer | null
    _count?: NestedIntNullableFilter
    _min?: NestedBytesNullableFilter
    _max?: NestedBytesNullableFilter
    isSet?: boolean
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: number[] | number | null
    notIn?: number[] | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Date[] | string[] | Date | string
    notIn?: Date[] | string[] | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: string[] | string | null
    notIn?: string[] | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
    isSet?: boolean
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: string[] | string | null
    notIn?: string[] | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
    isSet?: boolean
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | Date | string | null
    notIn?: Date[] | string[] | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
    isSet?: boolean
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: number[] | number | null
    notIn?: number[] | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Date[] | string[] | Date | string | null
    notIn?: Date[] | string[] | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
    isSet?: boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: number[] | number | null
    notIn?: number[] | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
    isSet?: boolean
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: number[] | number
    notIn?: number[] | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedBytesFilter = {
    equals?: Buffer
    in?: Buffer[] | Buffer
    notIn?: Buffer[] | Buffer
    not?: NestedBytesFilter | Buffer
  }

  export type NestedBytesWithAggregatesFilter = {
    equals?: Buffer
    in?: Buffer[] | Buffer
    notIn?: Buffer[] | Buffer
    not?: NestedBytesWithAggregatesFilter | Buffer
    _count?: NestedIntFilter
    _min?: NestedBytesFilter
    _max?: NestedBytesFilter
  }

  export type CityCreateWithoutUsersInput = {
    id?: string
    name: string
    requiredPoints?: number | null
    advertisements?: AdvertisementCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    requiredPoints?: number | null
    advertisements?: AdvertisementUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutUsersInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
  }

  export type CityUpsertWithoutUsersInput = {
    update: XOR<CityUpdateWithoutUsersInput, CityUncheckedUpdateWithoutUsersInput>
    create: XOR<CityCreateWithoutUsersInput, CityUncheckedCreateWithoutUsersInput>
  }

  export type CityUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    requiredPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    advertisements?: AdvertisementUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    requiredPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    advertisements?: AdvertisementUncheckedUpdateManyWithoutCityNestedInput
  }

  export type DocumentCreateWithoutOrganizationInput = {
    id?: string
    filename: string
    url: string
    uploadedBy: string
    createdAt?: Date | string
  }

  export type DocumentUncheckedCreateWithoutOrganizationInput = {
    id?: string
    filename: string
    url: string
    uploadedBy: string
    createdAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutOrganizationInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutOrganizationInput, DocumentUncheckedCreateWithoutOrganizationInput>
  }

  export type DocumentCreateManyOrganizationInputEnvelope = {
    data: DocumentCreateManyOrganizationInput | DocumentCreateManyOrganizationInput[]
  }

  export type DonationCreateWithoutOrganizationInput = {
    id?: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
    dropPoint: DropPointCreateNestedOneWithoutDonationsInput
    peripherals?: PeripheralCreateNestedManyWithoutDonationInput
  }

  export type DonationUncheckedCreateWithoutOrganizationInput = {
    id?: string
    dropPointId: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
    peripherals?: PeripheralUncheckedCreateNestedManyWithoutDonationInput
  }

  export type DonationCreateOrConnectWithoutOrganizationInput = {
    where: DonationWhereUniqueInput
    create: XOR<DonationCreateWithoutOrganizationInput, DonationUncheckedCreateWithoutOrganizationInput>
  }

  export type DonationCreateManyOrganizationInputEnvelope = {
    data: DonationCreateManyOrganizationInput | DonationCreateManyOrganizationInput[]
  }

  export type AdvertisementCreateWithoutOrganizationInput = {
    id?: string
    title: string
    content: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate: Date | string
    expiryDate: Date | string
    city: CityCreateNestedOneWithoutAdvertisementsInput
    interactions?: AdInteractionCreateNestedManyWithoutAdvertisementInput
  }

  export type AdvertisementUncheckedCreateWithoutOrganizationInput = {
    id?: string
    cityId: string
    title: string
    content: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate: Date | string
    expiryDate: Date | string
    interactions?: AdInteractionUncheckedCreateNestedManyWithoutAdvertisementInput
  }

  export type AdvertisementCreateOrConnectWithoutOrganizationInput = {
    where: AdvertisementWhereUniqueInput
    create: XOR<AdvertisementCreateWithoutOrganizationInput, AdvertisementUncheckedCreateWithoutOrganizationInput>
  }

  export type AdvertisementCreateManyOrganizationInputEnvelope = {
    data: AdvertisementCreateManyOrganizationInput | AdvertisementCreateManyOrganizationInput[]
  }

  export type DocumentUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutOrganizationInput, DocumentUncheckedUpdateWithoutOrganizationInput>
    create: XOR<DocumentCreateWithoutOrganizationInput, DocumentUncheckedCreateWithoutOrganizationInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutOrganizationInput, DocumentUncheckedUpdateWithoutOrganizationInput>
  }

  export type DocumentUpdateManyWithWhereWithoutOrganizationInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutSubmittedDocumentsInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter | string
    filename?: StringFilter | string
    url?: StringFilter | string
    uploadedBy?: StringFilter | string
    organizationId?: StringNullableFilter | string | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type DonationUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: DonationWhereUniqueInput
    update: XOR<DonationUpdateWithoutOrganizationInput, DonationUncheckedUpdateWithoutOrganizationInput>
    create: XOR<DonationCreateWithoutOrganizationInput, DonationUncheckedCreateWithoutOrganizationInput>
  }

  export type DonationUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: DonationWhereUniqueInput
    data: XOR<DonationUpdateWithoutOrganizationInput, DonationUncheckedUpdateWithoutOrganizationInput>
  }

  export type DonationUpdateManyWithWhereWithoutOrganizationInput = {
    where: DonationScalarWhereInput
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyWithoutDonationsInput>
  }

  export type DonationScalarWhereInput = {
    AND?: DonationScalarWhereInput | DonationScalarWhereInput[]
    OR?: DonationScalarWhereInput[]
    NOT?: DonationScalarWhereInput | DonationScalarWhereInput[]
    id?: StringFilter | string
    organizationId?: StringFilter | string
    dropPointId?: StringFilter | string
    createdAt?: DateTimeFilter | Date | string
    expectedDateOfArrival?: DateTimeNullableFilter | Date | string | null
    confirmedByName?: StringNullableFilter | string | null
    confirmedByEmail?: StringNullableFilter | string | null
    status?: StringNullableFilter | string | null
    isSubmitted?: BoolFilter | boolean
    points?: FloatNullableFilter | number | null
  }

  export type AdvertisementUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: AdvertisementWhereUniqueInput
    update: XOR<AdvertisementUpdateWithoutOrganizationInput, AdvertisementUncheckedUpdateWithoutOrganizationInput>
    create: XOR<AdvertisementCreateWithoutOrganizationInput, AdvertisementUncheckedCreateWithoutOrganizationInput>
  }

  export type AdvertisementUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: AdvertisementWhereUniqueInput
    data: XOR<AdvertisementUpdateWithoutOrganizationInput, AdvertisementUncheckedUpdateWithoutOrganizationInput>
  }

  export type AdvertisementUpdateManyWithWhereWithoutOrganizationInput = {
    where: AdvertisementScalarWhereInput
    data: XOR<AdvertisementUpdateManyMutationInput, AdvertisementUncheckedUpdateManyWithoutAdvertisementsInput>
  }

  export type AdvertisementScalarWhereInput = {
    AND?: AdvertisementScalarWhereInput | AdvertisementScalarWhereInput[]
    OR?: AdvertisementScalarWhereInput[]
    NOT?: AdvertisementScalarWhereInput | AdvertisementScalarWhereInput[]
    id?: StringFilter | string
    organizationId?: StringFilter | string
    cityId?: StringFilter | string
    title?: StringFilter | string
    content?: StringFilter | string
    pointsSpent?: FloatFilter | number
    link?: StringFilter | string
    imageUrl?: BytesFilter | Buffer
    isActive?: BoolFilter | boolean
    startDate?: DateTimeFilter | Date | string
    expiryDate?: DateTimeFilter | Date | string
  }

  export type OrganizationCreateWithoutSubmittedDocumentsInput = {
    id?: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber?: string | null
    verificationStatus?: string
    totalPoints?: number
    type: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    donations?: DonationCreateNestedManyWithoutOrganizationInput
    advertisements?: AdvertisementCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutSubmittedDocumentsInput = {
    id?: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber?: string | null
    verificationStatus?: string
    totalPoints?: number
    type: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    donations?: DonationUncheckedCreateNestedManyWithoutOrganizationInput
    advertisements?: AdvertisementUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutSubmittedDocumentsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutSubmittedDocumentsInput, OrganizationUncheckedCreateWithoutSubmittedDocumentsInput>
  }

  export type OrganizationUpsertWithoutSubmittedDocumentsInput = {
    update: XOR<OrganizationUpdateWithoutSubmittedDocumentsInput, OrganizationUncheckedUpdateWithoutSubmittedDocumentsInput>
    create: XOR<OrganizationCreateWithoutSubmittedDocumentsInput, OrganizationUncheckedCreateWithoutSubmittedDocumentsInput>
  }

  export type OrganizationUpdateWithoutSubmittedDocumentsInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    donations?: DonationUpdateManyWithoutOrganizationNestedInput
    advertisements?: AdvertisementUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutSubmittedDocumentsInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    donations?: DonationUncheckedUpdateManyWithoutOrganizationNestedInput
    advertisements?: AdvertisementUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type ManagerCreateWithoutDropPointInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phoneNumber?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManagerUncheckedCreateWithoutDropPointInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phoneNumber?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManagerCreateOrConnectWithoutDropPointInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutDropPointInput, ManagerUncheckedCreateWithoutDropPointInput>
  }

  export type DonationCreateWithoutDropPointInput = {
    id?: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
    organization: OrganizationCreateNestedOneWithoutDonationsInput
    peripherals?: PeripheralCreateNestedManyWithoutDonationInput
  }

  export type DonationUncheckedCreateWithoutDropPointInput = {
    id?: string
    organizationId: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
    peripherals?: PeripheralUncheckedCreateNestedManyWithoutDonationInput
  }

  export type DonationCreateOrConnectWithoutDropPointInput = {
    where: DonationWhereUniqueInput
    create: XOR<DonationCreateWithoutDropPointInput, DonationUncheckedCreateWithoutDropPointInput>
  }

  export type DonationCreateManyDropPointInputEnvelope = {
    data: DonationCreateManyDropPointInput | DonationCreateManyDropPointInput[]
  }

  export type ManagerUpsertWithoutDropPointInput = {
    update: XOR<ManagerUpdateWithoutDropPointInput, ManagerUncheckedUpdateWithoutDropPointInput>
    create: XOR<ManagerCreateWithoutDropPointInput, ManagerUncheckedCreateWithoutDropPointInput>
  }

  export type ManagerUpdateWithoutDropPointInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerUncheckedUpdateWithoutDropPointInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUpsertWithWhereUniqueWithoutDropPointInput = {
    where: DonationWhereUniqueInput
    update: XOR<DonationUpdateWithoutDropPointInput, DonationUncheckedUpdateWithoutDropPointInput>
    create: XOR<DonationCreateWithoutDropPointInput, DonationUncheckedCreateWithoutDropPointInput>
  }

  export type DonationUpdateWithWhereUniqueWithoutDropPointInput = {
    where: DonationWhereUniqueInput
    data: XOR<DonationUpdateWithoutDropPointInput, DonationUncheckedUpdateWithoutDropPointInput>
  }

  export type DonationUpdateManyWithWhereWithoutDropPointInput = {
    where: DonationScalarWhereInput
    data: XOR<DonationUpdateManyMutationInput, DonationUncheckedUpdateManyWithoutDonationsInput>
  }

  export type DropPointCreateWithoutManagerInput = {
    id?: string
    name: string
    location: string
    openingTime: string
    closingTime: string
    description: string
    password?: string | null
    donations?: DonationCreateNestedManyWithoutDropPointInput
  }

  export type DropPointUncheckedCreateWithoutManagerInput = {
    id?: string
    name: string
    location: string
    openingTime: string
    closingTime: string
    description: string
    password?: string | null
    donations?: DonationUncheckedCreateNestedManyWithoutDropPointInput
  }

  export type DropPointCreateOrConnectWithoutManagerInput = {
    where: DropPointWhereUniqueInput
    create: XOR<DropPointCreateWithoutManagerInput, DropPointUncheckedCreateWithoutManagerInput>
  }

  export type DropPointCreateManyManagerInputEnvelope = {
    data: DropPointCreateManyManagerInput | DropPointCreateManyManagerInput[]
  }

  export type DropPointUpsertWithWhereUniqueWithoutManagerInput = {
    where: DropPointWhereUniqueInput
    update: XOR<DropPointUpdateWithoutManagerInput, DropPointUncheckedUpdateWithoutManagerInput>
    create: XOR<DropPointCreateWithoutManagerInput, DropPointUncheckedCreateWithoutManagerInput>
  }

  export type DropPointUpdateWithWhereUniqueWithoutManagerInput = {
    where: DropPointWhereUniqueInput
    data: XOR<DropPointUpdateWithoutManagerInput, DropPointUncheckedUpdateWithoutManagerInput>
  }

  export type DropPointUpdateManyWithWhereWithoutManagerInput = {
    where: DropPointScalarWhereInput
    data: XOR<DropPointUpdateManyMutationInput, DropPointUncheckedUpdateManyWithoutDropPointInput>
  }

  export type DropPointScalarWhereInput = {
    AND?: DropPointScalarWhereInput | DropPointScalarWhereInput[]
    OR?: DropPointScalarWhereInput[]
    NOT?: DropPointScalarWhereInput | DropPointScalarWhereInput[]
    id?: StringFilter | string
    name?: StringFilter | string
    location?: StringFilter | string
    openingTime?: StringFilter | string
    closingTime?: StringFilter | string
    description?: StringFilter | string
    managerId?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
  }

  export type OrganizationCreateWithoutDonationsInput = {
    id?: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber?: string | null
    verificationStatus?: string
    totalPoints?: number
    type: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    submittedDocuments?: DocumentCreateNestedManyWithoutOrganizationInput
    advertisements?: AdvertisementCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutDonationsInput = {
    id?: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber?: string | null
    verificationStatus?: string
    totalPoints?: number
    type: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    submittedDocuments?: DocumentUncheckedCreateNestedManyWithoutOrganizationInput
    advertisements?: AdvertisementUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutDonationsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutDonationsInput, OrganizationUncheckedCreateWithoutDonationsInput>
  }

  export type DropPointCreateWithoutDonationsInput = {
    id?: string
    name: string
    location: string
    openingTime: string
    closingTime: string
    description: string
    password?: string | null
    manager?: ManagerCreateNestedOneWithoutDropPointInput
  }

  export type DropPointUncheckedCreateWithoutDonationsInput = {
    id?: string
    name: string
    location: string
    openingTime: string
    closingTime: string
    description: string
    managerId?: string | null
    password?: string | null
  }

  export type DropPointCreateOrConnectWithoutDonationsInput = {
    where: DropPointWhereUniqueInput
    create: XOR<DropPointCreateWithoutDonationsInput, DropPointUncheckedCreateWithoutDonationsInput>
  }

  export type PeripheralCreateWithoutDonationInput = {
    id?: string
    type: string
    brand: string
    model: string
    condition: string
    quantity?: number
  }

  export type PeripheralUncheckedCreateWithoutDonationInput = {
    id?: string
    type: string
    brand: string
    model: string
    condition: string
    quantity?: number
  }

  export type PeripheralCreateOrConnectWithoutDonationInput = {
    where: PeripheralWhereUniqueInput
    create: XOR<PeripheralCreateWithoutDonationInput, PeripheralUncheckedCreateWithoutDonationInput>
  }

  export type PeripheralCreateManyDonationInputEnvelope = {
    data: PeripheralCreateManyDonationInput | PeripheralCreateManyDonationInput[]
  }

  export type OrganizationUpsertWithoutDonationsInput = {
    update: XOR<OrganizationUpdateWithoutDonationsInput, OrganizationUncheckedUpdateWithoutDonationsInput>
    create: XOR<OrganizationCreateWithoutDonationsInput, OrganizationUncheckedCreateWithoutDonationsInput>
  }

  export type OrganizationUpdateWithoutDonationsInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedDocuments?: DocumentUpdateManyWithoutOrganizationNestedInput
    advertisements?: AdvertisementUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutDonationsInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedDocuments?: DocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    advertisements?: AdvertisementUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type DropPointUpsertWithoutDonationsInput = {
    update: XOR<DropPointUpdateWithoutDonationsInput, DropPointUncheckedUpdateWithoutDonationsInput>
    create: XOR<DropPointCreateWithoutDonationsInput, DropPointUncheckedCreateWithoutDonationsInput>
  }

  export type DropPointUpdateWithoutDonationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    openingTime?: StringFieldUpdateOperationsInput | string
    closingTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: ManagerUpdateOneWithoutDropPointNestedInput
  }

  export type DropPointUncheckedUpdateWithoutDonationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    openingTime?: StringFieldUpdateOperationsInput | string
    closingTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PeripheralUpsertWithWhereUniqueWithoutDonationInput = {
    where: PeripheralWhereUniqueInput
    update: XOR<PeripheralUpdateWithoutDonationInput, PeripheralUncheckedUpdateWithoutDonationInput>
    create: XOR<PeripheralCreateWithoutDonationInput, PeripheralUncheckedCreateWithoutDonationInput>
  }

  export type PeripheralUpdateWithWhereUniqueWithoutDonationInput = {
    where: PeripheralWhereUniqueInput
    data: XOR<PeripheralUpdateWithoutDonationInput, PeripheralUncheckedUpdateWithoutDonationInput>
  }

  export type PeripheralUpdateManyWithWhereWithoutDonationInput = {
    where: PeripheralScalarWhereInput
    data: XOR<PeripheralUpdateManyMutationInput, PeripheralUncheckedUpdateManyWithoutPeripheralsInput>
  }

  export type PeripheralScalarWhereInput = {
    AND?: PeripheralScalarWhereInput | PeripheralScalarWhereInput[]
    OR?: PeripheralScalarWhereInput[]
    NOT?: PeripheralScalarWhereInput | PeripheralScalarWhereInput[]
    id?: StringFilter | string
    type?: StringFilter | string
    brand?: StringFilter | string
    model?: StringFilter | string
    condition?: StringFilter | string
    quantity?: IntFilter | number
    donationId?: StringFilter | string
  }

  export type DonationCreateWithoutPeripheralsInput = {
    id?: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
    organization: OrganizationCreateNestedOneWithoutDonationsInput
    dropPoint: DropPointCreateNestedOneWithoutDonationsInput
  }

  export type DonationUncheckedCreateWithoutPeripheralsInput = {
    id?: string
    organizationId: string
    dropPointId: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
  }

  export type DonationCreateOrConnectWithoutPeripheralsInput = {
    where: DonationWhereUniqueInput
    create: XOR<DonationCreateWithoutPeripheralsInput, DonationUncheckedCreateWithoutPeripheralsInput>
  }

  export type DonationUpsertWithoutPeripheralsInput = {
    update: XOR<DonationUpdateWithoutPeripheralsInput, DonationUncheckedUpdateWithoutPeripheralsInput>
    create: XOR<DonationCreateWithoutPeripheralsInput, DonationUncheckedCreateWithoutPeripheralsInput>
  }

  export type DonationUpdateWithoutPeripheralsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneRequiredWithoutDonationsNestedInput
    dropPoint?: DropPointUpdateOneRequiredWithoutDonationsNestedInput
  }

  export type DonationUncheckedUpdateWithoutPeripheralsInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    dropPointId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type UserCreateWithoutCityInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
  }

  export type UserUncheckedCreateWithoutCityInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
  }

  export type UserCreateOrConnectWithoutCityInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput>
  }

  export type UserCreateManyCityInputEnvelope = {
    data: UserCreateManyCityInput | UserCreateManyCityInput[]
  }

  export type AdvertisementCreateWithoutCityInput = {
    id?: string
    title: string
    content: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate: Date | string
    expiryDate: Date | string
    organization: OrganizationCreateNestedOneWithoutAdvertisementsInput
    interactions?: AdInteractionCreateNestedManyWithoutAdvertisementInput
  }

  export type AdvertisementUncheckedCreateWithoutCityInput = {
    id?: string
    organizationId: string
    title: string
    content: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate: Date | string
    expiryDate: Date | string
    interactions?: AdInteractionUncheckedCreateNestedManyWithoutAdvertisementInput
  }

  export type AdvertisementCreateOrConnectWithoutCityInput = {
    where: AdvertisementWhereUniqueInput
    create: XOR<AdvertisementCreateWithoutCityInput, AdvertisementUncheckedCreateWithoutCityInput>
  }

  export type AdvertisementCreateManyCityInputEnvelope = {
    data: AdvertisementCreateManyCityInput | AdvertisementCreateManyCityInput[]
  }

  export type UserUpsertWithWhereUniqueWithoutCityInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutCityInput, UserUncheckedUpdateWithoutCityInput>
    create: XOR<UserCreateWithoutCityInput, UserUncheckedCreateWithoutCityInput>
  }

  export type UserUpdateWithWhereUniqueWithoutCityInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutCityInput, UserUncheckedUpdateWithoutCityInput>
  }

  export type UserUpdateManyWithWhereWithoutCityInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter | string
    email?: StringFilter | string
    firstName?: StringFilter | string
    lastName?: StringFilter | string
    password?: StringFilter | string
    cityId?: StringFilter | string
    gender?: StringFilter | string
    contactNumber?: StringFilter | string
    profilePicture?: BytesNullableFilter | Buffer | null
    createdAt?: DateTimeFilter | Date | string
  }

  export type AdvertisementUpsertWithWhereUniqueWithoutCityInput = {
    where: AdvertisementWhereUniqueInput
    update: XOR<AdvertisementUpdateWithoutCityInput, AdvertisementUncheckedUpdateWithoutCityInput>
    create: XOR<AdvertisementCreateWithoutCityInput, AdvertisementUncheckedCreateWithoutCityInput>
  }

  export type AdvertisementUpdateWithWhereUniqueWithoutCityInput = {
    where: AdvertisementWhereUniqueInput
    data: XOR<AdvertisementUpdateWithoutCityInput, AdvertisementUncheckedUpdateWithoutCityInput>
  }

  export type AdvertisementUpdateManyWithWhereWithoutCityInput = {
    where: AdvertisementScalarWhereInput
    data: XOR<AdvertisementUpdateManyMutationInput, AdvertisementUncheckedUpdateManyWithoutAdvertisementsInput>
  }

  export type OrganizationCreateWithoutAdvertisementsInput = {
    id?: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber?: string | null
    verificationStatus?: string
    totalPoints?: number
    type: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    submittedDocuments?: DocumentCreateNestedManyWithoutOrganizationInput
    donations?: DonationCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutAdvertisementsInput = {
    id?: string
    organizationname: string
    email: string
    password: string
    address: string
    contactNumber: string
    secRegistrationNumber?: string | null
    verificationStatus?: string
    totalPoints?: number
    type: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
    submittedDocuments?: DocumentUncheckedCreateNestedManyWithoutOrganizationInput
    donations?: DonationUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutAdvertisementsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutAdvertisementsInput, OrganizationUncheckedCreateWithoutAdvertisementsInput>
  }

  export type CityCreateWithoutAdvertisementsInput = {
    id?: string
    name: string
    requiredPoints?: number | null
    users?: UserCreateNestedManyWithoutCityInput
  }

  export type CityUncheckedCreateWithoutAdvertisementsInput = {
    id?: string
    name: string
    requiredPoints?: number | null
    users?: UserUncheckedCreateNestedManyWithoutCityInput
  }

  export type CityCreateOrConnectWithoutAdvertisementsInput = {
    where: CityWhereUniqueInput
    create: XOR<CityCreateWithoutAdvertisementsInput, CityUncheckedCreateWithoutAdvertisementsInput>
  }

  export type AdInteractionCreateWithoutAdvertisementInput = {
    id?: string
    clickedAt?: Date | string
  }

  export type AdInteractionUncheckedCreateWithoutAdvertisementInput = {
    id?: string
    clickedAt?: Date | string
  }

  export type AdInteractionCreateOrConnectWithoutAdvertisementInput = {
    where: AdInteractionWhereUniqueInput
    create: XOR<AdInteractionCreateWithoutAdvertisementInput, AdInteractionUncheckedCreateWithoutAdvertisementInput>
  }

  export type AdInteractionCreateManyAdvertisementInputEnvelope = {
    data: AdInteractionCreateManyAdvertisementInput | AdInteractionCreateManyAdvertisementInput[]
  }

  export type OrganizationUpsertWithoutAdvertisementsInput = {
    update: XOR<OrganizationUpdateWithoutAdvertisementsInput, OrganizationUncheckedUpdateWithoutAdvertisementsInput>
    create: XOR<OrganizationCreateWithoutAdvertisementsInput, OrganizationUncheckedCreateWithoutAdvertisementsInput>
  }

  export type OrganizationUpdateWithoutAdvertisementsInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedDocuments?: DocumentUpdateManyWithoutOrganizationNestedInput
    donations?: DonationUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutAdvertisementsInput = {
    organizationname?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    secRegistrationNumber?: NullableStringFieldUpdateOperationsInput | string | null
    verificationStatus?: StringFieldUpdateOperationsInput | string
    totalPoints?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedDocuments?: DocumentUncheckedUpdateManyWithoutOrganizationNestedInput
    donations?: DonationUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type CityUpsertWithoutAdvertisementsInput = {
    update: XOR<CityUpdateWithoutAdvertisementsInput, CityUncheckedUpdateWithoutAdvertisementsInput>
    create: XOR<CityCreateWithoutAdvertisementsInput, CityUncheckedCreateWithoutAdvertisementsInput>
  }

  export type CityUpdateWithoutAdvertisementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    requiredPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    users?: UserUpdateManyWithoutCityNestedInput
  }

  export type CityUncheckedUpdateWithoutAdvertisementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    requiredPoints?: NullableFloatFieldUpdateOperationsInput | number | null
    users?: UserUncheckedUpdateManyWithoutCityNestedInput
  }

  export type AdInteractionUpsertWithWhereUniqueWithoutAdvertisementInput = {
    where: AdInteractionWhereUniqueInput
    update: XOR<AdInteractionUpdateWithoutAdvertisementInput, AdInteractionUncheckedUpdateWithoutAdvertisementInput>
    create: XOR<AdInteractionCreateWithoutAdvertisementInput, AdInteractionUncheckedCreateWithoutAdvertisementInput>
  }

  export type AdInteractionUpdateWithWhereUniqueWithoutAdvertisementInput = {
    where: AdInteractionWhereUniqueInput
    data: XOR<AdInteractionUpdateWithoutAdvertisementInput, AdInteractionUncheckedUpdateWithoutAdvertisementInput>
  }

  export type AdInteractionUpdateManyWithWhereWithoutAdvertisementInput = {
    where: AdInteractionScalarWhereInput
    data: XOR<AdInteractionUpdateManyMutationInput, AdInteractionUncheckedUpdateManyWithoutInteractionsInput>
  }

  export type AdInteractionScalarWhereInput = {
    AND?: AdInteractionScalarWhereInput | AdInteractionScalarWhereInput[]
    OR?: AdInteractionScalarWhereInput[]
    NOT?: AdInteractionScalarWhereInput | AdInteractionScalarWhereInput[]
    id?: StringFilter | string
    advertisementId?: StringFilter | string
    clickedAt?: DateTimeFilter | Date | string
  }

  export type AdvertisementCreateWithoutInteractionsInput = {
    id?: string
    title: string
    content: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate: Date | string
    expiryDate: Date | string
    organization: OrganizationCreateNestedOneWithoutAdvertisementsInput
    city: CityCreateNestedOneWithoutAdvertisementsInput
  }

  export type AdvertisementUncheckedCreateWithoutInteractionsInput = {
    id?: string
    organizationId: string
    cityId: string
    title: string
    content: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate: Date | string
    expiryDate: Date | string
  }

  export type AdvertisementCreateOrConnectWithoutInteractionsInput = {
    where: AdvertisementWhereUniqueInput
    create: XOR<AdvertisementCreateWithoutInteractionsInput, AdvertisementUncheckedCreateWithoutInteractionsInput>
  }

  export type AdvertisementUpsertWithoutInteractionsInput = {
    update: XOR<AdvertisementUpdateWithoutInteractionsInput, AdvertisementUncheckedUpdateWithoutInteractionsInput>
    create: XOR<AdvertisementCreateWithoutInteractionsInput, AdvertisementUncheckedCreateWithoutInteractionsInput>
  }

  export type AdvertisementUpdateWithoutInteractionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAdvertisementsNestedInput
    city?: CityUpdateOneRequiredWithoutAdvertisementsNestedInput
  }

  export type AdvertisementUncheckedUpdateWithoutInteractionsInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyOrganizationInput = {
    id?: string
    filename: string
    url: string
    uploadedBy: string
    createdAt?: Date | string
  }

  export type DonationCreateManyOrganizationInput = {
    id?: string
    dropPointId: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
  }

  export type AdvertisementCreateManyOrganizationInput = {
    id?: string
    cityId: string
    title: string
    content: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate: Date | string
    expiryDate: Date | string
  }

  export type DocumentUpdateWithoutOrganizationInput = {
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateWithoutOrganizationInput = {
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyWithoutSubmittedDocumentsInput = {
    filename?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationUpdateWithoutOrganizationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
    dropPoint?: DropPointUpdateOneRequiredWithoutDonationsNestedInput
    peripherals?: PeripheralUpdateManyWithoutDonationNestedInput
  }

  export type DonationUncheckedUpdateWithoutOrganizationInput = {
    dropPointId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
    peripherals?: PeripheralUncheckedUpdateManyWithoutDonationNestedInput
  }

  export type DonationUncheckedUpdateManyWithoutDonationsInput = {
    dropPointId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AdvertisementUpdateWithoutOrganizationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: CityUpdateOneRequiredWithoutAdvertisementsNestedInput
    interactions?: AdInteractionUpdateManyWithoutAdvertisementNestedInput
  }

  export type AdvertisementUncheckedUpdateWithoutOrganizationInput = {
    cityId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: AdInteractionUncheckedUpdateManyWithoutAdvertisementNestedInput
  }

  export type AdvertisementUncheckedUpdateManyWithoutAdvertisementsInput = {
    cityId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DonationCreateManyDropPointInput = {
    id?: string
    organizationId: string
    createdAt?: Date | string
    expectedDateOfArrival?: Date | string | null
    confirmedByName?: string | null
    confirmedByEmail?: string | null
    status?: string | null
    isSubmitted?: boolean
    points?: number | null
  }

  export type DonationUpdateWithoutDropPointInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
    organization?: OrganizationUpdateOneRequiredWithoutDonationsNestedInput
    peripherals?: PeripheralUpdateManyWithoutDonationNestedInput
  }

  export type DonationUncheckedUpdateWithoutDropPointInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expectedDateOfArrival?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    confirmedByName?: NullableStringFieldUpdateOperationsInput | string | null
    confirmedByEmail?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isSubmitted?: BoolFieldUpdateOperationsInput | boolean
    points?: NullableFloatFieldUpdateOperationsInput | number | null
    peripherals?: PeripheralUncheckedUpdateManyWithoutDonationNestedInput
  }

  export type DropPointCreateManyManagerInput = {
    id?: string
    name: string
    location: string
    openingTime: string
    closingTime: string
    description: string
    password?: string | null
  }

  export type DropPointUpdateWithoutManagerInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    openingTime?: StringFieldUpdateOperationsInput | string
    closingTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    donations?: DonationUpdateManyWithoutDropPointNestedInput
  }

  export type DropPointUncheckedUpdateWithoutManagerInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    openingTime?: StringFieldUpdateOperationsInput | string
    closingTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    donations?: DonationUncheckedUpdateManyWithoutDropPointNestedInput
  }

  export type DropPointUncheckedUpdateManyWithoutDropPointInput = {
    name?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    openingTime?: StringFieldUpdateOperationsInput | string
    closingTime?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PeripheralCreateManyDonationInput = {
    id?: string
    type: string
    brand: string
    model: string
    condition: string
    quantity?: number
  }

  export type PeripheralUpdateWithoutDonationInput = {
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type PeripheralUncheckedUpdateWithoutDonationInput = {
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type PeripheralUncheckedUpdateManyWithoutPeripheralsInput = {
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    condition?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateManyCityInput = {
    id?: string
    email: string
    firstName: string
    lastName: string
    password: string
    gender: string
    contactNumber: string
    profilePicture?: Buffer | null
    createdAt?: Date | string
  }

  export type AdvertisementCreateManyCityInput = {
    id?: string
    organizationId: string
    title: string
    content: string
    pointsSpent: number
    link: string
    imageUrl: Buffer
    isActive: boolean
    startDate: Date | string
    expiryDate: Date | string
  }

  export type UserUpdateWithoutCityInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutCityInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyWithoutUsersInput = {
    email?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    contactNumber?: StringFieldUpdateOperationsInput | string
    profilePicture?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdvertisementUpdateWithoutCityInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutAdvertisementsNestedInput
    interactions?: AdInteractionUpdateManyWithoutAdvertisementNestedInput
  }

  export type AdvertisementUncheckedUpdateWithoutCityInput = {
    organizationId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    pointsSpent?: FloatFieldUpdateOperationsInput | number
    link?: StringFieldUpdateOperationsInput | string
    imageUrl?: BytesFieldUpdateOperationsInput | Buffer
    isActive?: BoolFieldUpdateOperationsInput | boolean
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiryDate?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: AdInteractionUncheckedUpdateManyWithoutAdvertisementNestedInput
  }

  export type AdInteractionCreateManyAdvertisementInput = {
    id?: string
    clickedAt?: Date | string
  }

  export type AdInteractionUpdateWithoutAdvertisementInput = {
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdInteractionUncheckedUpdateWithoutAdvertisementInput = {
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdInteractionUncheckedUpdateManyWithoutInteractionsInput = {
    clickedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use OrganizationCountOutputTypeDefaultArgs instead
     */
    export type OrganizationCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = OrganizationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DropPointCountOutputTypeDefaultArgs instead
     */
    export type DropPointCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DropPointCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ManagerCountOutputTypeDefaultArgs instead
     */
    export type ManagerCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ManagerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DonationCountOutputTypeDefaultArgs instead
     */
    export type DonationCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DonationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityCountOutputTypeDefaultArgs instead
     */
    export type CityCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvertisementCountOutputTypeDefaultArgs instead
     */
    export type AdvertisementCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = AdvertisementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganizationDefaultArgs instead
     */
    export type OrganizationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = OrganizationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DropPointDefaultArgs instead
     */
    export type DropPointArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DropPointDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ManagerDefaultArgs instead
     */
    export type ManagerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = ManagerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DonationDefaultArgs instead
     */
    export type DonationArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = DonationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PeripheralDefaultArgs instead
     */
    export type PeripheralArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = PeripheralDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CityDefaultArgs instead
     */
    export type CityArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = CityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdvertisementDefaultArgs instead
     */
    export type AdvertisementArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = AdvertisementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdInteractionDefaultArgs instead
     */
    export type AdInteractionArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = AdInteractionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}